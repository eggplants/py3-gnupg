{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"py3-gnupg [!NOTE] THIS PROJECT IS A FORK OF python-gnupg , BUT FOR GnuPG 2 and Python3 ONLY. Installation pip install git+https://github.com/eggplants/py3-gnupg","title":"Home"},{"location":"#py3-gnupg","text":"[!NOTE] THIS PROJECT IS A FORK OF python-gnupg , BUT FOR GnuPG 2 and Python3 ONLY.","title":"py3-gnupg"},{"location":"#installation","text":"pip install git+https://github.com/eggplants/py3-gnupg","title":"Installation"},{"location":"CHANGELOG/","text":"Change log [!NOTE] GCnn refers to an issue nn on Google Code. 0.5.3 (future) Released: Not yet Fix #117: Add WKD (Web Key Directory) support for auto-locating keys. Thanks to Myzel394 for the patch. Fix #237: Ensure local variable is initialized even when an exception occurs. Fix #239: Remove logging of decryption result. 0.5.2 Released: 2023-12-12 Fix #228: Clarify documentation for encryption/decryption. Make I/O buffer size configurable via buffer_size attribute on a GPG instance. 0.5.1 Released: 2023-07-22 Added TRUST_EXPIRED to trust_keys . Thanks to Leif Liddy for the patch. Fix #206: Remove deprecated --always-trust in favour of --trust-model always Fix #208: Add status_detail attribute to result objects which is populated when the status is 'invalid recipient' (encryption/decryption) or 'invalid signer' (signing). This attribute will be set when the result object's status attribute is set to invalid recipient and will contain more information about the failure in the form of reason:ident where reason is a text description of the reason, and ident identifies the recipient key. Add scan_keys_mem() function to scan keys in a string. Thanks to Sky Moore for the patch. Fix #214: Handle multiple signatures when one of them is invalid or unverified. A problems attribute was added which holds problems reported by gpg during verification. This is a list of dictionaries, one for each reported problem. Each dictionary will have status and keyid keys indicating the problem and the corresponding key; other information in the dictionaries will be error specific. Fix #217: Use machine-readable interface to query the gpg version. Thanks to Justus Winter for the patch. Added the ability to export keys to a file. Thanks to Leif Liddy for the patch. 0.5.0 Released: 2022-08-23 Fixed #181: Added the ability to pass file paths to encrypt_file, decrypt_file, sign_file, verify_file, get_recipients_file and added import_keys_file. Fixed #183: Handle FAILURE and UNEXPECTED conditions correctly. Thanks to sebbASF for the patch. Fixed #185: Handle VALIDSIG arguments more robustly. Fixed #188: Remove handling of DECRYPTION_FAILED from Verify code, as not required there. Thanks to sebbASF for the patch. Fixed #190: Handle KEY_CREATED more robustly. Fixed #191: Handle NODATA messages during verification. Fixed #196: Don't log chunk data by default, as it could contain sensitive information (during decryption, for example). Added the ability to pass an environment to the gpg executable. Thanks to Edvard Rejthar for the patch. 0.4.9 Released: 2022-05-20 Fixed #161: Added a status attribute to the returned object from gen_key() which is set to 'ok' if a key was successfully created, or 'key not created' if that was reported by gpg, or None in any other case. Fixed #164: Provided the ability to add subkeys. Thanks to Daniel Kilimnik for the feature request and patch. Fixed #166: Added keygrip values to the information collected when keys are listed. Thanks to Daniel Kilimnik for the feature request and patch. Fixed #173: Added extra_args to send_keys(), recv_keys() and search_keys() to allow passing options relating to key servers. 0.4.8 Released: 2021-11-24 Fixed #147: Return gpg's return code in all result instances. Fixed #152: Add check for invalid file objects. Fixed #157: Provide more useful status message when a secret key is absent. Fixed #158: Added a get_recipients() API to find the recipients of an encrypted message without decrypting it. 0.4.7 Released: 2021-03-11 Fixed #129, #141: Added support for no passphrase during key generation. Fixed #143: Improved permission-denied test. Thanks to Elliot Cameron for the patch. Fixed #144: Updated logging to only show partial results. Fixed #146: Allowed a passphrase to be passed to import_keys(). Thanks to Chris de Graaf for the patch. 0.4.6 Released: 2020-04-17 Fixed #122: Updated documentation about gnupghome needing to be an existing directory. Fixed #123: Handled error conditions from gpg when calling trust_keys(). Fixed #124: Avoided an exception being raised when ImportResult.summary() was called after a failed recv_keys(). Fixed #128: Added ECC support by changing key generation parameters. (The Key-Length value isn't added if a curve is specified.) Fixed #130: Provided a mechanism to provide more complete error messages. Support for Python versions 3.5 and under is discontinued, except for Python 2.7. 0.4.5 Released: 2019-08-12 Fixed #107: Improved documentation. Fixed #112: Raised a ValueError if a gnupghome is specified which is not an existing directory. Fixed #113: Corrected stale link in the documentation. Fixed #116: Updated documentation to clarify when spurious key-expired/ signature-expired messages might be seen. Fixed #119: Added --yes to avoid pinentry when deleting secret keys with GnuPG >= 2.1. A warning is logged if gpg returns a non-zero return code. Added extra_args to import_keys . Added support for CI using AppVeyor. 0.4.4 Released: 2019-01-24 Fixed #108: Changed how any return value from the on_data callable is processed. In earlier versions, the return value was ignored. In this version, if the return value is False , the data received from gpg is not buffered. Otherwise (if the value is None or True , for example), the data is buffered as normal. This functionality can be used to do your own buffering, or to prevent buffering altogether. The on_data callable is also called once with an empty byte-string to signal the end of data from gpg . Fixed #97: Added an additional attribute check_fingerprint_collisions to GPG instances, which defaults to False . It seems that gpg is happy to have duplicate keys and fingerprints in a keyring, so we can't be too strict. A user can set this attribute of an instance to True to trigger a check for collisions. Fixed #111: With GnuPG 2.2.7 or later, provide the fingerprint of a signing key for a failed signature verification, if available. Fixed #21: For verification where multiple signatures are involved, a mapping of signature_ids to fingerprint, keyid, username, creation date, creation timestamp and expiry timestamp is provided. Added a check to disallow certain control characters ('r', 'n', NUL) in passphrases. 0.4.3 Released: 2018-06-13 Added --no-verbose to the gpg command line, in case verbose is specified in gpg.conf - we don't need verbose output. 0.4.2 Released: 2018-03-28 Fixed #81: Subkey information is now collected and returned in a subkey_info dictionary keyed by the subkey's ID. Fixed #84: GPG2 version is now correctly detected on OS X. Fixed #94: Added expect_passphrase password for use on GnuPG >= 2.1 when passing passphrase to gpg via pinentry. Fixed #95: Provided a trust_keys method to allow setting the trust level for keys. Thanks to William Foster for a suggested implementation. Made the exception message when the gpg executable is not found contain the path of the executable that was tried. Thanks to Kostis Anagnostopoulos for the suggestion. Fixed #100: Made the error message less categorical in the case of a failure with an unspecified reason, adding some information from gpg error codes when available. 0.4.1 Released: 2017-07-06 Updated message handling logic to no longer raise exceptions when a message isn't recognised. Thanks to Daniel Kahn Gillmor for the patch. Always use always use --fixed-list-mode , --batch and --with-colons . Thanks to Daniel Kahn Gillmor for the patch. Improved scan_keys() handling on GnuPG >= 2.1. Thanks to Daniel Kahn Gillmor for the patch. Improved test behaviour with GnuPG >= 2.1. Failures when deleting test directory trees are now ignored. Thanks to Daniel Kahn Gillmor for the patch. Added close_file keyword argument to verify_file to allow the file closing to be made optional. Current behaviour is maintained - close_file=False can be passed to skip closing the file being verified. Added the extra_args keyword parameter to allow custom arguments to be passed to the gpg executable. Instances of the GPG class now have an additional on_data attribute, which defaults to None . It can be set to a callable which will be called with a single argument - a binary chunk of data received from the gpg executable. The callable can do whatever it likes with the chunks passed to it - e.g. write them to a separate stream. The callable should not raise any exceptions (unless it wants the current operation to fail). 0.4.0 Released: 2017-01-29 Added support for KEY_CONSIDERED in more places - encryption / decryption, signing, key generation and key import. Partial fix for #32 (GPG 2.1 compatibility). Unfortunately, better support cannot be provided at this point, unless there are certain changes (relating to pinentry popups) in how GPG 2.1 works. Fixed #60: An IndexError was being thrown by scan_keys() . Ensured that utf-8 encoding is used when the --with-column mode is used. Thanks to Yann Leboulanger for the patch. list_keys() now uses --fixed-list-mode . Thanks to Werner Koch for the pointer. 0.3.9 Released: 2016-09-10 Fixed #38: You can now request information about signatures against keys. Thanks to SunDwarf for the suggestion and patch, which was used as a basis for this change. Fixed #49: When exporting keys, no attempt is made to decode the output when armor=False is specified. Fixed #53: A FAILURE message caused by passing an incorrect passphrase is handled. Handled EXPORTED and EXPORT_RES messages while exporting keys. Thanks to Marcel P\u00f6rner for the patch. Fixed #54: Improved error message shown when gpg is not available. Fixed #55: Added support for KEY_CONSIDERED while verifying. Avoided encoding problems with filenames under Windows. Thanks to K\u00e9vin Bernard-Allies for the patch. Fixed #57: Used a better mechanism for comparing keys. 0.3.8 Released: 2015-09-24 Fixed #22: handled PROGRESS messages during verification and signing. Fixed #26: handled PINENTRY_LAUNCHED messages during verification, decryption and key generation. Fixed #28: Allowed a default Name-Email to be computed even when neither of LOGNAME and USERNAME are in the environment. Fixed #29: Included test files missing from the tarball in previous versions. Fixed #39: On Python 3.x, passing a text instead of a binary stream caused file decryption to hang due to a UnicodeDecodeError . This has now been correctly handled: The decryption fails with a \"no data\" status. Fixed #41: Handled Unicode filenames correctly by encoding them on 2.x using the file system encoding. Fixed #43: handled PINENTRY_LAUNCHED messages during key export. Thanks to Ian Denhardt for looking into this. Hide the console window which appears on Windows when gpg is spawned. Thanks to K\u00e9vin Bernard-Allies for the patch. Subkey fingerprints are now captured. The returned value from the list_keys method now has a new attribute, key_map , which is a dictionary mapping key and subkey fingerprints to the corresponding key's dictionary. With this change, you don't need to iterate over the (potentially large) returned list to search for a key with a given fingerprint - the key_map dict will take you straight to the key info, whether the fingerprint you have is for a key or a subkey. Thanks to Nick Daly for the initial suggestion. 0.3.7 Released: 2014-12-07 Signed with PGP key: Vinay Sajip (CODE SIGNING KEY) \\< vinay_sajip@yahoo.co.uk > Key Fingerprint : CA74 9061 914E AC13 8E66 EADB 9147 B477 339A 9B86 Added an output keyword parameter to the sign and sign_file methods, to allow writing the signature to a file. Thanks to Jannis Leidel for the patch. Allowed specifying True for the sign keyword parameter, which allows use of the default key for signing and avoids having to specify a key id when it's desired to use the default. Thanks to Fabian Beutel for the patch. Used a uniform approach with subprocess on Windows and POSIX: shell=True is not used on either. When signing/verifying, the status is updated to reflect any expired or revoked keys or signatures. Handled 'NOTATION_NAME' and 'NOTATION_DATA' during verification. Fixed #1, #16, #18, #20: Quoting approach changed, since now shell=False. Fixed #14: Handled 'NEED_PASSPHRASE_PIN' message. Fixed #8: Added a scan_keys method to allow scanning of keys without the need to import into a keyring. Thanks to Venzen Khaosan for the suggestion. Fixed #5: Added '0x' prefix when searching for keys. Thanks to Aaron Toponce for the report. Fixed #4: Handled 'PROGRESS' message during encryption. Thanks to Daniel Mills for the report. Fixed #3: Changed default encoding to Latin-1. Fixed #2: Raised ValueError if no recipients were specified for an asymmetric encryption request. Handled 'UNEXPECTED' message during verification. Thanks to David Andersen for the patch. Replaced old range(len(X)) idiom with enumerate(). Refactored ListKeys / SearchKeys classes to maximise use of common functions. Fixed GC94: Added export-minimal and armor options when exporting keys. This addition was inadvertently left out of 0.3.6. 0.3.6 Released: 2014-02-05 Fixed GC82: Enabled fast random tests on gpg as well as gpg2. Fixed GC85: Avoided deleting temporary file to preserve its permissions. Fixed GC87: Avoided writing passphrase to log. Fixed GC95: Added verify_data() method to allow verification of signatures in memory. Fixed GC96: Regularised end-of-line characters. Fixed GC98: Rectified problems with earlier fix for shell injection. 0.3.5 Released: 2013-08-30 Added improved shell quoting to guard against shell injection. Fixed GC76: Added search_keys() and send_keys() methods. Fixed GC77: Allowed specifying a symmetric cipher algorithm. Fixed GC78: Fell back to utf-8 encoding when no other could be determined. Fixed GC79: Default key length is now 2048 bits. Fixed GC80: Removed the Name-Comment default in key generation. 0.3.4 Released: 2013-06-05 Fixed GC65: Fixed encoding exception when getting version. Fixed GC66: Now accepts sets and frozensets where appropriate. Fixed GC67: Hash algorithm now captured in sign result. Fixed GC68: Added support for --secret-keyring . Fixed GC70: Added support for multiple keyrings. 0.3.3 Released: 2013-03-11 Fixed GC57: Handled control characters in list_keys() . Fixed GC61: Enabled fast random for testing. Fixed GC62: Handled KEYEXPIRED status. Fixed GC63: Handled NO_SGNR status. 0.3.2 Released: 2013-01-17 Fixed GC56: Disallowed blank values in key generation. Fixed GC57: Handled colons and other characters in list_keys() . Fixed GC59/GC60: Handled INV_SGNR status during verification and removed calls requiring interactive password input from doctests. 0.3.1 Released: 2012-09-01 Fixed GC45: Allowed additional arguments to gpg executable. Fixed GC50: Used latin-1 encoding in tests when it's known to be required. Fixed GC51: Test now returns non-zero exit status on test failure. Fixed GC53: Now handles INV_SGNR and KEY_NOT_CREATED statuses. Fixed GC55: Verification and decryption now return trust level of signer in integer and text form. 0.3.0 Released: 2012-05-12 Fixed GC49: Reinstated Yann Leboulanger's change to support subkeys (accidentally left out in 0.2.7). 0.2.9 Released: 2012-03-29 Fixed GC36: Now handles CARDCTRL and POLICY_URL messages. Fixed GC40: Now handles DECRYPTION_INFO , DECRYPTION_FAILED and DECRYPTION_OKAY messages. The random_binary_data file is no longer shipped, but constructed by the test suite if needed. 0.2.8 Released: 2011-09-02 Fixed GC29: Now handles IMPORT_RES while verifying. Fixed GC30: Fixed an encoding problem. Fixed GC33: Quoted arguments for added safety. 0.2.7 Released: 2011-04-10 Fixed GC24: License is clarified as BSD. Fixed GC25: Incorporated Daniel Folkinshteyn's changes. Fixed GC26: Incorporated Yann Leboulanger's subkey change. Fixed GC27: Incorporated hysterix's support for symmetric encryption. Did some internal cleanups of Unicode handling. 0.2.6 Released: 2011-01-25 Fixed GC14: Should be able to accept passphrases from GPG-Agent. Fixed GC19: Should be able to create a detached signature. Fixed GC21/GC23: Better handling of less common responses from GPG. 0.2.5 Released: 2010-10-13 Fixed GC11/GC16: Detached signatures can now be created. Fixed GC3: Detached signatures can be verified. Fixed GC12: Better support for RSA and IDEA. Fixed GC15/GC17: Better support for non-ASCII input. 0.2.4 Released: 2010-03-01 Fixed GC9: Now allows encryption without armor and the ability to encrypt and decrypt directly to/from files. 0.2.3 Released: 2010-01-07 Fixed GC7: Made sending data to process threaded and added a test case. With a test data file used by the test case, the archive size has gone up to 5MB (the size of the test file). 0.2.2 Released: 2009-10-06 Fixed GC5/GC6: Added --batch when specifying --passphrase-fd and changed the name of the distribution file to add the python- prefix. 0.2.1 Released: 2009-08-07 Fixed GC2: Added handle_status() method to the ListKeys class. 0.2.0 Released: 2009-07-16 Various changes made to support Python 3.0. 0.1.0 Released: 2009-07-04 Initial release.","title":"Changelog"},{"location":"CHANGELOG/#change-log","text":"[!NOTE] GCnn refers to an issue nn on Google Code.","title":"Change log"},{"location":"CHANGELOG/#053-future","text":"Released: Not yet Fix #117: Add WKD (Web Key Directory) support for auto-locating keys. Thanks to Myzel394 for the patch. Fix #237: Ensure local variable is initialized even when an exception occurs. Fix #239: Remove logging of decryption result.","title":"0.5.3 (future)"},{"location":"CHANGELOG/#052","text":"Released: 2023-12-12 Fix #228: Clarify documentation for encryption/decryption. Make I/O buffer size configurable via buffer_size attribute on a GPG instance.","title":"0.5.2"},{"location":"CHANGELOG/#051","text":"Released: 2023-07-22 Added TRUST_EXPIRED to trust_keys . Thanks to Leif Liddy for the patch. Fix #206: Remove deprecated --always-trust in favour of --trust-model always Fix #208: Add status_detail attribute to result objects which is populated when the status is 'invalid recipient' (encryption/decryption) or 'invalid signer' (signing). This attribute will be set when the result object's status attribute is set to invalid recipient and will contain more information about the failure in the form of reason:ident where reason is a text description of the reason, and ident identifies the recipient key. Add scan_keys_mem() function to scan keys in a string. Thanks to Sky Moore for the patch. Fix #214: Handle multiple signatures when one of them is invalid or unverified. A problems attribute was added which holds problems reported by gpg during verification. This is a list of dictionaries, one for each reported problem. Each dictionary will have status and keyid keys indicating the problem and the corresponding key; other information in the dictionaries will be error specific. Fix #217: Use machine-readable interface to query the gpg version. Thanks to Justus Winter for the patch. Added the ability to export keys to a file. Thanks to Leif Liddy for the patch.","title":"0.5.1"},{"location":"CHANGELOG/#050","text":"Released: 2022-08-23 Fixed #181: Added the ability to pass file paths to encrypt_file, decrypt_file, sign_file, verify_file, get_recipients_file and added import_keys_file. Fixed #183: Handle FAILURE and UNEXPECTED conditions correctly. Thanks to sebbASF for the patch. Fixed #185: Handle VALIDSIG arguments more robustly. Fixed #188: Remove handling of DECRYPTION_FAILED from Verify code, as not required there. Thanks to sebbASF for the patch. Fixed #190: Handle KEY_CREATED more robustly. Fixed #191: Handle NODATA messages during verification. Fixed #196: Don't log chunk data by default, as it could contain sensitive information (during decryption, for example). Added the ability to pass an environment to the gpg executable. Thanks to Edvard Rejthar for the patch.","title":"0.5.0"},{"location":"CHANGELOG/#049","text":"Released: 2022-05-20 Fixed #161: Added a status attribute to the returned object from gen_key() which is set to 'ok' if a key was successfully created, or 'key not created' if that was reported by gpg, or None in any other case. Fixed #164: Provided the ability to add subkeys. Thanks to Daniel Kilimnik for the feature request and patch. Fixed #166: Added keygrip values to the information collected when keys are listed. Thanks to Daniel Kilimnik for the feature request and patch. Fixed #173: Added extra_args to send_keys(), recv_keys() and search_keys() to allow passing options relating to key servers.","title":"0.4.9"},{"location":"CHANGELOG/#048","text":"Released: 2021-11-24 Fixed #147: Return gpg's return code in all result instances. Fixed #152: Add check for invalid file objects. Fixed #157: Provide more useful status message when a secret key is absent. Fixed #158: Added a get_recipients() API to find the recipients of an encrypted message without decrypting it.","title":"0.4.8"},{"location":"CHANGELOG/#047","text":"Released: 2021-03-11 Fixed #129, #141: Added support for no passphrase during key generation. Fixed #143: Improved permission-denied test. Thanks to Elliot Cameron for the patch. Fixed #144: Updated logging to only show partial results. Fixed #146: Allowed a passphrase to be passed to import_keys(). Thanks to Chris de Graaf for the patch.","title":"0.4.7"},{"location":"CHANGELOG/#046","text":"Released: 2020-04-17 Fixed #122: Updated documentation about gnupghome needing to be an existing directory. Fixed #123: Handled error conditions from gpg when calling trust_keys(). Fixed #124: Avoided an exception being raised when ImportResult.summary() was called after a failed recv_keys(). Fixed #128: Added ECC support by changing key generation parameters. (The Key-Length value isn't added if a curve is specified.) Fixed #130: Provided a mechanism to provide more complete error messages. Support for Python versions 3.5 and under is discontinued, except for Python 2.7.","title":"0.4.6"},{"location":"CHANGELOG/#045","text":"Released: 2019-08-12 Fixed #107: Improved documentation. Fixed #112: Raised a ValueError if a gnupghome is specified which is not an existing directory. Fixed #113: Corrected stale link in the documentation. Fixed #116: Updated documentation to clarify when spurious key-expired/ signature-expired messages might be seen. Fixed #119: Added --yes to avoid pinentry when deleting secret keys with GnuPG >= 2.1. A warning is logged if gpg returns a non-zero return code. Added extra_args to import_keys . Added support for CI using AppVeyor.","title":"0.4.5"},{"location":"CHANGELOG/#044","text":"Released: 2019-01-24 Fixed #108: Changed how any return value from the on_data callable is processed. In earlier versions, the return value was ignored. In this version, if the return value is False , the data received from gpg is not buffered. Otherwise (if the value is None or True , for example), the data is buffered as normal. This functionality can be used to do your own buffering, or to prevent buffering altogether. The on_data callable is also called once with an empty byte-string to signal the end of data from gpg . Fixed #97: Added an additional attribute check_fingerprint_collisions to GPG instances, which defaults to False . It seems that gpg is happy to have duplicate keys and fingerprints in a keyring, so we can't be too strict. A user can set this attribute of an instance to True to trigger a check for collisions. Fixed #111: With GnuPG 2.2.7 or later, provide the fingerprint of a signing key for a failed signature verification, if available. Fixed #21: For verification where multiple signatures are involved, a mapping of signature_ids to fingerprint, keyid, username, creation date, creation timestamp and expiry timestamp is provided. Added a check to disallow certain control characters ('r', 'n', NUL) in passphrases.","title":"0.4.4"},{"location":"CHANGELOG/#043","text":"Released: 2018-06-13 Added --no-verbose to the gpg command line, in case verbose is specified in gpg.conf - we don't need verbose output.","title":"0.4.3"},{"location":"CHANGELOG/#042","text":"Released: 2018-03-28 Fixed #81: Subkey information is now collected and returned in a subkey_info dictionary keyed by the subkey's ID. Fixed #84: GPG2 version is now correctly detected on OS X. Fixed #94: Added expect_passphrase password for use on GnuPG >= 2.1 when passing passphrase to gpg via pinentry. Fixed #95: Provided a trust_keys method to allow setting the trust level for keys. Thanks to William Foster for a suggested implementation. Made the exception message when the gpg executable is not found contain the path of the executable that was tried. Thanks to Kostis Anagnostopoulos for the suggestion. Fixed #100: Made the error message less categorical in the case of a failure with an unspecified reason, adding some information from gpg error codes when available.","title":"0.4.2"},{"location":"CHANGELOG/#041","text":"Released: 2017-07-06 Updated message handling logic to no longer raise exceptions when a message isn't recognised. Thanks to Daniel Kahn Gillmor for the patch. Always use always use --fixed-list-mode , --batch and --with-colons . Thanks to Daniel Kahn Gillmor for the patch. Improved scan_keys() handling on GnuPG >= 2.1. Thanks to Daniel Kahn Gillmor for the patch. Improved test behaviour with GnuPG >= 2.1. Failures when deleting test directory trees are now ignored. Thanks to Daniel Kahn Gillmor for the patch. Added close_file keyword argument to verify_file to allow the file closing to be made optional. Current behaviour is maintained - close_file=False can be passed to skip closing the file being verified. Added the extra_args keyword parameter to allow custom arguments to be passed to the gpg executable. Instances of the GPG class now have an additional on_data attribute, which defaults to None . It can be set to a callable which will be called with a single argument - a binary chunk of data received from the gpg executable. The callable can do whatever it likes with the chunks passed to it - e.g. write them to a separate stream. The callable should not raise any exceptions (unless it wants the current operation to fail).","title":"0.4.1"},{"location":"CHANGELOG/#040","text":"Released: 2017-01-29 Added support for KEY_CONSIDERED in more places - encryption / decryption, signing, key generation and key import. Partial fix for #32 (GPG 2.1 compatibility). Unfortunately, better support cannot be provided at this point, unless there are certain changes (relating to pinentry popups) in how GPG 2.1 works. Fixed #60: An IndexError was being thrown by scan_keys() . Ensured that utf-8 encoding is used when the --with-column mode is used. Thanks to Yann Leboulanger for the patch. list_keys() now uses --fixed-list-mode . Thanks to Werner Koch for the pointer.","title":"0.4.0"},{"location":"CHANGELOG/#039","text":"Released: 2016-09-10 Fixed #38: You can now request information about signatures against keys. Thanks to SunDwarf for the suggestion and patch, which was used as a basis for this change. Fixed #49: When exporting keys, no attempt is made to decode the output when armor=False is specified. Fixed #53: A FAILURE message caused by passing an incorrect passphrase is handled. Handled EXPORTED and EXPORT_RES messages while exporting keys. Thanks to Marcel P\u00f6rner for the patch. Fixed #54: Improved error message shown when gpg is not available. Fixed #55: Added support for KEY_CONSIDERED while verifying. Avoided encoding problems with filenames under Windows. Thanks to K\u00e9vin Bernard-Allies for the patch. Fixed #57: Used a better mechanism for comparing keys.","title":"0.3.9"},{"location":"CHANGELOG/#038","text":"Released: 2015-09-24 Fixed #22: handled PROGRESS messages during verification and signing. Fixed #26: handled PINENTRY_LAUNCHED messages during verification, decryption and key generation. Fixed #28: Allowed a default Name-Email to be computed even when neither of LOGNAME and USERNAME are in the environment. Fixed #29: Included test files missing from the tarball in previous versions. Fixed #39: On Python 3.x, passing a text instead of a binary stream caused file decryption to hang due to a UnicodeDecodeError . This has now been correctly handled: The decryption fails with a \"no data\" status. Fixed #41: Handled Unicode filenames correctly by encoding them on 2.x using the file system encoding. Fixed #43: handled PINENTRY_LAUNCHED messages during key export. Thanks to Ian Denhardt for looking into this. Hide the console window which appears on Windows when gpg is spawned. Thanks to K\u00e9vin Bernard-Allies for the patch. Subkey fingerprints are now captured. The returned value from the list_keys method now has a new attribute, key_map , which is a dictionary mapping key and subkey fingerprints to the corresponding key's dictionary. With this change, you don't need to iterate over the (potentially large) returned list to search for a key with a given fingerprint - the key_map dict will take you straight to the key info, whether the fingerprint you have is for a key or a subkey. Thanks to Nick Daly for the initial suggestion.","title":"0.3.8"},{"location":"CHANGELOG/#037","text":"Released: 2014-12-07 Signed with PGP key: Vinay Sajip (CODE SIGNING KEY) \\< vinay_sajip@yahoo.co.uk > Key Fingerprint : CA74 9061 914E AC13 8E66 EADB 9147 B477 339A 9B86 Added an output keyword parameter to the sign and sign_file methods, to allow writing the signature to a file. Thanks to Jannis Leidel for the patch. Allowed specifying True for the sign keyword parameter, which allows use of the default key for signing and avoids having to specify a key id when it's desired to use the default. Thanks to Fabian Beutel for the patch. Used a uniform approach with subprocess on Windows and POSIX: shell=True is not used on either. When signing/verifying, the status is updated to reflect any expired or revoked keys or signatures. Handled 'NOTATION_NAME' and 'NOTATION_DATA' during verification. Fixed #1, #16, #18, #20: Quoting approach changed, since now shell=False. Fixed #14: Handled 'NEED_PASSPHRASE_PIN' message. Fixed #8: Added a scan_keys method to allow scanning of keys without the need to import into a keyring. Thanks to Venzen Khaosan for the suggestion. Fixed #5: Added '0x' prefix when searching for keys. Thanks to Aaron Toponce for the report. Fixed #4: Handled 'PROGRESS' message during encryption. Thanks to Daniel Mills for the report. Fixed #3: Changed default encoding to Latin-1. Fixed #2: Raised ValueError if no recipients were specified for an asymmetric encryption request. Handled 'UNEXPECTED' message during verification. Thanks to David Andersen for the patch. Replaced old range(len(X)) idiom with enumerate(). Refactored ListKeys / SearchKeys classes to maximise use of common functions. Fixed GC94: Added export-minimal and armor options when exporting keys. This addition was inadvertently left out of 0.3.6.","title":"0.3.7"},{"location":"CHANGELOG/#036","text":"Released: 2014-02-05 Fixed GC82: Enabled fast random tests on gpg as well as gpg2. Fixed GC85: Avoided deleting temporary file to preserve its permissions. Fixed GC87: Avoided writing passphrase to log. Fixed GC95: Added verify_data() method to allow verification of signatures in memory. Fixed GC96: Regularised end-of-line characters. Fixed GC98: Rectified problems with earlier fix for shell injection.","title":"0.3.6"},{"location":"CHANGELOG/#035","text":"Released: 2013-08-30 Added improved shell quoting to guard against shell injection. Fixed GC76: Added search_keys() and send_keys() methods. Fixed GC77: Allowed specifying a symmetric cipher algorithm. Fixed GC78: Fell back to utf-8 encoding when no other could be determined. Fixed GC79: Default key length is now 2048 bits. Fixed GC80: Removed the Name-Comment default in key generation.","title":"0.3.5"},{"location":"CHANGELOG/#034","text":"Released: 2013-06-05 Fixed GC65: Fixed encoding exception when getting version. Fixed GC66: Now accepts sets and frozensets where appropriate. Fixed GC67: Hash algorithm now captured in sign result. Fixed GC68: Added support for --secret-keyring . Fixed GC70: Added support for multiple keyrings.","title":"0.3.4"},{"location":"CHANGELOG/#033","text":"Released: 2013-03-11 Fixed GC57: Handled control characters in list_keys() . Fixed GC61: Enabled fast random for testing. Fixed GC62: Handled KEYEXPIRED status. Fixed GC63: Handled NO_SGNR status.","title":"0.3.3"},{"location":"CHANGELOG/#032","text":"Released: 2013-01-17 Fixed GC56: Disallowed blank values in key generation. Fixed GC57: Handled colons and other characters in list_keys() . Fixed GC59/GC60: Handled INV_SGNR status during verification and removed calls requiring interactive password input from doctests.","title":"0.3.2"},{"location":"CHANGELOG/#031","text":"Released: 2012-09-01 Fixed GC45: Allowed additional arguments to gpg executable. Fixed GC50: Used latin-1 encoding in tests when it's known to be required. Fixed GC51: Test now returns non-zero exit status on test failure. Fixed GC53: Now handles INV_SGNR and KEY_NOT_CREATED statuses. Fixed GC55: Verification and decryption now return trust level of signer in integer and text form.","title":"0.3.1"},{"location":"CHANGELOG/#030","text":"Released: 2012-05-12 Fixed GC49: Reinstated Yann Leboulanger's change to support subkeys (accidentally left out in 0.2.7).","title":"0.3.0"},{"location":"CHANGELOG/#029","text":"Released: 2012-03-29 Fixed GC36: Now handles CARDCTRL and POLICY_URL messages. Fixed GC40: Now handles DECRYPTION_INFO , DECRYPTION_FAILED and DECRYPTION_OKAY messages. The random_binary_data file is no longer shipped, but constructed by the test suite if needed.","title":"0.2.9"},{"location":"CHANGELOG/#028","text":"Released: 2011-09-02 Fixed GC29: Now handles IMPORT_RES while verifying. Fixed GC30: Fixed an encoding problem. Fixed GC33: Quoted arguments for added safety.","title":"0.2.8"},{"location":"CHANGELOG/#027","text":"Released: 2011-04-10 Fixed GC24: License is clarified as BSD. Fixed GC25: Incorporated Daniel Folkinshteyn's changes. Fixed GC26: Incorporated Yann Leboulanger's subkey change. Fixed GC27: Incorporated hysterix's support for symmetric encryption. Did some internal cleanups of Unicode handling.","title":"0.2.7"},{"location":"CHANGELOG/#026","text":"Released: 2011-01-25 Fixed GC14: Should be able to accept passphrases from GPG-Agent. Fixed GC19: Should be able to create a detached signature. Fixed GC21/GC23: Better handling of less common responses from GPG.","title":"0.2.6"},{"location":"CHANGELOG/#025","text":"Released: 2010-10-13 Fixed GC11/GC16: Detached signatures can now be created. Fixed GC3: Detached signatures can be verified. Fixed GC12: Better support for RSA and IDEA. Fixed GC15/GC17: Better support for non-ASCII input.","title":"0.2.5"},{"location":"CHANGELOG/#024","text":"Released: 2010-03-01 Fixed GC9: Now allows encryption without armor and the ability to encrypt and decrypt directly to/from files.","title":"0.2.4"},{"location":"CHANGELOG/#023","text":"Released: 2010-01-07 Fixed GC7: Made sending data to process threaded and added a test case. With a test data file used by the test case, the archive size has gone up to 5MB (the size of the test file).","title":"0.2.3"},{"location":"CHANGELOG/#022","text":"Released: 2009-10-06 Fixed GC5/GC6: Added --batch when specifying --passphrase-fd and changed the name of the distribution file to add the python- prefix.","title":"0.2.2"},{"location":"CHANGELOG/#021","text":"Released: 2009-08-07 Fixed GC2: Added handle_status() method to the ListKeys class.","title":"0.2.1"},{"location":"CHANGELOG/#020","text":"Released: 2009-07-16 Various changes made to support Python 3.0.","title":"0.2.0"},{"location":"CHANGELOG/#010","text":"Released: 2009-07-04 Initial release.","title":"0.1.0"},{"location":"reference/gnupg/","text":"Module gnupg A wrapper for the GnuPG gpg command. Portions of this module are derived from A.M. Kuchling's well-designed GPG.py, using Richard Jones' updated version 1.3, which can be found in the pycrypto CVS repository on Sourceforge: http://pycrypto.cvs.sourceforge.net/viewvc/pycrypto/gpg/GPG.py This module is not forward-compatible with amk's; some of the old interface has changed. For instance, since I've added decrypt functionality, I elected to initialize with a 'gnupghome' argument instead of 'keyring', so that gpg can find both the public and secret keyrings. I've also altered some of the returned objects in order for the caller to not have to know as much about the internals of the result classes. While the rest of ISconf is released under the GPL, I am releasing this single file under the same terms that A.M. Kuchling used for pycrypto. Steve Traugott, stevegt@terraluna.org Thu Jun 23 21:27:20 PDT 2005 This version of the module has been modified from Steve Traugott's version (see http://trac.t7a.org/isconf/browser/trunk/lib/python/isconf/GPG.py) by Vinay Sajip to make use of the subprocess module (Steve's version uses os.fork() and so does not work on Windows). Renamed to gnupg.py to avoid confusion with the previous versions. Modifications Copyright (C) 2008-2024 Vinay Sajip. All rights reserved. For the full documentation, see https://docs.red-dove.com/python-gnupg/ or https://gnupg.readthedocs.io/ View Source \" \"\" A wrapper for the GnuPG `gpg` command. Portions of this module are derived from A.M. Kuchling's well-designed GPG.py, using Richard Jones' updated version 1.3, which can be found in the pycrypto CVS repository on Sourceforge: http://pycrypto.cvs.sourceforge.net/viewvc/pycrypto/gpg/GPG.py This module is *not* forward-compatible with amk's; some of the old interface has changed. For instance, since I've added decrypt functionality, I elected to initialize with a 'gnupghome' argument instead of 'keyring', so that gpg can find both the public and secret keyrings. I've also altered some of the returned objects in order for the caller to not have to know as much about the internals of the result classes. While the rest of ISconf is released under the GPL, I am releasing this single file under the same terms that A.M. Kuchling used for pycrypto. Steve Traugott, stevegt@terraluna.org Thu Jun 23 21:27:20 PDT 2005 This version of the module has been modified from Steve Traugott's version (see http://trac.t7a.org/isconf/browser/trunk/lib/python/isconf/GPG.py) by Vinay Sajip to make use of the subprocess module (Steve's version uses os.fork() and so does not work on Windows). Renamed to gnupg.py to avoid confusion with the previous versions. Modifications Copyright (C) 2008-2024 Vinay Sajip. All rights reserved. For the full documentation, see https://docs.red-dove.com/python-gnupg/ or https://gnupg.readthedocs.io/ \"\" \" from __future__ import annotations from . gnupg import GPG __version__ = \"YANKED\" __author__ = \"Vinay Sajip\" __date__ = \"YANKED\" __all__ = ( \"GPG\" ,) Sub-modules gnupg.gnupg gnupg.handlers gnupg.helper Classes GPG class GPG ( * , gpgbinary : 'str' = 'gpg' , gnupghome : 'str | None' = None , verbose : 'bool' = False , use_agent : 'bool' = False , keyring : 'str | None' = None , options : 'None' = None , secret_keyring : 'None' = None , env : 'None' = None ) This class provides a high-level programmatic interface for gpg . View Source class GPG : \"\"\" This class provides a high - level programmatic interface for ` gpg ` . \"\"\" error_map = None decode_errors = \"strict\" buffer_size = 16384 # override in instance if needed result_map = MappingProxyType ( { \"crypt\" : CryptHandler , \"delete\" : DeleteResultHandler , \"generate\" : GenKeyHandler , \"addSubkey\" : AddSubkeyHandler , \"import\" : ImportResultHandler , \"send\" : SendResultHandler , \"list\" : ListKeysHandler , \"scan\" : ScanKeysHandler , \"search\" : SearchKeysHandler , \"sign\" : SignHandler , \"trust\" : TrustResultHandler , \"verify\" : VerifyHandler , \"export\" : ExportResultHandler , \"auto-locate-key\" : AutoLocateKeyHandler , }, ) \"A map of GPG operations to result object types.\" def __init__ ( # noqa : PLR0913 self , * , gpgbinary : str = \"gpg\" , gnupghome : str | None = None , verbose : bool = False , use_agent : bool = False , keyring : str | None = None , options : None = None , secret_keyring : None = None , env : None = None , ) -> None : \"\"\"Initialize a GPG process wrapper. Args : gpgbinary ( str ) : A pathname for the GPG binary to use . gnupghome ( str ) : A pathname to where we can find the public and private keyrings . The default is whatever ` gpg ` defaults to . keyring ( str | list ) : The name of alternative keyring file to use , or a list of such keyring files . If specified , the default keyring is not used . options ( list ) : A list of additional options to pass to the GPG binary . secret_keyring ( str | list ) : The name of an alternative secret keyring file to use , or a list of such keyring files . env ( dict ) : A dict of environment variables to be used for the GPG subprocess . \"\"\" self . gpgbinary = gpgbinary self . gnupghome = None if not gnupghome else Path ( gnupghome ) self . env = env # issue 112: fail if the specified value isn't a directory if self . gnupghome and not self . gnupghome . is_dir () : msg = f \"gnupghome should be a directory (it isn't): {self.gnupghome}\" raise ValueError ( msg ) # Allow passing a string or another iterable. Make it uniformly # a list of keyring filenames if keyring and isinstance ( keyring , str ) : keyring = [ keyring ] self . keyring = keyring # Allow passing a string or another iterable. Make it uniformly # a list of keyring filenames if secret_keyring and isinstance ( secret_keyring , str ) : # pragma : no cover secret_keyring = [ secret_keyring ] self . secret_keyring = secret_keyring self . verbose = verbose self . use_agent = use_agent if isinstance ( options , str ) : # pragma : no cover options = [ options ] self . options = options self . on_data = None # or a callable - will be called with data chunks # Changed in 0.3.7 to use Latin-1 encoding rather than # locale.getpreferredencoding falling back to sys.stdin.encoding # falling back to utf-8, because gpg itself uses latin-1 as the default # encoding. self . encoding = \"latin-1\" if self . gnupghome and not self . gnupghome . is_dir () : # pragma : no cover self . gnupghome . mkdir ( mode = 0 o700 , parents = True ) try : p = self . _open_subprocess ([ \"--list-config\" , \"--with-colons\" ]) except OSError : msg = f \"Unable to run gpg ({self.gpgbinary}) - it may not be available.\" logger . exception ( msg ) raise OSError ( msg ) from None result = self . result_map [ \"verify\" ]( self ) # any result will do for this self . _collect_output ( p , result , stdin = p . stdin ) if p . returncode != 0 : # pragma : no cover msg = f \"Error invoking gpg: {p.returncode}: {result.stderr}\" raise ValueError ( msg ) m = VERSION_RE . match ( result . data ) if not m : # pragma : no cover self . version = None else : dot = \".\" . encode ( \"ascii\" ) self . version = tuple ([ int ( s ) for s in m . groups ()[ 0 ]. split ( dot )]) # See issue #97. It seems gpg allow duplicate keys in keyrings, so we # can't be too strict. self . check_fingerprint_collisions = False def make_args ( self , args : list [ str ], * , passphrase : bool | None = False ) -> list [ str ] : \"\"\" Make a list of command line elements for GPG . The value of `` args `` will be appended . The `` passphrase `` argument needs to be True if a passphrase will be sent to ` gpg ` , else False . Args : args ( list [ str ]) : A list of arguments . passphrase ( str ) : The passphrase to use . \"\"\" cmd = [ self . gpgbinary , \"--status-fd\" , \"2\" , \"--no-tty\" , \"--no-verbose\" ] if \"DEBUG_IPC\" in os . environ : # pragma : no cover cmd . extend ([ \"--debug\" , \"ipc\" ]) if passphrase and hasattr ( self , \"version\" ) and self . version >= ( 2 , 1 ) : cmd [ 1 : 1 ] = [ \"--pinentry-mode\" , \"loopback\" ] cmd . extend ([ \"--fixed-list-mode\" , \"--batch\" , \"--with-colons\" ]) if self . gnupghome : cmd . extend ([ \"--homedir\" , str ( self . gnupghome )]) if self . keyring : cmd . append ( \"--no-default-keyring\" ) for fn in self . keyring : cmd . extend ([ \"--keyring\" , fn ]) if self . secret_keyring : # pragma : no cover for fn in self . secret_keyring : cmd . extend ([ \"--secret-keyring\" , fn ]) if passphrase : cmd . extend ([ \"--passphrase-fd\" , \"0\" ]) if self . use_agent : # pragma : no cover cmd . append ( \"--use-agent\" ) if self . options : cmd . extend ( self . options ) cmd . extend ( args ) return cmd def _open_subprocess ( self , args : list [ str ], * , passphrase : bool | None = False ) -> Popen : # Internal method: open a pipe to a GPG subprocess and return # the file objects for communicating with it. from subprocess import list2cmdline as debug_print cmd = self . make_args ( args , passphrase = passphrase ) if self . verbose : # pragma : no cover pass if not STARTUPINFO : si = None else : # pragma : no cover si = STARTUPINFO () si . dwFlags = STARTF_USESHOWWINDOW si . wShowWindow = SW_HIDE result = Popen ( # noqa : S603 cmd , shell = False , stdin = PIPE , stdout = PIPE , stderr = PIPE , startupinfo = si , env = self . env , ) logger . debug ( \"%s: %s\" , result . pid , debug_print ( cmd )) return result def _read_response ( self , stream : IO , result : StatusHandler ) -> None : # Internal method: reads all the stderr output from GPG, taking notice # only of lines that begin with the magic [GNUPG:] prefix. # # Calls methods on the response object for each valid token found, # with the arg being the remainder of the status line. lines = [] while True : line = stream . readline () if len ( line ) == 0 : break lines . append ( line ) line = line . rstrip () if self . verbose : # pragma : no cover pass logger . debug ( \"%s\" , line ) if line [ 0 : 9 ] == \"[GNUPG:] \" : # Chop off the prefix line = line [ 9 : ]. split ( None , 1 ) keyword = line [ 0 ] value = line [ 1 ] if len ( line ) > 1 else \"\" result . handle_status ( keyword , value ) result . stderr = \"\" . join ( lines ) def _read_data ( self , stream : IO , result : StatusHandler , * , on_data : Callable [[ str | bytes ], Any ] | None = None , buffer_size : int = 1024 , ) -> None : # Read the contents of the file from GPG's stdout assert buffer_size > 0 # noqa : S101 chunks = [] while True : data = stream . read ( buffer_size ) if len ( data ) == 0 : if on_data : on_data ( data ) break if log_everything : msg = f \"chunk: {data[:256]!r}\" logger . debug ( msg ) append = True if on_data : append = on_data ( data ) is not False if append : chunks . append ( data ) # Join using b'' or '', as appropriate result . data = type ( data )(). join ( chunks ) def _collect_output ( self , process : Popen , result : StatusHandler , writer : threading . Thread | None = None , stdin : BufferedWriter | None = None , ) -> int : \"\"\" Drain the subprocesses output streams , writing the collected output to the result . If a writer thread ( writing to the subprocess ) is given , make sure it ' s joined before returning . If a stdin stream is given , close it before returning . \"\"\" stderr = codecs . getreader ( self . encoding )( process . stderr ) rr = threading . Thread ( target = self . _read_response , args = ( stderr , result )) rr . daemon = True logger . debug ( \"stderr reader: %r\" , rr ) rr . start () stdout = process . stdout dr = threading . Thread ( target = self . _read_data , args = ( stdout , result ), kwargs = { \"on_data\" : self . on_data , \"buffer_size\" : self . buffer_size }, ) dr . daemon = True logger . debug ( \"stdout reader: %r\" , dr ) dr . start () dr . join () rr . join () if writer is not None : writer . join ( 0.01 ) process . wait () result . returncode = rc = process . returncode if rc != 0 : logger . warning ( \"gpg returned a non-zero error code: %d\" , rc ) if stdin is not None : with contextlib . suppress ( OSError ) : stdin . close () stderr . close () stdout . close () return rc def is_valid_file ( self , fileobj : str | bytes | BufferedReader | TextIOWrapper | BytesIO ) -> bool : \"\"\" A simplistic check for a file - like object . Args : fileobj ( object ) : The object to test . Returns : bool : `` True `` if it ' s a file - like object , else `` False `` . \"\"\" return hasattr ( fileobj , \"read\" ) def _get_fileobj ( self , fileobj_or_path : str | bytes | BufferedReader | TextIOWrapper | BytesIO , ) -> BufferedReader | BytesIO | TextIOWrapper : if self . is_valid_file ( fileobj_or_path ) : result = fileobj_or_path elif not isinstance ( fileobj_or_path , str ) : msg = f \"Not a valid file or path: {fileobj_or_path}\" raise TypeError ( msg ) elif not Path ( fileobj_or_path ). exists () : msg = f \"No such file: {fileobj_or_path}\" raise ValueError ( msg ) else : result = Path ( fileobj_or_path ). open ( \"rb\" ) # noqa : SIM115 return result def _handle_io ( self , args : list [ str ], fileobj_or_path : str | bytes | BufferedReader | TextIOWrapper | BytesIO , result : StatusHandler , * , passphrase : str | None = None , binary : bool = False , ) -> StatusHandler : \"Handle a call to GPG - pass input data, collect output data\" # Handle a basic data call - pass data to GPG, handle the output # including status information. Garbage In, Garbage Out :) fileobj = self . _get_fileobj ( fileobj_or_path ) try : p = self . _open_subprocess ( args , passphrase = passphrase is not None ) stdin = p . stdin if binary else codecs . getwriter ( self . encoding )( p . stdin ) writer = None # See issue # 237 if passphrase : _write_passphrase ( stdin , passphrase , self . encoding ) writer = _threaded_copy_data ( fileobj , stdin , self . buffer_size ) self . _collect_output ( p , result , writer , stdin ) return result finally : if writer : writer . join ( 0.01 ) if fileobj is not fileobj_or_path : fileobj . close () # # SIGNATURE METHODS # def sign ( self , message : bytes , ** kwargs : str | bool | list [ str ]) -> SignHandler : \"\"\" Sign a message . This method delegates most of the work to the ` sign_file () ` method . Args : message ( str | bytes ) : The data to sign . kwargs ( dict ) : Keyword arguments , which are passed to ` sign_file () ` : * keyid ( str ) : The key id of the signer . * passphrase ( str ) : The passphrase for the key . * clearsign ( bool ) : Whether to use clear signing . * detach ( bool ) : Whether to produce a detached signature . * binary ( bool ) : Whether to produce a binary signature . * output ( str ) : The path to write a detached signature to . * extra_args ( list [ str ]) : Additional arguments to pass to ` gpg ` . \"\"\" f = _make_binary_stream ( message , self . encoding ) result = self . sign_file ( f , ** kwargs ) f . close () return result def set_output_without_confirmation ( self , args : list [ str ], output : str ) -> None : \"\"\" If writing to a file which exists , avoid a confirmation message by updating the * args * value in place to set the output path and avoid any cpmfirmation prompt . Args : args ( list [ str ]) : A list of arguments . output ( str ) : The path to the outpur file . \"\"\" if Path ( output ). exists () : # We need to avoid an overwrite confirmation message args . extend ([ \"--yes\" ]) args . extend ([ \"--output\" , output ]) def is_valid_passphrase ( self , passphrase : str ) -> bool : \"\"\" Confirm that the passphrase doesn ' t contain newline - type characters - it is passed in a pipe to ` gpg ` , and so not checking could lead to spoofing attacks by passing arbitrary text after passphrase and newline . Args : passphrase ( str ) : The passphrase to test . Returns : bool : `` True `` if it ' s a valid passphrase , else `` False `` . \"\"\" return \" \\n \" not in passphrase and \" \\r \" not in passphrase and \" \\x00 \" not in passphrase def sign_file ( # noqa : PLR0913 self , fileobj_or_path : BufferedReader | BytesIO | str , * , keyid : str | None = None , passphrase : str | None = None , clearsign : bool = True , detach : bool = False , binary : bool = False , output : str | None = None , extra_args : None = None , ) -> SignHandler : \"\"\" Sign data in a file or file - like object . Args : fileobj_or_path ( str | file ) : The file or file - like object to sign . keyid ( str ) : The key id of the signer . passphrase ( str ) : The passphrase for the key . clearsign ( bool ) : Whether to use clear signing . detach ( bool ) : Whether to produce a detached signature . binary ( bool ) : Whether to produce a binary signature . output ( str ) : The path to write a detached signature to . extra_args ( list [ str ]) : Additional arguments to pass to ` gpg ` . \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ) : msg = \"Invalid passphrase\" raise ValueError ( msg ) logger . debug ( \"sign_file: %s\" , fileobj_or_path ) args = [ \"-s\" ] if binary else [ \"-sa\" ] # You can't specify detach-sign and clearsign together: gpg ignores # the detach-sign in that case. if detach : args . append ( \"--detach-sign\" ) elif clearsign : args . append ( \"--clearsign\" ) if keyid : args . extend ([ \"--default-key\" , keyid ]) if output : # pragma : no cover # write the output to a file with the specified name self . set_output_without_confirmation ( args , output ) if extra_args : # pragma : no cover args . extend ( extra_args ) result = self . result_map [ \"sign\" ]( self ) # We could use _handle_io here except for the fact that if the # passphrase is bad, gpg bails and you can't write the message. fileobj = self . _get_fileobj ( fileobj_or_path ) p = self . _open_subprocess ( args , passphrase = passphrase is not None ) try : stdin = p . stdin if passphrase : _write_passphrase ( stdin , passphrase , self . encoding ) writer = _threaded_copy_data ( fileobj , stdin , self . buffer_size ) except OSError : # pragma : no cover logging . exception ( \"error writing message\" ) writer = None finally : if writer : writer . join ( 0.01 ) if fileobj is not fileobj_or_path : fileobj . close () self . _collect_output ( p , result , writer , stdin ) return result def verify ( self , data : bytes , ** kwargs : str | bool | list [ str ] | IO ) -> VerifyHandler : \"\"\" Verify the signature on the contents of the string * data * . This method delegates most of the work to ` verify_file () ` . Args : data ( str | bytes ) : The data to verify . kwargs ( dict ) : Keyword arguments , which are passed to ` verify_file () ` : * fileobj_or_path ( str | file ) : A path to a signature , or a file - like object containing one . * data_filename ( str ) : If the signature is a detached one , the path to the data that was signed . * close_file ( bool ) : If a file - like object is passed in , whether to close it . * extra_args ( list [ str ]) : Additional arguments to pass to ` gpg ` . \"\"\" f = _make_binary_stream ( data , self . encoding ) result = self . verify_file ( f , ** kwargs ) f . close () return result def verify_file ( self , fileobj_or_path : BytesIO | str , * , data_filename : str | None = None , close_file : bool = True , extra_args : None = None , ) -> VerifyHandler : \"\"\" Verify a signature . Args : fileobj_or_path ( str | file ) : A path to a signature , or a file - like object containing one . data_filename ( str ) : If the signature is a detached one , the path to the data that was signed . close_file ( bool ) : If a file - like object is passed in , whether to close it . extra_args ( list [ str ]) : Additional arguments to pass to ` gpg ` . \"\"\" logger . debug ( \"verify_file: %r, %r\" , fileobj_or_path , data_filename ) result = self . result_map [ \"verify\" ]( self ) args = [ \"--verify\" ] if extra_args : # pragma : no cover args . extend ( extra_args ) if data_filename is None : self . _handle_io ( args , fileobj_or_path , result , binary = True ) else : logger . debug ( \"Handling detached verification\" ) import tempfile fd , fn = tempfile . mkstemp ( prefix = \"pygpg-\" ) s = fileobj_or_path . read () if close_file : fileobj_or_path . close () logger . debug ( \"Wrote to temp file: %r\" , s ) os . write ( fd , s ) os . close ( fd ) args . append ( fn ) args . append ( data_filename ) try : p = self . _open_subprocess ( args ) self . _collect_output ( p , result , stdin = p . stdin ) finally : Path ( fn ). unlink () return result def verify_data ( self , sig_filename : str , data : bytes , extra_args : None = None ) -> VerifyHandler : \"\"\" Verify the signature in sig_filename against data in memory Args : sig_filename ( str ) : The path to a signature . data ( str | bytes ) : The data to be verified . extra_args ( list [ str ]) : Additional arguments to pass to ` gpg ` . \"\"\" logger . debug ( \"verify_data: %r, %r ...\" , sig_filename , data [ : 16 ]) result = self . result_map [ \"verify\" ]( self ) args = [ \"--verify\" ] if extra_args : # pragma : no cover args . extend ( extra_args ) args . extend ([ sig_filename , \"-\" ]) stream = BytesIO ( data ) self . _handle_io ( args , stream , result , binary = True ) return result # # KEY MANAGEMENT # def import_keys ( self , key_data : str | bytes , extra_args : None = None , passphrase : None = None , ) -> ImportResultHandler : \"\"\" Import the key_data into our keyring . Args : key_data ( str | bytes ) : The key data to import . passphrase ( str ) : The passphrase to use . extra_args ( list [ str ]) : Additional arguments to pass to ` gpg ` . \"\"\" result = self . result_map [ \"import\" ]( self ) logger . debug ( \"import_keys: %r\" , key_data [ : 256 ]) data = _make_binary_stream ( key_data , self . encoding ) args = [ \"--import\" ] if extra_args : # pragma : no cover args . extend ( extra_args ) self . _handle_io ( args , data , result , passphrase = passphrase , binary = True ) logger . debug ( \"import_keys result: %r\" , result . __dict__ ) data . close () return result def import_keys_file ( self , key_path : str , ** kwargs : str | list [ str ]) -> ImportResultHandler : \"\"\" Import the key data in key_path into our keyring . Args : key_path ( str ) : A path to the key data to be imported . \"\"\" with Path ( key_path ). open ( \"rb\" ) as f : return self . import_keys ( f . read (), ** kwargs ) def recv_keys ( self , keyserver : str , * keyids : str , ** kwargs : list [ str ]) -> ImportResultHandler : \"\"\" Import one or more keys from a keyserver . Args : keyserver ( str ) : The key server hostname . keyids ( str ) : A list of key ids to receive . \"\"\" result = self . result_map [ \"import\" ]( self ) logger . debug ( \"recv_keys: %r\" , keyids ) data = _make_binary_stream ( \"\" , self . encoding ) args = [ \"--keyserver\" , keyserver ] if \"extra_args\" in kwargs : # pragma : no cover args . extend ( kwargs [ \"extra_args\" ]) args . append ( \"--recv-keys\" ) args . extend ( list ( keyids )) self . _handle_io ( args , data , result , binary = True ) logger . debug ( \"recv_keys result: %r\" , result . __dict__ ) data . close () return result # This function isn't exercised by tests, to avoid polluting external # key servers with test keys def send_keys ( self , keyserver : str , * keyids : str , ** kwargs : list [ str ]) -> StatusHandler : # pragma : no cover \"\"\" Send one or more keys to a keyserver . Args : keyserver ( str ) : The key server hostname . keyids ( list [ str ]) : A list of key ids to send . \"\"\" # Note: it's not practical to test this function without sending # arbitrary data to live keyservers. result = self . result_map [ \"send\" ]( self ) logger . debug ( \"send_keys: %r\" , keyids ) data = _make_binary_stream ( \"\" , self . encoding ) args = [ \"--keyserver\" , keyserver ] if \"extra_args\" in kwargs : args . extend ( kwargs [ \"extra_args\" ]) args . append ( \"--send-keys\" ) args . extend ( list ( keyids )) self . _handle_io ( args , data , result , binary = True ) logger . debug ( \"send_keys result: %r\" , result . __dict__ ) data . close () return result def delete_keys ( self , fingerprints : str , * , secret : bool = False , passphrase : str | None = None , expect_passphrase : bool = True , exclamation_mode : bool = False , ) -> DeleteResultHandler : \"\"\" Delete the indicated keys . Args : fingerprints ( str | list [ str ]) : The keys to delete . secret ( bool ) : Whether to delete secret keys . passphrase ( str ) : The passphrase to use . expect_passphrase ( bool ) : Whether a passphrase is expected . exclamation_mode ( bool ) : If specified , a ` '!' ` is appended to each fingerprint . This deletes only a subkey or an entire key , depending on what the fingerprint refers to . .. note :: Passphrases Since GnuPG 2.1 , you can ' t delete secret keys without providing a passphrase . However , if you ' re expecting the passphrase to go to ` gpg ` via pinentry , you should specify expect_passphrase = False . ( It ' s only checked for GnuPG >= 2.1 ). \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ) : # pragma : no cover msg = \"Invalid passphrase\" raise ValueError ( msg ) which = \"key\" if secret : # pragma : no cover if self . version >= ( 2 , 1 ) and passphrase is None and expect_passphrase : msg = \"For GnuPG >= 2.1, deleting secret keys needs a passphrase to be provided\" raise ValueError ( msg ) which = \"secret-key\" fingerprints = list ( fingerprints ) if _is_sequence ( fingerprints ) else [ fingerprints ] if exclamation_mode : fingerprints = [ f + \"!\" for f in fingerprints ] args = [ f \"--delete-{which}\" ] if secret and self . version >= ( 2 , 1 ) : args . insert ( 0 , \"--yes\" ) args . extend ( fingerprints ) result = self . result_map [ \"delete\" ]( self ) if not secret or self . version < ( 2 , 1 ) : p = self . _open_subprocess ( args ) self . _collect_output ( p , result , stdin = p . stdin ) else : # Need to send in a passphrase. f = _make_binary_stream ( \"\" , self . encoding ) try : self . _handle_io ( args , f , result , passphrase = passphrase , binary = True ) finally : f . close () return result def export_keys ( # noqa : PLR0913 self , keyids : str | list [ str ], * , secret : bool = False , armor : bool = True , minimal : bool = False , passphrase : str | None = None , expect_passphrase : bool = True , output : None = None , ) -> str | bytes : \"\"\" Export the indicated keys . A ' keyid ' is anything ` gpg ` accepts . Args : keyids ( str | list [ str ]) : A single keyid or a list of them . secret ( bool ) : Whether to export secret keys . armor ( bool ) : Whether to ASCII - armor the output . minimal ( bool ) : Whether to pass ` -- export - options export - minimal ` to ` gpg ` . passphrase ( str ) : The passphrase to use . expect_passphrase ( bool ) : Whether a passphrase is expected . output ( str ) : If specified , the path to write the exported key ( s ) to . .. note :: Passphrases Since GnuPG 2.1 , you can ' t export secret keys without providing a passphrase . However , if you ' re expecting the passphrase to go to ` gpg ` via pinentry , you should specify expect_passphrase = False . ( It ' s only checked for GnuPG >= 2.1 ). \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ) : # pragma : no cover msg = \"Invalid passphrase\" raise ValueError ( msg ) which = \"\" if secret : which = \"-secret-key\" if self . version >= ( 2 , 1 ) and passphrase is None and expect_passphrase : # pragma : no cover msg = \"For GnuPG >= 2.1, exporting secret keys needs a passphrase to be provided\" raise ValueError ( msg ) keyids = list ( keyids ) if _is_sequence ( keyids ) else [ keyids ] args = [ f \"--export{which}\" ] if armor : args . append ( \"--armor\" ) if minimal : # pragma : no cover args . extend ([ \"--export-options\" , \"export-minimal\" ]) if output : # pragma : no cover # write the output to a file with the specified name self . set_output_without_confirmation ( args , output ) args . extend ( keyids ) # gpg --export produces no status-fd output; stdout will be # empty in case of failure result = self . result_map [ \"export\" ]( self ) if not secret or self . version < ( 2 , 1 ) : p = self . _open_subprocess ( args ) self . _collect_output ( p , result , stdin = p . stdin ) else : # Need to send in a passphrase. f = _make_binary_stream ( \"\" , self . encoding ) try : self . _handle_io ( args , f , result , passphrase = passphrase , binary = True ) finally : f . close () logger . debug ( \"export_keys result[:100]: %r\" , result . data [ : 100 ]) # Issue #49: Return bytes if armor not specified, else text result = result . data if armor : result = result . decode ( self . encoding , self . decode_errors ) return result def _decode_result ( self , result : ListKeysHandler | ScanKeysHandler , ) -> ListKeysHandler | ScanKeysHandler : lines = result . data . decode ( self . encoding , self . decode_errors ). splitlines () valid_keywords = \"pub uid sec fpr sub ssb sig grp\" . split () for line in lines : if self . verbose : # pragma : no cover pass logger . debug ( \"line: %r\" , line . rstrip ()) if not line : # pragma : no cover break fields = line . strip (). split ( \":\" ) if not fields : # pragma : no cover continue keyword = fields [ 0 ] if keyword in valid_keywords : getattr ( result , keyword )( fields ) return result def _get_list_output ( self , p : Popen , kind : str ) -> ListKeysHandler | ScanKeysHandler : # Get the response information result = self . result_map [ kind ]( self ) self . _collect_output ( p , result , stdin = p . stdin ) return self . _decode_result ( result ) def list_keys ( self , * , secret : bool = False , keys : str | list [ str ] | None = None , sigs : bool = False , ) -> ListKeysHandler : \"\"\" List the keys currently in the keyring . Args : secret ( bool ) : Whether to list secret keys . keys ( str | list [ str ]) : A list of key ids to match . sigs ( bool ) : Whether to include signature information . Returns : list [ dict ] : A list of dictionaries with key information . \"\"\" which = \"secret-keys\" if secret else \"sigs\" if sigs else \"keys\" args = [ f \"--list-{which}\" , \"--fingerprint\" , \"--fingerprint\" ] # get subkey FPs , too if self . version >= ( 2 , 1 ) : args . append ( \"--with-keygrip\" ) if keys : if isinstance ( keys , str ) : keys = [ keys ] args . extend ( keys ) p = self . _open_subprocess ( args ) return self . _get_list_output ( p , \"list\" ) def scan_keys ( self , filename : str ) -> ScanKeysHandler : \"\"\" List details of an ascii armored or binary key file without first importing it to the local keyring . Args : filename ( str ) : The path to the file containing the key ( s ). .. warning :: Warning : Care is needed . The function works on modern GnuPG by running : $ gpg -- dry - run -- import - options import - show -- import filename On older versions , it does the * much * riskier : $ gpg -- with - fingerprint -- with - colons filename \"\"\" if self . version >= ( 2 , 1 ) : args = [ \"--dry-run\" , \"--import-options\" , \"import-show\" , \"--import\" ] else : logger . warning ( \"Trying to list packets, but if the file is not a keyring, might accidentally decrypt\" ) args = [ \"--with-fingerprint\" , \"--with-colons\" , \"--fixed-list-mode\" ] args . append ( filename ) p = self . _open_subprocess ( args ) return self . _get_list_output ( p , \"scan\" ) def scan_keys_mem ( self , key_data : str ) -> ScanKeysHandler : \"\"\" List details of an ascii armored or binary key without first importing it to the local keyring . Args : key_data ( str | bytes ) : The key data to import . .. warning :: Warning : Care is needed . The function works on modern GnuPG by running : $ gpg -- dry - run -- import - options import - show -- import filename On older versions , it does the * much * riskier : $ gpg -- with - fingerprint -- with - colons filename \"\"\" result = self . result_map [ \"scan\" ]( self ) logger . debug ( \"scan_keys: %r\" , key_data [ : 256 ]) data = _make_binary_stream ( key_data , self . encoding ) if self . version >= ( 2 , 1 ) : args = [ \"--dry-run\" , \"--import-options\" , \"import-show\" , \"--import\" ] else : logger . warning ( \"Trying to list packets, but if the file is not a keyring, might accidentally decrypt\" ) args = [ \"--with-fingerprint\" , \"--with-colons\" , \"--fixed-list-mode\" ] self . _handle_io ( args , data , result , binary = True ) logger . debug ( \"scan_keys result: %r\" , result . __dict__ ) data . close () return self . _decode_result ( result ) def search_keys ( self , query : str , keyserver : str = \"pgp.mit.edu\" , extra_args : list [ str ] | None = None , ) -> StatusHandler : \"\"\" search a keyserver by query ( using the ` -- search - keys ` option ). Args : query ( str ) : The query to use . keyserver ( str ) : The key server hostname . extra_args ( list [ str ]) : Additional arguments to pass to ` gpg ` . \"\"\" query = query . strip () if HEX_DIGITS_RE . match ( query ) : query = \"0x\" + query args = [ \"--fingerprint\" , \"--keyserver\" , keyserver ] if extra_args : # pragma : no cover args . extend ( extra_args ) args . extend ([ \"--search-keys\" , query ]) p = self . _open_subprocess ( args ) # Get the response information result = self . result_map [ \"search\" ]( self ) self . _collect_output ( p , result , stdin = p . stdin ) lines = result . data . decode ( self . encoding , self . decode_errors ). splitlines () valid_keywords = [ \"pub\" , \"uid\" ] for line in lines : if self . verbose : # pragma : no cover pass logger . debug ( \"line: %r\" , line . rstrip ()) if not line : # sometimes get blank lines on Windows continue fields = line . strip (). split ( \":\" ) if not fields : # pragma : no cover continue keyword = fields [ 0 ] if keyword in valid_keywords : getattr ( result , keyword )( fields ) return result def auto_locate_key ( self , email : str , mechanisms : list [ str ] | None = None , ** kwargs : list [ str ]) -> StatusHandler : \"\"\" Auto locate a public key by ` email ` . Args : email ( str ) : The email address to search for . mechanisms ( list [ str ]) : A list of mechanisms to use . Valid mechanisms can be found here https : //www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration-Options.html under \"--auto-key-locate\" . Default : [ ' wkd ' , ' ntds ' , ' ldap ' , ' cert ' , ' dane ' , ' local ' ] \"\"\" mechanisms = mechanisms or [ \"wkd\" , \"ntds\" , \"ldap\" , \"cert\" , \"dane\" , \"local\" ] args = [ \"--auto-key-locate\" , \",\" . join ( mechanisms ), \"--locate-keys\" , email ] result = self . result_map [ \"auto-locate-key\" ]( self ) if \"extra_args\" in kwargs : args . extend ( kwargs [ \"extra_args\" ]) process = self . _open_subprocess ( args ) self . _collect_output ( process , result , stdin = process . stdin ) self . _decode_result ( result ) return result def gen_key ( self , key_input : str ) -> GenKeyHandler : \"\"\" Generate a key ; you might use ` gen_key_input () ` to create the input . Args : key_input ( str ) : The input to the key creation operation . \"\"\" args = [ \"--gen-key\" ] result = self . result_map [ \"generate\" ]( self ) f = _make_binary_stream ( key_input , self . encoding ) self . _handle_io ( args , f , result , binary = True ) f . close () return result def gen_key_input ( self , ** kwargs : bool | str | int ) -> str : \"\"\" Generate ` -- gen - key ` input ( see ` gpg ` documentation in DETAILS ). Args : kwargs ( dict ) : A list of keyword arguments . Returns : str : A string suitable for passing to the ` gen_key () ` method . \"\"\" parms = {} no_protection = kwargs . pop ( \"no_protection\" , False ) for key , val in [ item for item in kwargs . items () if str ( item [ 1 ]). strip ()] : parms [ key . replace ( \"_\" , \"-\" ). title ()] = val parms . setdefault ( \"Key-Type\" , \"RSA\" ) if \"key_curve\" not in kwargs : parms . setdefault ( \"Key-Length\" , 2048 ) parms . setdefault ( \"Name-Real\" , \"Autogenerated Key\" ) logname = os . environ . get ( \"LOGNAME\" ) or os . environ . get ( \"USERNAME\" ) or \"unspecified\" hostname = socket . gethostname () parms . setdefault ( \"Name-Email\" , \"{}@{}\" . format ( logname . replace ( \" \" , \"_\" ), hostname )) out = \"Key-Type: {} \\n \" . format ( parms . pop ( \"Key-Type\" )) for key , val in list ( parms . items ()) : out += f \"{key}: {val} \\n \" if no_protection : # pragma : no cover out += \"%no-protection \\n \" out += \"%commit \\n \" return out \"\"\" Key - Type : RSA Key - Length : 1024 Name - Real : ISdlink Server on %s Name - Comment : Created by %s Name - Email : isdlink @ %s Expire - Date : 0 %commit Key - Type : DSA Key - Length : 1024 Subkey - Type : ELG - E Subkey - Length : 1024 Name - Real : Joe Tester Name - Comment : with stupid passphrase Name - Email : joe @ foo . bar Expire - Date : 0 Passphrase : abc %pubring foo . pub %secring foo . sec %commit \"\"\" return None def add_subkey ( self , master_key : str , master_passphrase : str | None = None , algorithm : str = \"rsa\" , usage : str = \"encrypt\" , expire : int = \"-\" , ) -> AddSubkeyHandler : \"\"\" Add subkeys to a master key , Args : master_key ( str ) : The master key . master_passphrase ( str ) : The passphrase for the master key . algorithm ( str ) : The key algorithm to use . usage ( str ) : The desired uses for the subkey . expire ( str ) : The expiration date of the subkey . \"\"\" if self . version [ 0 ] < 2 : # noqa : PLR2004 msg = \"Not available in GnuPG 1.x\" raise NotImplementedError ( msg ) if not master_key : # pragma : no cover msg = \"No master key fingerprint specified\" raise ValueError ( msg ) if master_passphrase and not self . is_valid_passphrase ( master_passphrase ) : # pragma : no cover msg = \"Invalid passphrase\" raise ValueError ( msg ) args = [ \"--quick-add-key\" , master_key , algorithm , usage , str ( expire )] result = self . result_map [ \"addSubkey\" ]( self ) f = _make_binary_stream ( \"\" , self . encoding ) self . _handle_io ( args , f , result , passphrase = master_passphrase , binary = True ) return result # # ENCRYPTION # def encrypt_file ( # noqa : PLR0913 self , fileobj_or_path : BytesIO | str , recipients : str | list [ str ] | tuple [ str , str ] | None , * , sign : str | None = None , always_trust : bool = False , passphrase : str | None = None , armor : bool = True , output : str | None = None , symmetric : bool | str = False , extra_args : list [ str ] | None = None , ) -> CryptHandler : \"\"\" Encrypt data in a file or file - like object . Args : fileobj_or_path ( str | file ) : A path to a file or a file - like object containing the data to be encrypted . recipients ( str | list ) : A key id of a recipient of the encrypted data , or a list of such key ids . sign ( str ) : If specified , the key id of a signer to sign the encrypted data . always_trust ( bool ) : Whether to always trust keys . passphrase ( str ) : The passphrase to use for a signature . armor ( bool ) : Whether to ASCII - armor the output . output ( str ) : A path to write the encrypted output to . symmetric ( bool ) : Whether to use symmetric encryption , extra_args ( list [ str ]) : A list of additional arguments to pass to ` gpg ` . \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ) : msg = \"Invalid passphrase\" raise ValueError ( msg ) args = [ \"--encrypt\" ] if symmetric : # can't be False or None - could be True or a cipher algo value # such as AES256 args = [ \"--symmetric\" ] if symmetric is not True : args . extend ([ \"--cipher-algo\" , symmetric ]) # else use the default, currently CAST5 else : if not recipients : msg = \"No recipients specified with asymmetric encryption\" raise ValueError ( msg ) if not _is_sequence ( recipients ) : recipients = ( recipients ,) for recipient in recipients : args . extend ([ \"--recipient\" , recipient ]) if armor : # create ascii - armored output - False for binary output args . append ( \"--armor\" ) if output : # pragma : no cover # write the output to a file with the specified name self . set_output_without_confirmation ( args , output ) if sign is True : # pragma : no cover args . append ( \"--sign\" ) elif sign : # pragma : no cover args . extend ([ \"--sign\" , \"--default-key\" , sign ]) if always_trust : # pragma : no cover args . extend ([ \"--trust-model\" , \"always\" ]) if extra_args : # pragma : no cover args . extend ( extra_args ) result = self . result_map [ \"crypt\" ]( self ) self . _handle_io ( args , fileobj_or_path , result , passphrase = passphrase , binary = True ) logger . debug ( \"encrypt result[:100]: %r\" , result . data [ : 100 ]) return result def encrypt ( self , data : str | bytes , recipients : str | list [ str ] | tuple [ str , str ] | None , ** kwargs : str | bool | list [ str ], ) -> CryptHandler : \"\"\" Encrypt the message contained in the string * data * for * recipients * . This method delegates most of the work to ` encrypt_file () ` . Args : data ( str | bytes ) : The data to encrypt . recipients ( str | list [ str ]) : A key id of a recipient of the encrypted data , or a list of such key ids . kwargs ( dict ) : Keyword arguments , which are passed to ` encrypt_file () ` : * sign ( str ) : If specified , the key id of a signer to sign the encrypted data . * always_trust ( bool ) : Whether to always trust keys . * passphrase ( str ) : The passphrase to use for a signature . * armor ( bool ) : Whether to ASCII - armor the output . * output ( str ) : A path to write the encrypted output to . * symmetric ( bool ) : Whether to use symmetric encryption , * extra_args ( list [ str ]) : A list of additional arguments to pass to ` gpg ` . \"\"\" data = _make_binary_stream ( data , self . encoding ) result = self . encrypt_file ( data , recipients , ** kwargs ) data . close () return result def decrypt ( self , message : str , ** kwargs : str | list [ str ]) -> CryptHandler : \"\"\" Decrypt the data in * message * . This method delegates most of the work to ` decrypt_file () ` . Args : message ( str | bytes ) : The data to decrypt . A default key will be used for decryption . kwargs ( dict ) : Keyword arguments , which are passed to ` decrypt_file () ` : * always_trust : Whether to always trust keys . * passphrase ( str ) : The passphrase to use . * output ( str ) : If specified , the path to write the decrypted data to . * extra_args ( list [ str ]) : A list of extra arguments to pass to ` gpg ` . \"\"\" data = _make_binary_stream ( message , self . encoding ) result = self . decrypt_file ( data , ** kwargs ) data . close () return result def decrypt_file ( self , fileobj_or_path : str | bytes | BufferedReader | TextIOWrapper | BytesIO , * , always_trust : bool = False , passphrase : str | None = None , output : str | None = None , extra_args : None = None , ) -> CryptHandler : \"\"\" Decrypt data in a file or file - like object . Args : fileobj_or_path ( str | file ) : A path to a file or a file - like object containing the data to be decrypted . always_trust : Whether to always trust keys . passphrase ( str ) : The passphrase to use . output ( str ) : If specified , the path to write the decrypted data to . extra_args ( list [ str ]) : A list of extra arguments to pass to ` gpg ` . \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ) : msg = \"Invalid passphrase\" raise ValueError ( msg ) args = [ \"--decrypt\" ] if output : # pragma : no cover # write the output to a file with the specified name self . set_output_without_confirmation ( args , output ) if always_trust : # pragma : no cover args . extend ([ \"--trust-model\" , \"always\" ]) if extra_args : # pragma : no cover args . extend ( extra_args ) result = self . result_map [ \"crypt\" ]( self ) self . _handle_io ( args , fileobj_or_path , result , passphrase = passphrase , binary = True ) logger . debug ( \"decrypt result[:100]: %r\" , result . data [ : 100 ]) return result def get_recipients ( self , message : str , ** kwargs : list [ str ]) -> list [ str ] : \"\"\"Get the list of recipients for an encrypted message. This method delegates most of the work to ` get_recipients_file () ` . Args : message ( str | bytes ) : The encrypted message . kwargs ( dict ) : Keyword arguments , which are passed to ` get_recipients_file () ` : * extra_args ( list [ str ]) : A list of extra arguments to pass to ` gpg ` . \"\"\" data = _make_binary_stream ( message , self . encoding ) result = self . get_recipients_file ( data , ** kwargs ) data . close () return result def get_recipients_file ( self , fileobj_or_path : BytesIO | str , extra_args : list [ str ] | None = None ) -> list [ str ] : \"\"\" Get the list of recipients for an encrypted message in a file or file - like object . Args : fileobj_or_path ( str | file ) : A path to a file or file - like object containing the encrypted data . extra_args ( list [ str ]) : A list of extra arguments to pass to ` gpg ` . \"\"\" args = [ \"--decrypt\" , \"--list-only\" , \"-v\" ] if extra_args : # pragma : no cover args . extend ( extra_args ) result = self . result_map [ \"crypt\" ]( self ) self . _handle_io ( args , fileobj_or_path , result , binary = True ) return [ m . group ( 1 ) for m in PUBLIC_KEY_RE . finditer ( result . stderr )] def trust_keys ( self , fingerprints : str | list [ str ], trustlevel : str ) -> StatusHandler : \"\"\" Set the trust level for one or more keys . Args : fingerprints ( str | list [ str ]) : A key id for which to set the trust level , or a list of such key ids . trustlevel ( str ) : The trust level . This is one of the following . * ``' TRUST_EXPIRED '`` * ``' TRUST_UNDEFINED '`` * ``' TRUST_NEVER '`` * ``' TRUST_MARGINAL '`` * ``' TRUST_FULLY '`` * ``' TRUST_ULTIMATE '`` \"\"\" levels = VerifyHandler . TRUST_LEVELS if trustlevel not in levels : poss = \", \" . join ( sorted ( levels )) msg = f ' Invalid trust level : \"{trustlevel}\" ( must be one of { poss }) ' raise ValueError ( msg ) trustlevel = levels [ trustlevel ] + 1 import tempfile try : fd , fn = tempfile . mkstemp ( prefix = \"pygpg-\" ) if isinstance ( fingerprints , str ) : fingerprints = [ fingerprints ] lines = [ f \"{f}:{trustlevel}:\" for f in fingerprints ] # The trailing newline is required! s = os . linesep . join ( lines ) + os . linesep logger . debug ( \"writing ownertrust info: %s\" , s ) os . write ( fd , s . encode ( self . encoding )) os . close ( fd ) result = self . result_map [ \"trust\" ]( self ) p = self . _open_subprocess ([ \"--import-ownertrust\" , fn ]) self . _collect_output ( p , result , stdin = p . stdin ) if p . returncode != 0 : raise ValueError ( \"gpg returned an error - return code %d\" % p . returncode ) finally : Path ( fn ). unlink () return result Class variables buffer_size decode_errors error_map result_map A map of GPG operations to result object types. Methods add_subkey def add_subkey ( self , master_key : 'str' , master_passphrase : 'str | None' = None , algorithm : 'str' = 'rsa' , usage : 'str' = 'encrypt' , expire : 'int' = '-' ) -> 'AddSubkeyHandler' Add subkeys to a master key, Parameters: Name Type Description Default master_key str The master key. None master_passphrase str The passphrase for the master key. None algorithm str The key algorithm to use. None usage str The desired uses for the subkey. None expire str The expiration date of the subkey. None View Source def add_subkey ( self , master_key : str , master_passphrase : str | None = None , algorithm : str = \"rsa\" , usage : str = \"encrypt\" , expire : int = \"-\" , ) -> AddSubkeyHandler : \"\"\" Add subkeys to a master key, Args: master_key (str): The master key. master_passphrase (str): The passphrase for the master key. algorithm (str): The key algorithm to use. usage (str): The desired uses for the subkey. expire (str): The expiration date of the subkey. \"\"\" if self . version [ 0 ] < 2 : # noqa : PLR2004 msg = \"Not available in GnuPG 1.x\" raise NotImplementedError ( msg ) if not master_key : # pragma : no cover msg = \"No master key fingerprint specified\" raise ValueError ( msg ) if master_passphrase and not self . is_valid_passphrase ( master_passphrase ) : # pragma : no cover msg = \"Invalid passphrase\" raise ValueError ( msg ) args = [ \"--quick-add-key\" , master_key , algorithm , usage , str ( expire )] result = self . result_map [ \"addSubkey\" ]( self ) f = _make_binary_stream ( \"\" , self . encoding ) self . _handle_io ( args , f , result , passphrase = master_passphrase , binary = True ) return result auto_locate_key def auto_locate_key ( self , email : 'str' , mechanisms : 'list[str] | None' = None , ** kwargs : 'list[str]' ) -> 'StatusHandler' Auto locate a public key by email . Parameters: Name Type Description Default email str The email address to search for. None mechanisms list[str] A list of mechanisms to use. Valid mechanisms can be found None here https None //www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration-Options.html None under \"--auto-key-locate\". Default None ['wkd', 'ntds', 'ldap', 'cert', 'dane', 'local'] None View Source def auto_locate_key ( self , email : str , mechanisms : list [ str ] | None = None , ** kwargs : list [ str ] ) -> StatusHandler : \"\"\" Auto locate a public key by `email`. Args: email (str): The email address to search for. mechanisms (list[str]): A list of mechanisms to use. Valid mechanisms can be found here https://www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration-Options.html under \" -- auto - key - locate \". Default: ['wkd', 'ntds', 'ldap', 'cert', 'dane', 'local'] \"\"\" mechanisms = mechanisms or [ \"wkd\", \"ntds\", \"ldap\", \"cert\", \"dane\", \"local\" ] args = [ \"--auto-key-locate\", \",\".join(mechanisms), \"--locate-keys\", email ] result = self . result_map [ \"auto-locate-key\" ] ( self ) if \"extra_args\" in kwargs : args . extend ( kwargs [ \"extra_args\" ] ) process = self . _open_subprocess ( args ) self . _collect_output ( process , result , stdin = process . stdin ) self . _decode_result ( result ) return result decrypt def decrypt ( self , message : 'str' , ** kwargs : 'str | list[str]' ) -> 'CryptHandler' Decrypt the data in message . This method delegates most of the work to decrypt_file() . Parameters: Name Type Description Default message str bytes The data to decrypt. A default key will be used for decryption. kwargs dict Keyword arguments, which are passed to decrypt_file() : always_trust: Whether to always trust keys. passphrase (str): The passphrase to use. output (str): If specified, the path to write the decrypted data to. extra_args (list[str]): A list of extra arguments to pass to gpg . None View Source def decrypt ( self , message : str , ** kwargs : str | list [ str ] ) -> CryptHandler : \"\"\" Decrypt the data in *message*. This method delegates most of the work to `decrypt_file()`. Args: message (str|bytes): The data to decrypt. A default key will be used for decryption. kwargs (dict): Keyword arguments, which are passed to `decrypt_file()`: * always_trust: Whether to always trust keys. * passphrase (str): The passphrase to use. * output (str): If specified, the path to write the decrypted data to. * extra_args (list[str]): A list of extra arguments to pass to `gpg`. \"\"\" data = _make_binary_stream ( message , self . encoding ) result = self . decrypt_file ( data , ** kwargs ) data . close () return result decrypt_file def decrypt_file ( self , fileobj_or_path : 'str | bytes | BufferedReader | TextIOWrapper | BytesIO' , * , always_trust : 'bool' = False , passphrase : 'str | None' = None , output : 'str | None' = None , extra_args : 'None' = None ) -> 'CryptHandler' Decrypt data in a file or file-like object. Parameters: Name Type Description Default fileobj_or_path str file A path to a file or a file-like object containing the data to be decrypted. always_trust None Whether to always trust keys. None passphrase str The passphrase to use. None output str If specified, the path to write the decrypted data to. None extra_args list[str] A list of extra arguments to pass to gpg . None View Source def decrypt_file ( self , fileobj_or_path : str | bytes | BufferedReader | TextIOWrapper | BytesIO , * , always_trust : bool = False , passphrase : str | None = None , output : str | None = None , extra_args : None = None , ) -> CryptHandler : \" \"\" Decrypt data in a file or file-like object. Args: fileobj_or_path (str|file): A path to a file or a file-like object containing the data to be decrypted. always_trust: Whether to always trust keys. passphrase (str): The passphrase to use. output (str): If specified, the path to write the decrypted data to. extra_args (list[str]): A list of extra arguments to pass to `gpg`. \"\" \" if passphrase and not self . is_valid_passphrase ( passphrase ) : msg = \"Invalid passphrase\" raise ValueError ( msg ) args = [ \"--decrypt\" ] if output : # pragma: no cover # write the output to a file with the specified name self . set _output_without_confirmation ( args , output ) if always_trust : # pragma: no cover args . extend ( [ \"--trust-model\" , \"always\" ] ) if extra_args : # pragma: no cover args . extend ( extra_args ) result = self . result_map [ \"crypt\" ] ( self ) self . _handle_io ( args , fileobj_or_path , result , passphrase = passphrase , binary = True ) logger . debug ( \"decrypt result[:100]: %r\" , result . data [ : 100 ] ) return result delete_keys def delete_keys ( self , fingerprints : 'str' , * , secret : 'bool' = False , passphrase : 'str | None' = None , expect_passphrase : 'bool' = True , exclamation_mode : 'bool' = False ) -> 'DeleteResultHandler' Delete the indicated keys. Parameters: Name Type Description Default fingerprints str list[str] The keys to delete. secret bool Whether to delete secret keys. None passphrase str The passphrase to use. None expect_passphrase bool Whether a passphrase is expected. None exclamation_mode bool If specified, a '!' is appended to each fingerprint. This deletes only a subkey or an entire key, depending on what the fingerprint refers to. None View Source def delete_keys ( self , fingerprints : str , * , secret : bool = False , passphrase : str | None = None , expect_passphrase : bool = True , exclamation_mode : bool = False , ) -> DeleteResultHandler : \"\"\" Delete the indicated keys. Args: fingerprints (str|list[str]): The keys to delete. secret (bool): Whether to delete secret keys. passphrase (str): The passphrase to use. expect_passphrase (bool): Whether a passphrase is expected. exclamation_mode (bool): If specified, a `'!'` is appended to each fingerprint. This deletes only a subkey or an entire key, depending on what the fingerprint refers to. .. note:: Passphrases Since GnuPG 2.1, you can't delete secret keys without providing a passphrase. However, if you're expecting the passphrase to go to `gpg` via pinentry, you should specify expect_passphrase=False. (It's only checked for GnuPG >= 2.1). \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ) : # pragma : no cover msg = \"Invalid passphrase\" raise ValueError ( msg ) which = \"key\" if secret : # pragma : no cover if self . version >= ( 2 , 1 ) and passphrase is None and expect_passphrase : msg = \"For GnuPG >= 2.1, deleting secret keys needs a passphrase to be provided\" raise ValueError ( msg ) which = \"secret-key\" fingerprints = list ( fingerprints ) if _is_sequence ( fingerprints ) else [ fingerprints ] if exclamation_mode : fingerprints = [ f + \"!\" for f in fingerprints ] args = [ f\"--delete-{which}\" ] if secret and self . version >= ( 2 , 1 ) : args . insert ( 0 , \"--yes\" ) args . extend ( fingerprints ) result = self . result_map [ \"delete\" ] ( self ) if not secret or self . version < ( 2 , 1 ) : p = self . _open_subprocess ( args ) self . _collect_output ( p , result , stdin = p . stdin ) else : # Need to send in a passphrase . f = _make_binary_stream ( \"\" , self . encoding ) try : self . _handle_io ( args , f , result , passphrase = passphrase , binary = True ) finally : f . close () return result encrypt def encrypt ( self , data : 'str | bytes' , recipients : 'str | list[str] | tuple[str, str] | None' , ** kwargs : 'str | bool | list[str]' ) -> 'CryptHandler' Encrypt the message contained in the string data for recipients . This method delegates most of the work to encrypt_file() . Parameters: Name Type Description Default data str bytes The data to encrypt. recipients str list[str] A key id of a recipient of the encrypted data, or a list of such key ids. kwargs dict Keyword arguments, which are passed to encrypt_file() : sign (str): If specified, the key id of a signer to sign the encrypted data. always_trust (bool): Whether to always trust keys. passphrase (str): The passphrase to use for a signature. armor (bool): Whether to ASCII-armor the output. output (str): A path to write the encrypted output to. symmetric (bool): Whether to use symmetric encryption, * extra_args (list[str]): A list of additional arguments to pass to gpg . None View Source def encrypt ( self , data : str | bytes , recipients : str | list [ str ] | tuple [ str, str ] | None , ** kwargs : str | bool | list [ str ] , ) -> CryptHandler : \"\"\" Encrypt the message contained in the string *data* for *recipients*. This method delegates most of the work to `encrypt_file()`. Args: data (str|bytes): The data to encrypt. recipients (str|list[str]): A key id of a recipient of the encrypted data, or a list of such key ids. kwargs (dict): Keyword arguments, which are passed to `encrypt_file()`: * sign (str): If specified, the key id of a signer to sign the encrypted data. * always_trust (bool): Whether to always trust keys. * passphrase (str): The passphrase to use for a signature. * armor (bool): Whether to ASCII-armor the output. * output (str): A path to write the encrypted output to. * symmetric (bool): Whether to use symmetric encryption, * extra_args (list[str]): A list of additional arguments to pass to `gpg`. \"\"\" data = _make_binary_stream ( data , self . encoding ) result = self . encrypt_file ( data , recipients , ** kwargs ) data . close () return result encrypt_file def encrypt_file ( self , fileobj_or_path : 'BytesIO | str' , recipients : 'str | list[str] | tuple[str, str] | None' , * , sign : 'str | None' = None , always_trust : 'bool' = False , passphrase : 'str | None' = None , armor : 'bool' = True , output : 'str | None' = None , symmetric : 'bool | str' = False , extra_args : 'list[str] | None' = None ) -> 'CryptHandler' Encrypt data in a file or file-like object. Parameters: Name Type Description Default fileobj_or_path str file A path to a file or a file-like object containing the data to be encrypted. recipients str list A key id of a recipient of the encrypted data, or a list of such key ids. sign str If specified, the key id of a signer to sign the encrypted data. None always_trust bool Whether to always trust keys. None passphrase str The passphrase to use for a signature. None armor bool Whether to ASCII-armor the output. None output str A path to write the encrypted output to. None symmetric bool Whether to use symmetric encryption, None extra_args list[str] A list of additional arguments to pass to gpg . None View Source def encrypt_file ( # noqa : PLR0913 self , fileobj_or_path : BytesIO | str , recipients : str | list [ str ] | tuple [ str, str ] | None , * , sign : str | None = None , always_trust : bool = False , passphrase : str | None = None , armor : bool = True , output : str | None = None , symmetric : bool | str = False , extra_args : list [ str ] | None = None , ) -> CryptHandler : \"\"\" Encrypt data in a file or file-like object. Args: fileobj_or_path (str|file): A path to a file or a file-like object containing the data to be encrypted. recipients (str|list): A key id of a recipient of the encrypted data, or a list of such key ids. sign (str): If specified, the key id of a signer to sign the encrypted data. always_trust (bool): Whether to always trust keys. passphrase (str): The passphrase to use for a signature. armor (bool): Whether to ASCII-armor the output. output (str): A path to write the encrypted output to. symmetric (bool): Whether to use symmetric encryption, extra_args (list[str]): A list of additional arguments to pass to `gpg`. \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ) : msg = \"Invalid passphrase\" raise ValueError ( msg ) args = [ \"--encrypt\" ] if symmetric : # can ' t be False or None - could be True or a cipher algo value # such as AES256 args = [ \"--symmetric\" ] if symmetric is not True : args . extend ( [ \"--cipher-algo\", symmetric ] ) # else use the default , currently CAST5 else : if not recipients : msg = \"No recipients specified with asymmetric encryption\" raise ValueError ( msg ) if not _is_sequence ( recipients ) : recipients = ( recipients ,) for recipient in recipients : args . extend ( [ \"--recipient\", recipient ] ) if armor : # create ascii - armored output - False for binary output args . append ( \"--armor\" ) if output : # pragma : no cover # write the output to a file with the specified name self . set_output_without_confirmation ( args , output ) if sign is True : # pragma : no cover args . append ( \"--sign\" ) elif sign : # pragma : no cover args . extend ( [ \"--sign\", \"--default-key\", sign ] ) if always_trust : # pragma : no cover args . extend ( [ \"--trust-model\", \"always\" ] ) if extra_args : # pragma : no cover args . extend ( extra_args ) result = self . result_map [ \"crypt\" ] ( self ) self . _handle_io ( args , fileobj_or_path , result , passphrase = passphrase , binary = True ) logger . debug ( \"encrypt result[:100]: %r\" , result . data [ :100 ] ) return result export_keys def export_keys ( self , keyids : 'str | list[str]' , * , secret : 'bool' = False , armor : 'bool' = True , minimal : 'bool' = False , passphrase : 'str | None' = None , expect_passphrase : 'bool' = True , output : 'None' = None ) -> 'str | bytes' Export the indicated keys. A 'keyid' is anything gpg accepts. Parameters: Name Type Description Default keyids str list[str] A single keyid or a list of them. secret bool Whether to export secret keys. None armor bool Whether to ASCII-armor the output. None minimal bool Whether to pass --export-options export-minimal to gpg . None passphrase str The passphrase to use. None expect_passphrase bool Whether a passphrase is expected. None output str If specified, the path to write the exported key(s) to. None View Source def export_keys ( # noqa: PLR0913 self , keyids : str | list [ str ], * , secret : bool = False , armor : bool = True , minimal : bool = False , passphrase : str | None = None , expect_passphrase : bool = True , output : None = None , ) -> str | bytes : \"\"\" Export the indicated keys. A 'keyid' is anything `gpg` accepts. Args: keyids (str|list[str]): A single keyid or a list of them. secret (bool): Whether to export secret keys. armor (bool): Whether to ASCII-armor the output. minimal (bool): Whether to pass `--export-options export-minimal` to `gpg`. passphrase (str): The passphrase to use. expect_passphrase (bool): Whether a passphrase is expected. output (str): If specified, the path to write the exported key(s) to. .. note:: Passphrases Since GnuPG 2.1, you can't export secret keys without providing a passphrase. However, if you're expecting the passphrase to go to `gpg` via pinentry, you should specify expect_passphrase=False. (It's only checked for GnuPG >= 2.1). \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ): # pragma: no cover msg = \"Invalid passphrase\" raise ValueError ( msg ) which = \"\" if secret : which = \"-secret-key\" if self . version >= ( 2 , 1 ) and passphrase is None and expect_passphrase : # pragma: no cover msg = \"For GnuPG >= 2.1, exporting secret keys needs a passphrase to be provided\" raise ValueError ( msg ) keyids = list ( keyids ) if _is_sequence ( keyids ) else [ keyids ] args = [ f \"--export{which}\" ] if armor : args . append ( \"--armor\" ) if minimal : # pragma: no cover args . extend ([ \"--export-options\" , \"export-minimal\" ]) if output : # pragma: no cover # write the output to a file with the specified name self . set_output_without_confirmation ( args , output ) args . extend ( keyids ) # gpg --export produces no status-fd output; stdout will be # empty in case of failure result = self . result_map [ \"export\" ]( self ) if not secret or self . version < ( 2 , 1 ): p = self . _open_subprocess ( args ) self . _collect_output ( p , result , stdin = p . stdin ) else : # Need to send in a passphrase. f = _make_binary_stream ( \"\" , self . encoding ) try : self . _handle_io ( args , f , result , passphrase = passphrase , binary = True ) finally : f . close () logger . debug ( \"export_keys result[:100]: %r \" , result . data [: 100 ]) # Issue #49: Return bytes if armor not specified, else text result = result . data if armor : result = result . decode ( self . encoding , self . decode_errors ) return result gen_key def gen_key ( self , key_input : 'str' ) -> 'GenKeyHandler' Generate a key; you might use gen_key_input() to create the input. Parameters: Name Type Description Default key_input str The input to the key creation operation. None View Source def gen_key ( self , key_input : str ) - > GenKeyHandler : \"\"\" Generate a key; you might use `gen_key_input()` to create the input. Args: key_input (str): The input to the key creation operation. \"\"\" args = [ \"--gen-key\" ] result = self . result_map [ \"generate\" ] ( self ) f = _make_binary_stream ( key_input , self . encoding ) self . _handle_io ( args , f , result , binary = True ) f . close () return result gen_key_input def gen_key_input ( self , ** kwargs : 'bool | str | int' ) -> 'str' Generate --gen-key input (see gpg documentation in DETAILS). Parameters: Name Type Description Default kwargs dict A list of keyword arguments. None Returns: Type Description str A string suitable for passing to the gen_key() method. View Source def gen_key_input ( self , ** kwargs : bool | str | int ) -> str : \"\"\" Generate ` -- gen - key ` input ( see ` gpg ` documentation in DETAILS ). Args : kwargs ( dict ) : A list of keyword arguments . Returns : str : A string suitable for passing to the ` gen_key () ` method . \"\"\" parms = {} no_protection = kwargs . pop ( \"no_protection\" , False ) for key , val in [ item for item in kwargs . items () if str ( item [ 1 ]). strip ()] : parms [ key . replace ( \"_\" , \"-\" ). title ()] = val parms . setdefault ( \"Key-Type\" , \"RSA\" ) if \"key_curve\" not in kwargs : parms . setdefault ( \"Key-Length\" , 2048 ) parms . setdefault ( \"Name-Real\" , \"Autogenerated Key\" ) logname = os . environ . get ( \"LOGNAME\" ) or os . environ . get ( \"USERNAME\" ) or \"unspecified\" hostname = socket . gethostname () parms . setdefault ( \"Name-Email\" , \"{}@{}\" . format ( logname . replace ( \" \" , \"_\" ), hostname )) out = \"Key-Type: {} \\n \" . format ( parms . pop ( \"Key-Type\" )) for key , val in list ( parms . items ()) : out += f \"{key}: {val} \\n \" if no_protection : # pragma : no cover out += \"%no-protection \\n \" out += \"%commit \\n \" return out \"\"\" Key - Type : RSA Key - Length : 1024 Name - Real : ISdlink Server on %s Name - Comment : Created by %s Name - Email : isdlink @ %s Expire - Date : 0 %commit Key - Type : DSA Key - Length : 1024 Subkey - Type : ELG - E Subkey - Length : 1024 Name - Real : Joe Tester Name - Comment : with stupid passphrase Name - Email : joe @ foo . bar Expire - Date : 0 Passphrase : abc %pubring foo . pub %secring foo . sec %commit \"\"\" return None get_recipients def get_recipients ( self , message : 'str' , ** kwargs : 'list[str]' ) -> 'list[str]' Get the list of recipients for an encrypted message. This method delegates most of the work to get_recipients_file() . Parameters: Name Type Description Default message str bytes The encrypted message. kwargs dict Keyword arguments, which are passed to get_recipients_file() : * extra_args (list[str]): A list of extra arguments to pass to gpg . None View Source def get_recipients ( self , message : str , ** kwargs : list [ str ] ) -> list [ str ] : \"\"\"Get the list of recipients for an encrypted message. This method delegates most of the work to `get_recipients_file()`. Args: message (str|bytes): The encrypted message. kwargs (dict): Keyword arguments, which are passed to `get_recipients_file()`: * extra_args (list[str]): A list of extra arguments to pass to `gpg`. \"\"\" data = _make_binary_stream ( message , self . encoding ) result = self . get_recipients_file ( data , ** kwargs ) data . close () return result get_recipients_file def get_recipients_file ( self , fileobj_or_path : 'BytesIO | str' , extra_args : 'list[str] | None' = None ) -> 'list[str]' Get the list of recipients for an encrypted message in a file or file-like object. Parameters: Name Type Description Default fileobj_or_path str file A path to a file or file-like object containing the encrypted data. extra_args list[str] A list of extra arguments to pass to gpg . None View Source def get_recipients_file ( self , fileobj_or_path : BytesIO | str , extra_args : list [ str ] | None = None ) -> list [ str ] : \"\"\" Get the list of recipients for an encrypted message in a file or file-like object. Args: fileobj_or_path (str|file): A path to a file or file-like object containing the encrypted data. extra_args (list[str]): A list of extra arguments to pass to `gpg`. \"\"\" args = [ \"--decrypt\", \"--list-only\", \"-v\" ] if extra_args : # pragma : no cover args . extend ( extra_args ) result = self . result_map [ \"crypt\" ] ( self ) self . _handle_io ( args , fileobj_or_path , result , binary = True ) return [ m.group(1) for m in PUBLIC_KEY_RE.finditer(result.stderr) ] import_keys def import_keys ( self , key_data : 'str | bytes' , extra_args : 'None' = None , passphrase : 'None' = None ) -> 'ImportResultHandler' Import the key_data into our keyring. Parameters: Name Type Description Default key_data str bytes The key data to import. passphrase str The passphrase to use. None extra_args list[str] Additional arguments to pass to gpg . None View Source def import_keys ( self , key_data : str | bytes , extra_args : None = None , passphrase : None = None , ) -> ImportResultHandler : \" \"\" Import the key_data into our keyring. Args: key_data (str|bytes): The key data to import. passphrase (str): The passphrase to use. extra_args (list[str]): Additional arguments to pass to `gpg`. \"\" \" result = self . result_map [ \"import\" ] ( self ) logger . debug ( \"import_keys: %r\" , key_data [ : 256 ] ) data = _make_binary_stream ( key_data , self . encoding ) args = [ \"--import\" ] if extra_args : # pragma: no cover args . extend ( extra_args ) self . _handle_io ( args , data , result , passphrase = passphrase , binary = True ) logger . debug ( \"import_keys result: %r\" , result . __dict__ ) data . close () return result import_keys_file def import_keys_file ( self , key_path : 'str' , ** kwargs : 'str | list[str]' ) -> 'ImportResultHandler' Import the key data in key_path into our keyring. Parameters: Name Type Description Default key_path str A path to the key data to be imported. None View Source def import_keys_file ( self , key_path : str , ** kwargs : str | list [ str ] ) -> ImportResultHandler : \"\"\" Import the key data in key_path into our keyring. Args: key_path (str): A path to the key data to be imported. \"\"\" with Path ( key_path ). open ( \"rb\" ) as f : return self . import_keys ( f . read (), ** kwargs ) is_valid_file def is_valid_file ( self , fileobj : 'str | bytes | BufferedReader | TextIOWrapper | BytesIO' ) -> 'bool' A simplistic check for a file-like object. Parameters: Name Type Description Default fileobj object The object to test. None Returns: Type Description bool True if it's a file-like object, else False . View Source def is_valid_file ( self , fileobj : str | bytes | BufferedReader | TextIOWrapper | BytesIO ) -> bool : \" \"\" A simplistic check for a file-like object. Args: fileobj (object): The object to test. Returns: bool: ``True`` if it's a file-like object, else ``False``. \"\" \" return hasattr ( fileobj , \"read\" ) is_valid_passphrase def is_valid_passphrase ( self , passphrase : 'str' ) -> 'bool' Confirm that the passphrase doesn't contain newline-type characters - it is passed in a pipe to gpg , and so not checking could lead to spoofing attacks by passing arbitrary text after passphrase and newline. Parameters: Name Type Description Default passphrase str The passphrase to test. None Returns: Type Description bool True if it's a valid passphrase, else False . View Source def is_valid_passphrase ( self , passphrase : str ) -> bool : \" \"\" Confirm that the passphrase doesn't contain newline-type characters - it is passed in a pipe to `gpg`, and so not checking could lead to spoofing attacks by passing arbitrary text after passphrase and newline. Args: passphrase (str): The passphrase to test. Returns: bool: ``True`` if it's a valid passphrase, else ``False``. \"\" \" return \" \\n \" not in passphrase and \" \\r \" not in passphrase and \" \\ x00\" not in passphrase list_keys def list_keys ( self , * , secret : 'bool' = False , keys : 'str | list[str] | None' = None , sigs : 'bool' = False ) -> 'ListKeysHandler' List the keys currently in the keyring. Parameters: Name Type Description Default secret bool Whether to list secret keys. None keys str list[str] A list of key ids to match. sigs bool Whether to include signature information. None Returns: Type Description list[dict] A list of dictionaries with key information. View Source def list_keys ( self , * , secret : bool = False , keys : str | list [ str ] | None = None , sigs : bool = False , ) -> ListKeysHandler : \"\"\" List the keys currently in the keyring. Args: secret (bool): Whether to list secret keys. keys (str|list[str]): A list of key ids to match. sigs (bool): Whether to include signature information. Returns: list[dict]: A list of dictionaries with key information. \"\"\" which = \"secret-keys\" if secret else \"sigs\" if sigs else \"keys\" args = [ f\"--list-{which}\", \"--fingerprint\", \"--fingerprint\" ] # get subkey FPs , too if self . version >= ( 2 , 1 ) : args . append ( \"--with-keygrip\" ) if keys : if isinstance ( keys , str ) : keys = [ keys ] args . extend ( keys ) p = self . _open_subprocess ( args ) return self . _get_list_output ( p , \"list\" ) make_args def make_args ( self , args : 'list[str]' , * , passphrase : 'bool | None' = False ) -> 'list[str]' Make a list of command line elements for GPG. The value of args will be appended. The passphrase argument needs to be True if a passphrase will be sent to gpg , else False. Parameters: Name Type Description Default args list[str] A list of arguments. None passphrase str The passphrase to use. None View Source def make_args ( self , args : list [ str ] , * , passphrase : bool | None = False ) -> list [ str ] : \" \"\" Make a list of command line elements for GPG. The value of ``args`` will be appended. The ``passphrase`` argument needs to be True if a passphrase will be sent to `gpg`, else False. Args: args (list[str]): A list of arguments. passphrase (str): The passphrase to use. \"\" \" cmd = [ self . gpgbinary , \"--status-fd\" , \"2\" , \"--no-tty\" , \"--no-verbose\" ] if \"DEBUG_IPC\" in os . environ : # pragma: no cover cmd . extend ( [ \"--debug\" , \"ipc\" ] ) if passphrase and hasattr ( self , \"version\" ) and self . version >= ( 2 , 1 ) : cmd [ 1 : 1 ] = [ \"--pinentry-mode\" , \"loopback\" ] cmd . extend ( [ \"--fixed-list-mode\" , \"--batch\" , \"--with-colons\" ] ) if self . gnupghome : cmd . extend ( [ \"--homedir\" , str ( self . gnupghome ) ] ) if self . keyring : cmd . append ( \"--no-default-keyring\" ) for fn in self . keyring : cmd . extend ( [ \"--keyring\" , fn ] ) if self . secret_keyring : # pragma: no cover for fn in self . secret_keyring : cmd . extend ( [ \"--secret-keyring\" , fn ] ) if passphrase : cmd . extend ( [ \"--passphrase-fd\" , \"0\" ] ) if self . use_agent : # pragma: no cover cmd . append ( \"--use-agent\" ) if self . options : cmd . extend ( self . options ) cmd . extend ( args ) return cmd recv_keys def recv_keys ( self , keyserver : 'str' , * keyids : 'str' , ** kwargs : 'list[str]' ) -> 'ImportResultHandler' Import one or more keys from a keyserver. Parameters: Name Type Description Default keyserver str The key server hostname. None keyids str A list of key ids to receive. None View Source def recv_keys ( self , keyserver : str , * keyids : str , ** kwargs : list [ str ] ) -> ImportResultHandler : \"\"\" Import one or more keys from a keyserver. Args: keyserver (str): The key server hostname. keyids (str): A list of key ids to receive. \"\"\" result = self . result_map [ \"import\" ] ( self ) logger . debug ( \"recv_keys: %r\" , keyids ) data = _make_binary_stream ( \"\" , self . encoding ) args = [ \"--keyserver\", keyserver ] if \"extra_args\" in kwargs : # pragma : no cover args . extend ( kwargs [ \"extra_args\" ] ) args . append ( \"--recv-keys\" ) args . extend ( list ( keyids )) self . _handle_io ( args , data , result , binary = True ) logger . debug ( \"recv_keys result: %r\" , result . __dict__ ) data . close () return result scan_keys def scan_keys ( self , filename : 'str' ) -> 'ScanKeysHandler' List details of an ascii armored or binary key file without first importing it to the local keyring. Parameters: Name Type Description Default filename str The path to the file containing the key(s). None View Source def scan_keys ( self , filename : str ) -> ScanKeysHandler : \"\"\" List details of an ascii armored or binary key file without first importing it to the local keyring. Args: filename (str): The path to the file containing the key(s). .. warning:: Warning: Care is needed. The function works on modern GnuPG by running: $ gpg --dry-run --import-options import-show --import filename On older versions, it does the *much* riskier: $ gpg --with-fingerprint --with-colons filename \"\"\" if self . version >= ( 2 , 1 ): args = [ \"--dry-run\" , \"--import-options\" , \"import-show\" , \"--import\" ] else : logger . warning ( \"Trying to list packets, but if the file is not a keyring, might accidentally decrypt\" ) args = [ \"--with-fingerprint\" , \"--with-colons\" , \"--fixed-list-mode\" ] args . append ( filename ) p = self . _open_subprocess ( args ) return self . _get_list_output ( p , \"scan\" ) scan_keys_mem def scan_keys_mem ( self , key_data : 'str' ) -> 'ScanKeysHandler' List details of an ascii armored or binary key without first importing it to the local keyring. Parameters: Name Type Description Default key_data str bytes The key data to import. View Source def scan_keys_mem ( self , key_data : str ) -> ScanKeysHandler : \"\"\" List details of an ascii armored or binary key without first importing it to the local keyring. Args: key_data (str|bytes): The key data to import. .. warning:: Warning: Care is needed. The function works on modern GnuPG by running: $ gpg --dry-run --import-options import-show --import filename On older versions, it does the *much* riskier: $ gpg --with-fingerprint --with-colons filename \"\"\" result = self . result_map [ \"scan\" ]( self ) logger . debug ( \"scan_keys: %r \" , key_data [: 256 ]) data = _make_binary_stream ( key_data , self . encoding ) if self . version >= ( 2 , 1 ): args = [ \"--dry-run\" , \"--import-options\" , \"import-show\" , \"--import\" ] else : logger . warning ( \"Trying to list packets, but if the file is not a keyring, might accidentally decrypt\" ) args = [ \"--with-fingerprint\" , \"--with-colons\" , \"--fixed-list-mode\" ] self . _handle_io ( args , data , result , binary = True ) logger . debug ( \"scan_keys result: %r \" , result . __dict__ ) data . close () return self . _decode_result ( result ) search_keys def search_keys ( self , query : 'str' , keyserver : 'str' = 'pgp.mit.edu' , extra_args : 'list[str] | None' = None ) -> 'StatusHandler' search a keyserver by query (using the --search-keys option). Parameters: Name Type Description Default query str The query to use. None keyserver str The key server hostname. None extra_args list[str] Additional arguments to pass to gpg . None View Source def search_keys ( self , query : str , keyserver : str = \"pgp.mit.edu\" , extra_args : list [ str ] | None = None , ) -> StatusHandler : \"\"\" search a keyserver by query (using the `--search-keys` option). Args: query(str): The query to use. keyserver (str): The key server hostname. extra_args (list[str]): Additional arguments to pass to `gpg`. \"\"\" query = query . strip () if HEX_DIGITS_RE . match ( query ) : query = \"0x\" + query args = [ \"--fingerprint\", \"--keyserver\", keyserver ] if extra_args : # pragma : no cover args . extend ( extra_args ) args . extend ( [ \"--search-keys\", query ] ) p = self . _open_subprocess ( args ) # Get the response information result = self . result_map [ \"search\" ] ( self ) self . _collect_output ( p , result , stdin = p . stdin ) lines = result . data . decode ( self . encoding , self . decode_errors ). splitlines () valid_keywords = [ \"pub\", \"uid\" ] for line in lines : if self . verbose : # pragma : no cover pass logger . debug ( \"line: %r\" , line . rstrip ()) if not line : # sometimes get blank lines on Windows continue fields = line . strip (). split ( \":\" ) if not fields : # pragma : no cover continue keyword = fields [ 0 ] if keyword in valid_keywords : getattr ( result , keyword )( fields ) return result send_keys def send_keys ( self , keyserver : 'str' , * keyids : 'str' , ** kwargs : 'list[str]' ) -> 'StatusHandler' Send one or more keys to a keyserver. Parameters: Name Type Description Default keyserver str The key server hostname. None keyids list[str] A list of key ids to send. None View Source def send_keys ( self , keyserver : str , * keyids : str , ** kwargs : list [ str ] ) -> StatusHandler : # pragma : no cover \"\"\" Send one or more keys to a keyserver. Args: keyserver (str): The key server hostname. keyids (list[str]): A list of key ids to send. \"\"\" # Note : it ' s not practical to test this function without sending # arbitrary data to live keyservers . result = self . result_map [ \"send\" ] ( self ) logger . debug ( \"send_keys: %r\" , keyids ) data = _make_binary_stream ( \"\" , self . encoding ) args = [ \"--keyserver\", keyserver ] if \"extra_args\" in kwargs : args . extend ( kwargs [ \"extra_args\" ] ) args . append ( \"--send-keys\" ) args . extend ( list ( keyids )) self . _handle_io ( args , data , result , binary = True ) logger . debug ( \"send_keys result: %r\" , result . __dict__ ) data . close () return result set_output_without_confirmation def set_output_without_confirmation ( self , args : 'list[str]' , output : 'str' ) -> 'None' If writing to a file which exists, avoid a confirmation message by updating the args value in place to set the output path and avoid any cpmfirmation prompt. Parameters: Name Type Description Default args list[str] A list of arguments. None output str The path to the outpur file. None View Source def set_output_without_confirmation ( self , args : list [ str ] , output : str ) -> None : \"\"\" If writing to a file which exists, avoid a confirmation message by updating the *args* value in place to set the output path and avoid any cpmfirmation prompt. Args: args (list[str]): A list of arguments. output (str): The path to the outpur file. \"\"\" if Path ( output ). exists () : # We need to avoid an overwrite confirmation message args . extend ( [ \"--yes\" ] ) args . extend ( [ \"--output\", output ] ) sign def sign ( self , message : 'bytes' , ** kwargs : 'str | bool | list[str]' ) -> 'SignHandler' Sign a message. This method delegates most of the work to the sign_file() method. Parameters: Name Type Description Default message str bytes The data to sign. kwargs dict Keyword arguments, which are passed to sign_file() : keyid (str): The key id of the signer. passphrase (str): The passphrase for the key. clearsign (bool): Whether to use clear signing. detach (bool): Whether to produce a detached signature. binary (bool): Whether to produce a binary signature. output (str): The path to write a detached signature to. * extra_args (list[str]): Additional arguments to pass to gpg . None View Source def sign ( self , message : bytes , ** kwargs : str | bool | list [ str ] ) -> SignHandler : \"\"\" Sign a message. This method delegates most of the work to the `sign_file()` method. Args: message (str|bytes): The data to sign. kwargs (dict): Keyword arguments, which are passed to `sign_file()`: * keyid (str): The key id of the signer. * passphrase (str): The passphrase for the key. * clearsign (bool): Whether to use clear signing. * detach (bool): Whether to produce a detached signature. * binary (bool): Whether to produce a binary signature. * output (str): The path to write a detached signature to. * extra_args (list[str]): Additional arguments to pass to `gpg`. \"\"\" f = _make_binary_stream ( message , self . encoding ) result = self . sign_file ( f , ** kwargs ) f . close () return result sign_file def sign_file ( self , fileobj_or_path : 'BufferedReader | BytesIO | str' , * , keyid : 'str | None' = None , passphrase : 'str | None' = None , clearsign : 'bool' = True , detach : 'bool' = False , binary : 'bool' = False , output : 'str | None' = None , extra_args : 'None' = None ) -> 'SignHandler' Sign data in a file or file-like object. Parameters: Name Type Description Default fileobj_or_path str file The file or file-like object to sign. keyid str The key id of the signer. None passphrase str The passphrase for the key. None clearsign bool Whether to use clear signing. None detach bool Whether to produce a detached signature. None binary bool Whether to produce a binary signature. None output str The path to write a detached signature to. None extra_args list[str] Additional arguments to pass to gpg . None View Source def sign_file ( # noqa: PLR0913 self , fileobj_or_path : BufferedReader | BytesIO | str , * , keyid : str | None = None , passphrase : str | None = None , clearsign : bool = True , detach : bool = False , binary : bool = False , output : str | None = None , extra_args : None = None , ) -> SignHandler : \" \"\" Sign data in a file or file-like object. Args: fileobj_or_path (str|file): The file or file-like object to sign. keyid (str): The key id of the signer. passphrase (str): The passphrase for the key. clearsign (bool): Whether to use clear signing. detach (bool): Whether to produce a detached signature. binary (bool): Whether to produce a binary signature. output (str): The path to write a detached signature to. extra_args (list[str]): Additional arguments to pass to `gpg`. \"\" \" if passphrase and not self . is_valid_passphrase ( passphrase ) : msg = \"Invalid passphrase\" raise ValueError ( msg ) logger . debug ( \"sign_file: %s\" , fileobj_or_path ) args = [ \"-s\" ] if binary else [ \"-sa\" ] # You can't specify detach-sign and clearsign together: gpg ignores # the detach-sign in that case. if detach : args . append ( \"--detach-sign\" ) elif clearsign : args . append ( \"--clearsign\" ) if keyid : args . extend ( [ \"--default-key\" , keyid ] ) if output : # pragma: no cover # write the output to a file with the specified name self . set _output_without_confirmation ( args , output ) if extra_args : # pragma: no cover args . extend ( extra_args ) result = self . result_map [ \"sign\" ] ( self ) # We could use _handle_io here except for the fact that if the # passphrase is bad, gpg bails and you can't write the message. fileobj = self . _get_fileobj ( fileobj_or_path ) p = self . _open_subprocess ( args , passphrase = passphrase is not None ) try : stdin = p . stdin if passphrase : _write_passphrase ( stdin , passphrase , self . encoding ) writer = _threaded_copy_data ( fileobj , stdin , self . buffer_size ) except OSError : # pragma: no cover logging . exception ( \"error writing message\" ) writer = None finally : if writer : writer . join ( 0.01 ) if fileobj is not fileobj_or_path : fileobj . close () self . _collect_output ( p , result , writer , stdin ) return result trust_keys def trust_keys ( self , fingerprints : 'str | list[str]' , trustlevel : 'str' ) -> 'StatusHandler' Set the trust level for one or more keys. Parameters: Name Type Description Default fingerprints str list[str] A key id for which to set the trust level, or a list of such key ids. trustlevel str The trust level. This is one of the following. 'TRUST_EXPIRED' 'TRUST_UNDEFINED' 'TRUST_NEVER' 'TRUST_MARGINAL' 'TRUST_FULLY' 'TRUST_ULTIMATE' None View Source def trust_keys ( self , fingerprints : str | list [ str ] , trustlevel : str ) -> StatusHandler : \"\"\" Set the trust level for one or more keys. Args: fingerprints (str|list[str]): A key id for which to set the trust level, or a list of such key ids. trustlevel (str): The trust level. This is one of the following. * ``'TRUST_EXPIRED'`` * ``'TRUST_UNDEFINED'`` * ``'TRUST_NEVER'`` * ``'TRUST_MARGINAL'`` * ``'TRUST_FULLY'`` * ``'TRUST_ULTIMATE'`` \"\"\" levels = VerifyHandler . TRUST_LEVELS if trustlevel not in levels : poss = \", \" . join ( sorted ( levels )) msg = f 'Invalid trust level: \"{trustlevel}\" (must be one of {poss})' raise ValueError ( msg ) trustlevel = levels [ trustlevel ] + 1 import tempfile try : fd , fn = tempfile . mkstemp ( prefix = \"pygpg-\" ) if isinstance ( fingerprints , str ) : fingerprints = [ fingerprints ] lines = [ f\"{f}:{trustlevel}:\" for f in fingerprints ] # The trailing newline is required ! s = os . linesep . join ( lines ) + os . linesep logger . debug ( \"writing ownertrust info: %s\" , s ) os . write ( fd , s . encode ( self . encoding )) os . close ( fd ) result = self . result_map [ \"trust\" ] ( self ) p = self . _open_subprocess ( [ \"--import-ownertrust\", fn ] ) self . _collect_output ( p , result , stdin = p . stdin ) if p . returncode != 0 : raise ValueError ( \"gpg returned an error - return code %d\" % p . returncode ) finally : Path ( fn ). unlink () return result verify def verify ( self , data : 'bytes' , ** kwargs : 'str | bool | list[str] | IO' ) -> 'VerifyHandler' Verify the signature on the contents of the string data . This method delegates most of the work to verify_file() . Parameters: Name Type Description Default data str bytes The data to verify. kwargs dict Keyword arguments, which are passed to verify_file() : * fileobj_or_path (str file): A path to a signature, or a file-like object containing one. data_filename (str): If the signature is a detached one, the path to the data that was signed. close_file (bool): If a file-like object is passed in, whether to close it. * extra_args (list[str]): Additional arguments to pass to gpg . View Source def verify ( self , data : bytes , ** kwargs : str | bool | list [ str ] | IO ) -> VerifyHandler : \"\"\" Verify the signature on the contents of the string *data*. This method delegates most of the work to `verify_file()`. Args: data (str|bytes): The data to verify. kwargs (dict): Keyword arguments, which are passed to `verify_file()`: * fileobj_or_path (str|file): A path to a signature, or a file-like object containing one. * data_filename (str): If the signature is a detached one, the path to the data that was signed. * close_file (bool): If a file-like object is passed in, whether to close it. * extra_args (list[str]): Additional arguments to pass to `gpg`. \"\"\" f = _make_binary_stream ( data , self . encoding ) result = self . verify_file ( f , ** kwargs ) f . close () return result verify_data def verify_data ( self , sig_filename : 'str' , data : 'bytes' , extra_args : 'None' = None ) -> 'VerifyHandler' Verify the signature in sig_filename against data in memory Parameters: Name Type Description Default sig_filename str The path to a signature. None data str bytes The data to be verified. extra_args list[str] Additional arguments to pass to gpg . None View Source def verify_data ( self , sig_filename : str , data : bytes , extra_args : None = None ) -> VerifyHandler : \" \"\" Verify the signature in sig_filename against data in memory Args: sig_filename (str): The path to a signature. data (str|bytes): The data to be verified. extra_args (list[str]): Additional arguments to pass to `gpg`. \"\" \" logger . debug ( \"verify_data: %r, %r ...\" , sig_filename , data [ : 16 ] ) result = self . result_map [ \"verify\" ] ( self ) args = [ \"--verify\" ] if extra_args : # pragma: no cover args . extend ( extra_args ) args . extend ( [ sig_filename , \"-\" ] ) stream = BytesIO ( data ) self . _handle_io ( args , stream , result , binary = True ) return result verify_file def verify_file ( self , fileobj_or_path : 'BytesIO | str' , * , data_filename : 'str | None' = None , close_file : 'bool' = True , extra_args : 'None' = None ) -> 'VerifyHandler' Verify a signature. Parameters: Name Type Description Default fileobj_or_path str file A path to a signature, or a file-like object containing one. data_filename str If the signature is a detached one, the path to the data that was signed. None close_file bool If a file-like object is passed in, whether to close it. None extra_args list[str] Additional arguments to pass to gpg . None View Source def verify_file ( self , fileobj_or_path : BytesIO | str , * , data_filename : str | None = None , close_file : bool = True , extra_args : None = None , ) -> VerifyHandler : \" \"\" Verify a signature. Args: fileobj_or_path (str|file): A path to a signature, or a file-like object containing one. data_filename (str): If the signature is a detached one, the path to the data that was signed. close_file (bool): If a file-like object is passed in, whether to close it. extra_args (list[str]): Additional arguments to pass to `gpg`. \"\" \" logger . debug ( \"verify_file: %r, %r\" , fileobj_or_path , data_filename ) result = self . result_map [ \"verify\" ] ( self ) args = [ \"--verify\" ] if extra_args : # pragma: no cover args . extend ( extra_args ) if data_filename is None : self . _handle_io ( args , fileobj_or_path , result , binary = True ) else : logger . debug ( \"Handling detached verification\" ) import tempfile fd , fn = tempfile . mkstemp ( prefix = \"pygpg-\" ) s = fileobj_or_path . read () if close_file : fileobj_or_path . close () logger . debug ( \"Wrote to temp file: %r\" , s ) os . write ( fd , s ) os . close ( fd ) args . append ( fn ) args . append ( data_filename ) try : p = self . _open_subprocess ( args ) self . _collect_output ( p , result , stdin = p . stdin ) finally : Path ( fn ). unlink () return result","title":"Index"},{"location":"reference/gnupg/#module-gnupg","text":"A wrapper for the GnuPG gpg command. Portions of this module are derived from A.M. Kuchling's well-designed GPG.py, using Richard Jones' updated version 1.3, which can be found in the pycrypto CVS repository on Sourceforge: http://pycrypto.cvs.sourceforge.net/viewvc/pycrypto/gpg/GPG.py This module is not forward-compatible with amk's; some of the old interface has changed. For instance, since I've added decrypt functionality, I elected to initialize with a 'gnupghome' argument instead of 'keyring', so that gpg can find both the public and secret keyrings. I've also altered some of the returned objects in order for the caller to not have to know as much about the internals of the result classes. While the rest of ISconf is released under the GPL, I am releasing this single file under the same terms that A.M. Kuchling used for pycrypto. Steve Traugott, stevegt@terraluna.org Thu Jun 23 21:27:20 PDT 2005 This version of the module has been modified from Steve Traugott's version (see http://trac.t7a.org/isconf/browser/trunk/lib/python/isconf/GPG.py) by Vinay Sajip to make use of the subprocess module (Steve's version uses os.fork() and so does not work on Windows). Renamed to gnupg.py to avoid confusion with the previous versions. Modifications Copyright (C) 2008-2024 Vinay Sajip. All rights reserved. For the full documentation, see https://docs.red-dove.com/python-gnupg/ or https://gnupg.readthedocs.io/ View Source \" \"\" A wrapper for the GnuPG `gpg` command. Portions of this module are derived from A.M. Kuchling's well-designed GPG.py, using Richard Jones' updated version 1.3, which can be found in the pycrypto CVS repository on Sourceforge: http://pycrypto.cvs.sourceforge.net/viewvc/pycrypto/gpg/GPG.py This module is *not* forward-compatible with amk's; some of the old interface has changed. For instance, since I've added decrypt functionality, I elected to initialize with a 'gnupghome' argument instead of 'keyring', so that gpg can find both the public and secret keyrings. I've also altered some of the returned objects in order for the caller to not have to know as much about the internals of the result classes. While the rest of ISconf is released under the GPL, I am releasing this single file under the same terms that A.M. Kuchling used for pycrypto. Steve Traugott, stevegt@terraluna.org Thu Jun 23 21:27:20 PDT 2005 This version of the module has been modified from Steve Traugott's version (see http://trac.t7a.org/isconf/browser/trunk/lib/python/isconf/GPG.py) by Vinay Sajip to make use of the subprocess module (Steve's version uses os.fork() and so does not work on Windows). Renamed to gnupg.py to avoid confusion with the previous versions. Modifications Copyright (C) 2008-2024 Vinay Sajip. All rights reserved. For the full documentation, see https://docs.red-dove.com/python-gnupg/ or https://gnupg.readthedocs.io/ \"\" \" from __future__ import annotations from . gnupg import GPG __version__ = \"YANKED\" __author__ = \"Vinay Sajip\" __date__ = \"YANKED\" __all__ = ( \"GPG\" ,)","title":"Module gnupg"},{"location":"reference/gnupg/#sub-modules","text":"gnupg.gnupg gnupg.handlers gnupg.helper","title":"Sub-modules"},{"location":"reference/gnupg/#classes","text":"","title":"Classes"},{"location":"reference/gnupg/#gpg","text":"class GPG ( * , gpgbinary : 'str' = 'gpg' , gnupghome : 'str | None' = None , verbose : 'bool' = False , use_agent : 'bool' = False , keyring : 'str | None' = None , options : 'None' = None , secret_keyring : 'None' = None , env : 'None' = None ) This class provides a high-level programmatic interface for gpg . View Source class GPG : \"\"\" This class provides a high - level programmatic interface for ` gpg ` . \"\"\" error_map = None decode_errors = \"strict\" buffer_size = 16384 # override in instance if needed result_map = MappingProxyType ( { \"crypt\" : CryptHandler , \"delete\" : DeleteResultHandler , \"generate\" : GenKeyHandler , \"addSubkey\" : AddSubkeyHandler , \"import\" : ImportResultHandler , \"send\" : SendResultHandler , \"list\" : ListKeysHandler , \"scan\" : ScanKeysHandler , \"search\" : SearchKeysHandler , \"sign\" : SignHandler , \"trust\" : TrustResultHandler , \"verify\" : VerifyHandler , \"export\" : ExportResultHandler , \"auto-locate-key\" : AutoLocateKeyHandler , }, ) \"A map of GPG operations to result object types.\" def __init__ ( # noqa : PLR0913 self , * , gpgbinary : str = \"gpg\" , gnupghome : str | None = None , verbose : bool = False , use_agent : bool = False , keyring : str | None = None , options : None = None , secret_keyring : None = None , env : None = None , ) -> None : \"\"\"Initialize a GPG process wrapper. Args : gpgbinary ( str ) : A pathname for the GPG binary to use . gnupghome ( str ) : A pathname to where we can find the public and private keyrings . The default is whatever ` gpg ` defaults to . keyring ( str | list ) : The name of alternative keyring file to use , or a list of such keyring files . If specified , the default keyring is not used . options ( list ) : A list of additional options to pass to the GPG binary . secret_keyring ( str | list ) : The name of an alternative secret keyring file to use , or a list of such keyring files . env ( dict ) : A dict of environment variables to be used for the GPG subprocess . \"\"\" self . gpgbinary = gpgbinary self . gnupghome = None if not gnupghome else Path ( gnupghome ) self . env = env # issue 112: fail if the specified value isn't a directory if self . gnupghome and not self . gnupghome . is_dir () : msg = f \"gnupghome should be a directory (it isn't): {self.gnupghome}\" raise ValueError ( msg ) # Allow passing a string or another iterable. Make it uniformly # a list of keyring filenames if keyring and isinstance ( keyring , str ) : keyring = [ keyring ] self . keyring = keyring # Allow passing a string or another iterable. Make it uniformly # a list of keyring filenames if secret_keyring and isinstance ( secret_keyring , str ) : # pragma : no cover secret_keyring = [ secret_keyring ] self . secret_keyring = secret_keyring self . verbose = verbose self . use_agent = use_agent if isinstance ( options , str ) : # pragma : no cover options = [ options ] self . options = options self . on_data = None # or a callable - will be called with data chunks # Changed in 0.3.7 to use Latin-1 encoding rather than # locale.getpreferredencoding falling back to sys.stdin.encoding # falling back to utf-8, because gpg itself uses latin-1 as the default # encoding. self . encoding = \"latin-1\" if self . gnupghome and not self . gnupghome . is_dir () : # pragma : no cover self . gnupghome . mkdir ( mode = 0 o700 , parents = True ) try : p = self . _open_subprocess ([ \"--list-config\" , \"--with-colons\" ]) except OSError : msg = f \"Unable to run gpg ({self.gpgbinary}) - it may not be available.\" logger . exception ( msg ) raise OSError ( msg ) from None result = self . result_map [ \"verify\" ]( self ) # any result will do for this self . _collect_output ( p , result , stdin = p . stdin ) if p . returncode != 0 : # pragma : no cover msg = f \"Error invoking gpg: {p.returncode}: {result.stderr}\" raise ValueError ( msg ) m = VERSION_RE . match ( result . data ) if not m : # pragma : no cover self . version = None else : dot = \".\" . encode ( \"ascii\" ) self . version = tuple ([ int ( s ) for s in m . groups ()[ 0 ]. split ( dot )]) # See issue #97. It seems gpg allow duplicate keys in keyrings, so we # can't be too strict. self . check_fingerprint_collisions = False def make_args ( self , args : list [ str ], * , passphrase : bool | None = False ) -> list [ str ] : \"\"\" Make a list of command line elements for GPG . The value of `` args `` will be appended . The `` passphrase `` argument needs to be True if a passphrase will be sent to ` gpg ` , else False . Args : args ( list [ str ]) : A list of arguments . passphrase ( str ) : The passphrase to use . \"\"\" cmd = [ self . gpgbinary , \"--status-fd\" , \"2\" , \"--no-tty\" , \"--no-verbose\" ] if \"DEBUG_IPC\" in os . environ : # pragma : no cover cmd . extend ([ \"--debug\" , \"ipc\" ]) if passphrase and hasattr ( self , \"version\" ) and self . version >= ( 2 , 1 ) : cmd [ 1 : 1 ] = [ \"--pinentry-mode\" , \"loopback\" ] cmd . extend ([ \"--fixed-list-mode\" , \"--batch\" , \"--with-colons\" ]) if self . gnupghome : cmd . extend ([ \"--homedir\" , str ( self . gnupghome )]) if self . keyring : cmd . append ( \"--no-default-keyring\" ) for fn in self . keyring : cmd . extend ([ \"--keyring\" , fn ]) if self . secret_keyring : # pragma : no cover for fn in self . secret_keyring : cmd . extend ([ \"--secret-keyring\" , fn ]) if passphrase : cmd . extend ([ \"--passphrase-fd\" , \"0\" ]) if self . use_agent : # pragma : no cover cmd . append ( \"--use-agent\" ) if self . options : cmd . extend ( self . options ) cmd . extend ( args ) return cmd def _open_subprocess ( self , args : list [ str ], * , passphrase : bool | None = False ) -> Popen : # Internal method: open a pipe to a GPG subprocess and return # the file objects for communicating with it. from subprocess import list2cmdline as debug_print cmd = self . make_args ( args , passphrase = passphrase ) if self . verbose : # pragma : no cover pass if not STARTUPINFO : si = None else : # pragma : no cover si = STARTUPINFO () si . dwFlags = STARTF_USESHOWWINDOW si . wShowWindow = SW_HIDE result = Popen ( # noqa : S603 cmd , shell = False , stdin = PIPE , stdout = PIPE , stderr = PIPE , startupinfo = si , env = self . env , ) logger . debug ( \"%s: %s\" , result . pid , debug_print ( cmd )) return result def _read_response ( self , stream : IO , result : StatusHandler ) -> None : # Internal method: reads all the stderr output from GPG, taking notice # only of lines that begin with the magic [GNUPG:] prefix. # # Calls methods on the response object for each valid token found, # with the arg being the remainder of the status line. lines = [] while True : line = stream . readline () if len ( line ) == 0 : break lines . append ( line ) line = line . rstrip () if self . verbose : # pragma : no cover pass logger . debug ( \"%s\" , line ) if line [ 0 : 9 ] == \"[GNUPG:] \" : # Chop off the prefix line = line [ 9 : ]. split ( None , 1 ) keyword = line [ 0 ] value = line [ 1 ] if len ( line ) > 1 else \"\" result . handle_status ( keyword , value ) result . stderr = \"\" . join ( lines ) def _read_data ( self , stream : IO , result : StatusHandler , * , on_data : Callable [[ str | bytes ], Any ] | None = None , buffer_size : int = 1024 , ) -> None : # Read the contents of the file from GPG's stdout assert buffer_size > 0 # noqa : S101 chunks = [] while True : data = stream . read ( buffer_size ) if len ( data ) == 0 : if on_data : on_data ( data ) break if log_everything : msg = f \"chunk: {data[:256]!r}\" logger . debug ( msg ) append = True if on_data : append = on_data ( data ) is not False if append : chunks . append ( data ) # Join using b'' or '', as appropriate result . data = type ( data )(). join ( chunks ) def _collect_output ( self , process : Popen , result : StatusHandler , writer : threading . Thread | None = None , stdin : BufferedWriter | None = None , ) -> int : \"\"\" Drain the subprocesses output streams , writing the collected output to the result . If a writer thread ( writing to the subprocess ) is given , make sure it ' s joined before returning . If a stdin stream is given , close it before returning . \"\"\" stderr = codecs . getreader ( self . encoding )( process . stderr ) rr = threading . Thread ( target = self . _read_response , args = ( stderr , result )) rr . daemon = True logger . debug ( \"stderr reader: %r\" , rr ) rr . start () stdout = process . stdout dr = threading . Thread ( target = self . _read_data , args = ( stdout , result ), kwargs = { \"on_data\" : self . on_data , \"buffer_size\" : self . buffer_size }, ) dr . daemon = True logger . debug ( \"stdout reader: %r\" , dr ) dr . start () dr . join () rr . join () if writer is not None : writer . join ( 0.01 ) process . wait () result . returncode = rc = process . returncode if rc != 0 : logger . warning ( \"gpg returned a non-zero error code: %d\" , rc ) if stdin is not None : with contextlib . suppress ( OSError ) : stdin . close () stderr . close () stdout . close () return rc def is_valid_file ( self , fileobj : str | bytes | BufferedReader | TextIOWrapper | BytesIO ) -> bool : \"\"\" A simplistic check for a file - like object . Args : fileobj ( object ) : The object to test . Returns : bool : `` True `` if it ' s a file - like object , else `` False `` . \"\"\" return hasattr ( fileobj , \"read\" ) def _get_fileobj ( self , fileobj_or_path : str | bytes | BufferedReader | TextIOWrapper | BytesIO , ) -> BufferedReader | BytesIO | TextIOWrapper : if self . is_valid_file ( fileobj_or_path ) : result = fileobj_or_path elif not isinstance ( fileobj_or_path , str ) : msg = f \"Not a valid file or path: {fileobj_or_path}\" raise TypeError ( msg ) elif not Path ( fileobj_or_path ). exists () : msg = f \"No such file: {fileobj_or_path}\" raise ValueError ( msg ) else : result = Path ( fileobj_or_path ). open ( \"rb\" ) # noqa : SIM115 return result def _handle_io ( self , args : list [ str ], fileobj_or_path : str | bytes | BufferedReader | TextIOWrapper | BytesIO , result : StatusHandler , * , passphrase : str | None = None , binary : bool = False , ) -> StatusHandler : \"Handle a call to GPG - pass input data, collect output data\" # Handle a basic data call - pass data to GPG, handle the output # including status information. Garbage In, Garbage Out :) fileobj = self . _get_fileobj ( fileobj_or_path ) try : p = self . _open_subprocess ( args , passphrase = passphrase is not None ) stdin = p . stdin if binary else codecs . getwriter ( self . encoding )( p . stdin ) writer = None # See issue # 237 if passphrase : _write_passphrase ( stdin , passphrase , self . encoding ) writer = _threaded_copy_data ( fileobj , stdin , self . buffer_size ) self . _collect_output ( p , result , writer , stdin ) return result finally : if writer : writer . join ( 0.01 ) if fileobj is not fileobj_or_path : fileobj . close () # # SIGNATURE METHODS # def sign ( self , message : bytes , ** kwargs : str | bool | list [ str ]) -> SignHandler : \"\"\" Sign a message . This method delegates most of the work to the ` sign_file () ` method . Args : message ( str | bytes ) : The data to sign . kwargs ( dict ) : Keyword arguments , which are passed to ` sign_file () ` : * keyid ( str ) : The key id of the signer . * passphrase ( str ) : The passphrase for the key . * clearsign ( bool ) : Whether to use clear signing . * detach ( bool ) : Whether to produce a detached signature . * binary ( bool ) : Whether to produce a binary signature . * output ( str ) : The path to write a detached signature to . * extra_args ( list [ str ]) : Additional arguments to pass to ` gpg ` . \"\"\" f = _make_binary_stream ( message , self . encoding ) result = self . sign_file ( f , ** kwargs ) f . close () return result def set_output_without_confirmation ( self , args : list [ str ], output : str ) -> None : \"\"\" If writing to a file which exists , avoid a confirmation message by updating the * args * value in place to set the output path and avoid any cpmfirmation prompt . Args : args ( list [ str ]) : A list of arguments . output ( str ) : The path to the outpur file . \"\"\" if Path ( output ). exists () : # We need to avoid an overwrite confirmation message args . extend ([ \"--yes\" ]) args . extend ([ \"--output\" , output ]) def is_valid_passphrase ( self , passphrase : str ) -> bool : \"\"\" Confirm that the passphrase doesn ' t contain newline - type characters - it is passed in a pipe to ` gpg ` , and so not checking could lead to spoofing attacks by passing arbitrary text after passphrase and newline . Args : passphrase ( str ) : The passphrase to test . Returns : bool : `` True `` if it ' s a valid passphrase , else `` False `` . \"\"\" return \" \\n \" not in passphrase and \" \\r \" not in passphrase and \" \\x00 \" not in passphrase def sign_file ( # noqa : PLR0913 self , fileobj_or_path : BufferedReader | BytesIO | str , * , keyid : str | None = None , passphrase : str | None = None , clearsign : bool = True , detach : bool = False , binary : bool = False , output : str | None = None , extra_args : None = None , ) -> SignHandler : \"\"\" Sign data in a file or file - like object . Args : fileobj_or_path ( str | file ) : The file or file - like object to sign . keyid ( str ) : The key id of the signer . passphrase ( str ) : The passphrase for the key . clearsign ( bool ) : Whether to use clear signing . detach ( bool ) : Whether to produce a detached signature . binary ( bool ) : Whether to produce a binary signature . output ( str ) : The path to write a detached signature to . extra_args ( list [ str ]) : Additional arguments to pass to ` gpg ` . \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ) : msg = \"Invalid passphrase\" raise ValueError ( msg ) logger . debug ( \"sign_file: %s\" , fileobj_or_path ) args = [ \"-s\" ] if binary else [ \"-sa\" ] # You can't specify detach-sign and clearsign together: gpg ignores # the detach-sign in that case. if detach : args . append ( \"--detach-sign\" ) elif clearsign : args . append ( \"--clearsign\" ) if keyid : args . extend ([ \"--default-key\" , keyid ]) if output : # pragma : no cover # write the output to a file with the specified name self . set_output_without_confirmation ( args , output ) if extra_args : # pragma : no cover args . extend ( extra_args ) result = self . result_map [ \"sign\" ]( self ) # We could use _handle_io here except for the fact that if the # passphrase is bad, gpg bails and you can't write the message. fileobj = self . _get_fileobj ( fileobj_or_path ) p = self . _open_subprocess ( args , passphrase = passphrase is not None ) try : stdin = p . stdin if passphrase : _write_passphrase ( stdin , passphrase , self . encoding ) writer = _threaded_copy_data ( fileobj , stdin , self . buffer_size ) except OSError : # pragma : no cover logging . exception ( \"error writing message\" ) writer = None finally : if writer : writer . join ( 0.01 ) if fileobj is not fileobj_or_path : fileobj . close () self . _collect_output ( p , result , writer , stdin ) return result def verify ( self , data : bytes , ** kwargs : str | bool | list [ str ] | IO ) -> VerifyHandler : \"\"\" Verify the signature on the contents of the string * data * . This method delegates most of the work to ` verify_file () ` . Args : data ( str | bytes ) : The data to verify . kwargs ( dict ) : Keyword arguments , which are passed to ` verify_file () ` : * fileobj_or_path ( str | file ) : A path to a signature , or a file - like object containing one . * data_filename ( str ) : If the signature is a detached one , the path to the data that was signed . * close_file ( bool ) : If a file - like object is passed in , whether to close it . * extra_args ( list [ str ]) : Additional arguments to pass to ` gpg ` . \"\"\" f = _make_binary_stream ( data , self . encoding ) result = self . verify_file ( f , ** kwargs ) f . close () return result def verify_file ( self , fileobj_or_path : BytesIO | str , * , data_filename : str | None = None , close_file : bool = True , extra_args : None = None , ) -> VerifyHandler : \"\"\" Verify a signature . Args : fileobj_or_path ( str | file ) : A path to a signature , or a file - like object containing one . data_filename ( str ) : If the signature is a detached one , the path to the data that was signed . close_file ( bool ) : If a file - like object is passed in , whether to close it . extra_args ( list [ str ]) : Additional arguments to pass to ` gpg ` . \"\"\" logger . debug ( \"verify_file: %r, %r\" , fileobj_or_path , data_filename ) result = self . result_map [ \"verify\" ]( self ) args = [ \"--verify\" ] if extra_args : # pragma : no cover args . extend ( extra_args ) if data_filename is None : self . _handle_io ( args , fileobj_or_path , result , binary = True ) else : logger . debug ( \"Handling detached verification\" ) import tempfile fd , fn = tempfile . mkstemp ( prefix = \"pygpg-\" ) s = fileobj_or_path . read () if close_file : fileobj_or_path . close () logger . debug ( \"Wrote to temp file: %r\" , s ) os . write ( fd , s ) os . close ( fd ) args . append ( fn ) args . append ( data_filename ) try : p = self . _open_subprocess ( args ) self . _collect_output ( p , result , stdin = p . stdin ) finally : Path ( fn ). unlink () return result def verify_data ( self , sig_filename : str , data : bytes , extra_args : None = None ) -> VerifyHandler : \"\"\" Verify the signature in sig_filename against data in memory Args : sig_filename ( str ) : The path to a signature . data ( str | bytes ) : The data to be verified . extra_args ( list [ str ]) : Additional arguments to pass to ` gpg ` . \"\"\" logger . debug ( \"verify_data: %r, %r ...\" , sig_filename , data [ : 16 ]) result = self . result_map [ \"verify\" ]( self ) args = [ \"--verify\" ] if extra_args : # pragma : no cover args . extend ( extra_args ) args . extend ([ sig_filename , \"-\" ]) stream = BytesIO ( data ) self . _handle_io ( args , stream , result , binary = True ) return result # # KEY MANAGEMENT # def import_keys ( self , key_data : str | bytes , extra_args : None = None , passphrase : None = None , ) -> ImportResultHandler : \"\"\" Import the key_data into our keyring . Args : key_data ( str | bytes ) : The key data to import . passphrase ( str ) : The passphrase to use . extra_args ( list [ str ]) : Additional arguments to pass to ` gpg ` . \"\"\" result = self . result_map [ \"import\" ]( self ) logger . debug ( \"import_keys: %r\" , key_data [ : 256 ]) data = _make_binary_stream ( key_data , self . encoding ) args = [ \"--import\" ] if extra_args : # pragma : no cover args . extend ( extra_args ) self . _handle_io ( args , data , result , passphrase = passphrase , binary = True ) logger . debug ( \"import_keys result: %r\" , result . __dict__ ) data . close () return result def import_keys_file ( self , key_path : str , ** kwargs : str | list [ str ]) -> ImportResultHandler : \"\"\" Import the key data in key_path into our keyring . Args : key_path ( str ) : A path to the key data to be imported . \"\"\" with Path ( key_path ). open ( \"rb\" ) as f : return self . import_keys ( f . read (), ** kwargs ) def recv_keys ( self , keyserver : str , * keyids : str , ** kwargs : list [ str ]) -> ImportResultHandler : \"\"\" Import one or more keys from a keyserver . Args : keyserver ( str ) : The key server hostname . keyids ( str ) : A list of key ids to receive . \"\"\" result = self . result_map [ \"import\" ]( self ) logger . debug ( \"recv_keys: %r\" , keyids ) data = _make_binary_stream ( \"\" , self . encoding ) args = [ \"--keyserver\" , keyserver ] if \"extra_args\" in kwargs : # pragma : no cover args . extend ( kwargs [ \"extra_args\" ]) args . append ( \"--recv-keys\" ) args . extend ( list ( keyids )) self . _handle_io ( args , data , result , binary = True ) logger . debug ( \"recv_keys result: %r\" , result . __dict__ ) data . close () return result # This function isn't exercised by tests, to avoid polluting external # key servers with test keys def send_keys ( self , keyserver : str , * keyids : str , ** kwargs : list [ str ]) -> StatusHandler : # pragma : no cover \"\"\" Send one or more keys to a keyserver . Args : keyserver ( str ) : The key server hostname . keyids ( list [ str ]) : A list of key ids to send . \"\"\" # Note: it's not practical to test this function without sending # arbitrary data to live keyservers. result = self . result_map [ \"send\" ]( self ) logger . debug ( \"send_keys: %r\" , keyids ) data = _make_binary_stream ( \"\" , self . encoding ) args = [ \"--keyserver\" , keyserver ] if \"extra_args\" in kwargs : args . extend ( kwargs [ \"extra_args\" ]) args . append ( \"--send-keys\" ) args . extend ( list ( keyids )) self . _handle_io ( args , data , result , binary = True ) logger . debug ( \"send_keys result: %r\" , result . __dict__ ) data . close () return result def delete_keys ( self , fingerprints : str , * , secret : bool = False , passphrase : str | None = None , expect_passphrase : bool = True , exclamation_mode : bool = False , ) -> DeleteResultHandler : \"\"\" Delete the indicated keys . Args : fingerprints ( str | list [ str ]) : The keys to delete . secret ( bool ) : Whether to delete secret keys . passphrase ( str ) : The passphrase to use . expect_passphrase ( bool ) : Whether a passphrase is expected . exclamation_mode ( bool ) : If specified , a ` '!' ` is appended to each fingerprint . This deletes only a subkey or an entire key , depending on what the fingerprint refers to . .. note :: Passphrases Since GnuPG 2.1 , you can ' t delete secret keys without providing a passphrase . However , if you ' re expecting the passphrase to go to ` gpg ` via pinentry , you should specify expect_passphrase = False . ( It ' s only checked for GnuPG >= 2.1 ). \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ) : # pragma : no cover msg = \"Invalid passphrase\" raise ValueError ( msg ) which = \"key\" if secret : # pragma : no cover if self . version >= ( 2 , 1 ) and passphrase is None and expect_passphrase : msg = \"For GnuPG >= 2.1, deleting secret keys needs a passphrase to be provided\" raise ValueError ( msg ) which = \"secret-key\" fingerprints = list ( fingerprints ) if _is_sequence ( fingerprints ) else [ fingerprints ] if exclamation_mode : fingerprints = [ f + \"!\" for f in fingerprints ] args = [ f \"--delete-{which}\" ] if secret and self . version >= ( 2 , 1 ) : args . insert ( 0 , \"--yes\" ) args . extend ( fingerprints ) result = self . result_map [ \"delete\" ]( self ) if not secret or self . version < ( 2 , 1 ) : p = self . _open_subprocess ( args ) self . _collect_output ( p , result , stdin = p . stdin ) else : # Need to send in a passphrase. f = _make_binary_stream ( \"\" , self . encoding ) try : self . _handle_io ( args , f , result , passphrase = passphrase , binary = True ) finally : f . close () return result def export_keys ( # noqa : PLR0913 self , keyids : str | list [ str ], * , secret : bool = False , armor : bool = True , minimal : bool = False , passphrase : str | None = None , expect_passphrase : bool = True , output : None = None , ) -> str | bytes : \"\"\" Export the indicated keys . A ' keyid ' is anything ` gpg ` accepts . Args : keyids ( str | list [ str ]) : A single keyid or a list of them . secret ( bool ) : Whether to export secret keys . armor ( bool ) : Whether to ASCII - armor the output . minimal ( bool ) : Whether to pass ` -- export - options export - minimal ` to ` gpg ` . passphrase ( str ) : The passphrase to use . expect_passphrase ( bool ) : Whether a passphrase is expected . output ( str ) : If specified , the path to write the exported key ( s ) to . .. note :: Passphrases Since GnuPG 2.1 , you can ' t export secret keys without providing a passphrase . However , if you ' re expecting the passphrase to go to ` gpg ` via pinentry , you should specify expect_passphrase = False . ( It ' s only checked for GnuPG >= 2.1 ). \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ) : # pragma : no cover msg = \"Invalid passphrase\" raise ValueError ( msg ) which = \"\" if secret : which = \"-secret-key\" if self . version >= ( 2 , 1 ) and passphrase is None and expect_passphrase : # pragma : no cover msg = \"For GnuPG >= 2.1, exporting secret keys needs a passphrase to be provided\" raise ValueError ( msg ) keyids = list ( keyids ) if _is_sequence ( keyids ) else [ keyids ] args = [ f \"--export{which}\" ] if armor : args . append ( \"--armor\" ) if minimal : # pragma : no cover args . extend ([ \"--export-options\" , \"export-minimal\" ]) if output : # pragma : no cover # write the output to a file with the specified name self . set_output_without_confirmation ( args , output ) args . extend ( keyids ) # gpg --export produces no status-fd output; stdout will be # empty in case of failure result = self . result_map [ \"export\" ]( self ) if not secret or self . version < ( 2 , 1 ) : p = self . _open_subprocess ( args ) self . _collect_output ( p , result , stdin = p . stdin ) else : # Need to send in a passphrase. f = _make_binary_stream ( \"\" , self . encoding ) try : self . _handle_io ( args , f , result , passphrase = passphrase , binary = True ) finally : f . close () logger . debug ( \"export_keys result[:100]: %r\" , result . data [ : 100 ]) # Issue #49: Return bytes if armor not specified, else text result = result . data if armor : result = result . decode ( self . encoding , self . decode_errors ) return result def _decode_result ( self , result : ListKeysHandler | ScanKeysHandler , ) -> ListKeysHandler | ScanKeysHandler : lines = result . data . decode ( self . encoding , self . decode_errors ). splitlines () valid_keywords = \"pub uid sec fpr sub ssb sig grp\" . split () for line in lines : if self . verbose : # pragma : no cover pass logger . debug ( \"line: %r\" , line . rstrip ()) if not line : # pragma : no cover break fields = line . strip (). split ( \":\" ) if not fields : # pragma : no cover continue keyword = fields [ 0 ] if keyword in valid_keywords : getattr ( result , keyword )( fields ) return result def _get_list_output ( self , p : Popen , kind : str ) -> ListKeysHandler | ScanKeysHandler : # Get the response information result = self . result_map [ kind ]( self ) self . _collect_output ( p , result , stdin = p . stdin ) return self . _decode_result ( result ) def list_keys ( self , * , secret : bool = False , keys : str | list [ str ] | None = None , sigs : bool = False , ) -> ListKeysHandler : \"\"\" List the keys currently in the keyring . Args : secret ( bool ) : Whether to list secret keys . keys ( str | list [ str ]) : A list of key ids to match . sigs ( bool ) : Whether to include signature information . Returns : list [ dict ] : A list of dictionaries with key information . \"\"\" which = \"secret-keys\" if secret else \"sigs\" if sigs else \"keys\" args = [ f \"--list-{which}\" , \"--fingerprint\" , \"--fingerprint\" ] # get subkey FPs , too if self . version >= ( 2 , 1 ) : args . append ( \"--with-keygrip\" ) if keys : if isinstance ( keys , str ) : keys = [ keys ] args . extend ( keys ) p = self . _open_subprocess ( args ) return self . _get_list_output ( p , \"list\" ) def scan_keys ( self , filename : str ) -> ScanKeysHandler : \"\"\" List details of an ascii armored or binary key file without first importing it to the local keyring . Args : filename ( str ) : The path to the file containing the key ( s ). .. warning :: Warning : Care is needed . The function works on modern GnuPG by running : $ gpg -- dry - run -- import - options import - show -- import filename On older versions , it does the * much * riskier : $ gpg -- with - fingerprint -- with - colons filename \"\"\" if self . version >= ( 2 , 1 ) : args = [ \"--dry-run\" , \"--import-options\" , \"import-show\" , \"--import\" ] else : logger . warning ( \"Trying to list packets, but if the file is not a keyring, might accidentally decrypt\" ) args = [ \"--with-fingerprint\" , \"--with-colons\" , \"--fixed-list-mode\" ] args . append ( filename ) p = self . _open_subprocess ( args ) return self . _get_list_output ( p , \"scan\" ) def scan_keys_mem ( self , key_data : str ) -> ScanKeysHandler : \"\"\" List details of an ascii armored or binary key without first importing it to the local keyring . Args : key_data ( str | bytes ) : The key data to import . .. warning :: Warning : Care is needed . The function works on modern GnuPG by running : $ gpg -- dry - run -- import - options import - show -- import filename On older versions , it does the * much * riskier : $ gpg -- with - fingerprint -- with - colons filename \"\"\" result = self . result_map [ \"scan\" ]( self ) logger . debug ( \"scan_keys: %r\" , key_data [ : 256 ]) data = _make_binary_stream ( key_data , self . encoding ) if self . version >= ( 2 , 1 ) : args = [ \"--dry-run\" , \"--import-options\" , \"import-show\" , \"--import\" ] else : logger . warning ( \"Trying to list packets, but if the file is not a keyring, might accidentally decrypt\" ) args = [ \"--with-fingerprint\" , \"--with-colons\" , \"--fixed-list-mode\" ] self . _handle_io ( args , data , result , binary = True ) logger . debug ( \"scan_keys result: %r\" , result . __dict__ ) data . close () return self . _decode_result ( result ) def search_keys ( self , query : str , keyserver : str = \"pgp.mit.edu\" , extra_args : list [ str ] | None = None , ) -> StatusHandler : \"\"\" search a keyserver by query ( using the ` -- search - keys ` option ). Args : query ( str ) : The query to use . keyserver ( str ) : The key server hostname . extra_args ( list [ str ]) : Additional arguments to pass to ` gpg ` . \"\"\" query = query . strip () if HEX_DIGITS_RE . match ( query ) : query = \"0x\" + query args = [ \"--fingerprint\" , \"--keyserver\" , keyserver ] if extra_args : # pragma : no cover args . extend ( extra_args ) args . extend ([ \"--search-keys\" , query ]) p = self . _open_subprocess ( args ) # Get the response information result = self . result_map [ \"search\" ]( self ) self . _collect_output ( p , result , stdin = p . stdin ) lines = result . data . decode ( self . encoding , self . decode_errors ). splitlines () valid_keywords = [ \"pub\" , \"uid\" ] for line in lines : if self . verbose : # pragma : no cover pass logger . debug ( \"line: %r\" , line . rstrip ()) if not line : # sometimes get blank lines on Windows continue fields = line . strip (). split ( \":\" ) if not fields : # pragma : no cover continue keyword = fields [ 0 ] if keyword in valid_keywords : getattr ( result , keyword )( fields ) return result def auto_locate_key ( self , email : str , mechanisms : list [ str ] | None = None , ** kwargs : list [ str ]) -> StatusHandler : \"\"\" Auto locate a public key by ` email ` . Args : email ( str ) : The email address to search for . mechanisms ( list [ str ]) : A list of mechanisms to use . Valid mechanisms can be found here https : //www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration-Options.html under \"--auto-key-locate\" . Default : [ ' wkd ' , ' ntds ' , ' ldap ' , ' cert ' , ' dane ' , ' local ' ] \"\"\" mechanisms = mechanisms or [ \"wkd\" , \"ntds\" , \"ldap\" , \"cert\" , \"dane\" , \"local\" ] args = [ \"--auto-key-locate\" , \",\" . join ( mechanisms ), \"--locate-keys\" , email ] result = self . result_map [ \"auto-locate-key\" ]( self ) if \"extra_args\" in kwargs : args . extend ( kwargs [ \"extra_args\" ]) process = self . _open_subprocess ( args ) self . _collect_output ( process , result , stdin = process . stdin ) self . _decode_result ( result ) return result def gen_key ( self , key_input : str ) -> GenKeyHandler : \"\"\" Generate a key ; you might use ` gen_key_input () ` to create the input . Args : key_input ( str ) : The input to the key creation operation . \"\"\" args = [ \"--gen-key\" ] result = self . result_map [ \"generate\" ]( self ) f = _make_binary_stream ( key_input , self . encoding ) self . _handle_io ( args , f , result , binary = True ) f . close () return result def gen_key_input ( self , ** kwargs : bool | str | int ) -> str : \"\"\" Generate ` -- gen - key ` input ( see ` gpg ` documentation in DETAILS ). Args : kwargs ( dict ) : A list of keyword arguments . Returns : str : A string suitable for passing to the ` gen_key () ` method . \"\"\" parms = {} no_protection = kwargs . pop ( \"no_protection\" , False ) for key , val in [ item for item in kwargs . items () if str ( item [ 1 ]). strip ()] : parms [ key . replace ( \"_\" , \"-\" ). title ()] = val parms . setdefault ( \"Key-Type\" , \"RSA\" ) if \"key_curve\" not in kwargs : parms . setdefault ( \"Key-Length\" , 2048 ) parms . setdefault ( \"Name-Real\" , \"Autogenerated Key\" ) logname = os . environ . get ( \"LOGNAME\" ) or os . environ . get ( \"USERNAME\" ) or \"unspecified\" hostname = socket . gethostname () parms . setdefault ( \"Name-Email\" , \"{}@{}\" . format ( logname . replace ( \" \" , \"_\" ), hostname )) out = \"Key-Type: {} \\n \" . format ( parms . pop ( \"Key-Type\" )) for key , val in list ( parms . items ()) : out += f \"{key}: {val} \\n \" if no_protection : # pragma : no cover out += \"%no-protection \\n \" out += \"%commit \\n \" return out \"\"\" Key - Type : RSA Key - Length : 1024 Name - Real : ISdlink Server on %s Name - Comment : Created by %s Name - Email : isdlink @ %s Expire - Date : 0 %commit Key - Type : DSA Key - Length : 1024 Subkey - Type : ELG - E Subkey - Length : 1024 Name - Real : Joe Tester Name - Comment : with stupid passphrase Name - Email : joe @ foo . bar Expire - Date : 0 Passphrase : abc %pubring foo . pub %secring foo . sec %commit \"\"\" return None def add_subkey ( self , master_key : str , master_passphrase : str | None = None , algorithm : str = \"rsa\" , usage : str = \"encrypt\" , expire : int = \"-\" , ) -> AddSubkeyHandler : \"\"\" Add subkeys to a master key , Args : master_key ( str ) : The master key . master_passphrase ( str ) : The passphrase for the master key . algorithm ( str ) : The key algorithm to use . usage ( str ) : The desired uses for the subkey . expire ( str ) : The expiration date of the subkey . \"\"\" if self . version [ 0 ] < 2 : # noqa : PLR2004 msg = \"Not available in GnuPG 1.x\" raise NotImplementedError ( msg ) if not master_key : # pragma : no cover msg = \"No master key fingerprint specified\" raise ValueError ( msg ) if master_passphrase and not self . is_valid_passphrase ( master_passphrase ) : # pragma : no cover msg = \"Invalid passphrase\" raise ValueError ( msg ) args = [ \"--quick-add-key\" , master_key , algorithm , usage , str ( expire )] result = self . result_map [ \"addSubkey\" ]( self ) f = _make_binary_stream ( \"\" , self . encoding ) self . _handle_io ( args , f , result , passphrase = master_passphrase , binary = True ) return result # # ENCRYPTION # def encrypt_file ( # noqa : PLR0913 self , fileobj_or_path : BytesIO | str , recipients : str | list [ str ] | tuple [ str , str ] | None , * , sign : str | None = None , always_trust : bool = False , passphrase : str | None = None , armor : bool = True , output : str | None = None , symmetric : bool | str = False , extra_args : list [ str ] | None = None , ) -> CryptHandler : \"\"\" Encrypt data in a file or file - like object . Args : fileobj_or_path ( str | file ) : A path to a file or a file - like object containing the data to be encrypted . recipients ( str | list ) : A key id of a recipient of the encrypted data , or a list of such key ids . sign ( str ) : If specified , the key id of a signer to sign the encrypted data . always_trust ( bool ) : Whether to always trust keys . passphrase ( str ) : The passphrase to use for a signature . armor ( bool ) : Whether to ASCII - armor the output . output ( str ) : A path to write the encrypted output to . symmetric ( bool ) : Whether to use symmetric encryption , extra_args ( list [ str ]) : A list of additional arguments to pass to ` gpg ` . \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ) : msg = \"Invalid passphrase\" raise ValueError ( msg ) args = [ \"--encrypt\" ] if symmetric : # can't be False or None - could be True or a cipher algo value # such as AES256 args = [ \"--symmetric\" ] if symmetric is not True : args . extend ([ \"--cipher-algo\" , symmetric ]) # else use the default, currently CAST5 else : if not recipients : msg = \"No recipients specified with asymmetric encryption\" raise ValueError ( msg ) if not _is_sequence ( recipients ) : recipients = ( recipients ,) for recipient in recipients : args . extend ([ \"--recipient\" , recipient ]) if armor : # create ascii - armored output - False for binary output args . append ( \"--armor\" ) if output : # pragma : no cover # write the output to a file with the specified name self . set_output_without_confirmation ( args , output ) if sign is True : # pragma : no cover args . append ( \"--sign\" ) elif sign : # pragma : no cover args . extend ([ \"--sign\" , \"--default-key\" , sign ]) if always_trust : # pragma : no cover args . extend ([ \"--trust-model\" , \"always\" ]) if extra_args : # pragma : no cover args . extend ( extra_args ) result = self . result_map [ \"crypt\" ]( self ) self . _handle_io ( args , fileobj_or_path , result , passphrase = passphrase , binary = True ) logger . debug ( \"encrypt result[:100]: %r\" , result . data [ : 100 ]) return result def encrypt ( self , data : str | bytes , recipients : str | list [ str ] | tuple [ str , str ] | None , ** kwargs : str | bool | list [ str ], ) -> CryptHandler : \"\"\" Encrypt the message contained in the string * data * for * recipients * . This method delegates most of the work to ` encrypt_file () ` . Args : data ( str | bytes ) : The data to encrypt . recipients ( str | list [ str ]) : A key id of a recipient of the encrypted data , or a list of such key ids . kwargs ( dict ) : Keyword arguments , which are passed to ` encrypt_file () ` : * sign ( str ) : If specified , the key id of a signer to sign the encrypted data . * always_trust ( bool ) : Whether to always trust keys . * passphrase ( str ) : The passphrase to use for a signature . * armor ( bool ) : Whether to ASCII - armor the output . * output ( str ) : A path to write the encrypted output to . * symmetric ( bool ) : Whether to use symmetric encryption , * extra_args ( list [ str ]) : A list of additional arguments to pass to ` gpg ` . \"\"\" data = _make_binary_stream ( data , self . encoding ) result = self . encrypt_file ( data , recipients , ** kwargs ) data . close () return result def decrypt ( self , message : str , ** kwargs : str | list [ str ]) -> CryptHandler : \"\"\" Decrypt the data in * message * . This method delegates most of the work to ` decrypt_file () ` . Args : message ( str | bytes ) : The data to decrypt . A default key will be used for decryption . kwargs ( dict ) : Keyword arguments , which are passed to ` decrypt_file () ` : * always_trust : Whether to always trust keys . * passphrase ( str ) : The passphrase to use . * output ( str ) : If specified , the path to write the decrypted data to . * extra_args ( list [ str ]) : A list of extra arguments to pass to ` gpg ` . \"\"\" data = _make_binary_stream ( message , self . encoding ) result = self . decrypt_file ( data , ** kwargs ) data . close () return result def decrypt_file ( self , fileobj_or_path : str | bytes | BufferedReader | TextIOWrapper | BytesIO , * , always_trust : bool = False , passphrase : str | None = None , output : str | None = None , extra_args : None = None , ) -> CryptHandler : \"\"\" Decrypt data in a file or file - like object . Args : fileobj_or_path ( str | file ) : A path to a file or a file - like object containing the data to be decrypted . always_trust : Whether to always trust keys . passphrase ( str ) : The passphrase to use . output ( str ) : If specified , the path to write the decrypted data to . extra_args ( list [ str ]) : A list of extra arguments to pass to ` gpg ` . \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ) : msg = \"Invalid passphrase\" raise ValueError ( msg ) args = [ \"--decrypt\" ] if output : # pragma : no cover # write the output to a file with the specified name self . set_output_without_confirmation ( args , output ) if always_trust : # pragma : no cover args . extend ([ \"--trust-model\" , \"always\" ]) if extra_args : # pragma : no cover args . extend ( extra_args ) result = self . result_map [ \"crypt\" ]( self ) self . _handle_io ( args , fileobj_or_path , result , passphrase = passphrase , binary = True ) logger . debug ( \"decrypt result[:100]: %r\" , result . data [ : 100 ]) return result def get_recipients ( self , message : str , ** kwargs : list [ str ]) -> list [ str ] : \"\"\"Get the list of recipients for an encrypted message. This method delegates most of the work to ` get_recipients_file () ` . Args : message ( str | bytes ) : The encrypted message . kwargs ( dict ) : Keyword arguments , which are passed to ` get_recipients_file () ` : * extra_args ( list [ str ]) : A list of extra arguments to pass to ` gpg ` . \"\"\" data = _make_binary_stream ( message , self . encoding ) result = self . get_recipients_file ( data , ** kwargs ) data . close () return result def get_recipients_file ( self , fileobj_or_path : BytesIO | str , extra_args : list [ str ] | None = None ) -> list [ str ] : \"\"\" Get the list of recipients for an encrypted message in a file or file - like object . Args : fileobj_or_path ( str | file ) : A path to a file or file - like object containing the encrypted data . extra_args ( list [ str ]) : A list of extra arguments to pass to ` gpg ` . \"\"\" args = [ \"--decrypt\" , \"--list-only\" , \"-v\" ] if extra_args : # pragma : no cover args . extend ( extra_args ) result = self . result_map [ \"crypt\" ]( self ) self . _handle_io ( args , fileobj_or_path , result , binary = True ) return [ m . group ( 1 ) for m in PUBLIC_KEY_RE . finditer ( result . stderr )] def trust_keys ( self , fingerprints : str | list [ str ], trustlevel : str ) -> StatusHandler : \"\"\" Set the trust level for one or more keys . Args : fingerprints ( str | list [ str ]) : A key id for which to set the trust level , or a list of such key ids . trustlevel ( str ) : The trust level . This is one of the following . * ``' TRUST_EXPIRED '`` * ``' TRUST_UNDEFINED '`` * ``' TRUST_NEVER '`` * ``' TRUST_MARGINAL '`` * ``' TRUST_FULLY '`` * ``' TRUST_ULTIMATE '`` \"\"\" levels = VerifyHandler . TRUST_LEVELS if trustlevel not in levels : poss = \", \" . join ( sorted ( levels )) msg = f ' Invalid trust level : \"{trustlevel}\" ( must be one of { poss }) ' raise ValueError ( msg ) trustlevel = levels [ trustlevel ] + 1 import tempfile try : fd , fn = tempfile . mkstemp ( prefix = \"pygpg-\" ) if isinstance ( fingerprints , str ) : fingerprints = [ fingerprints ] lines = [ f \"{f}:{trustlevel}:\" for f in fingerprints ] # The trailing newline is required! s = os . linesep . join ( lines ) + os . linesep logger . debug ( \"writing ownertrust info: %s\" , s ) os . write ( fd , s . encode ( self . encoding )) os . close ( fd ) result = self . result_map [ \"trust\" ]( self ) p = self . _open_subprocess ([ \"--import-ownertrust\" , fn ]) self . _collect_output ( p , result , stdin = p . stdin ) if p . returncode != 0 : raise ValueError ( \"gpg returned an error - return code %d\" % p . returncode ) finally : Path ( fn ). unlink () return result","title":"GPG"},{"location":"reference/gnupg/#class-variables","text":"buffer_size decode_errors error_map result_map A map of GPG operations to result object types.","title":"Class variables"},{"location":"reference/gnupg/#methods","text":"","title":"Methods"},{"location":"reference/gnupg/#add_subkey","text":"def add_subkey ( self , master_key : 'str' , master_passphrase : 'str | None' = None , algorithm : 'str' = 'rsa' , usage : 'str' = 'encrypt' , expire : 'int' = '-' ) -> 'AddSubkeyHandler' Add subkeys to a master key, Parameters: Name Type Description Default master_key str The master key. None master_passphrase str The passphrase for the master key. None algorithm str The key algorithm to use. None usage str The desired uses for the subkey. None expire str The expiration date of the subkey. None View Source def add_subkey ( self , master_key : str , master_passphrase : str | None = None , algorithm : str = \"rsa\" , usage : str = \"encrypt\" , expire : int = \"-\" , ) -> AddSubkeyHandler : \"\"\" Add subkeys to a master key, Args: master_key (str): The master key. master_passphrase (str): The passphrase for the master key. algorithm (str): The key algorithm to use. usage (str): The desired uses for the subkey. expire (str): The expiration date of the subkey. \"\"\" if self . version [ 0 ] < 2 : # noqa : PLR2004 msg = \"Not available in GnuPG 1.x\" raise NotImplementedError ( msg ) if not master_key : # pragma : no cover msg = \"No master key fingerprint specified\" raise ValueError ( msg ) if master_passphrase and not self . is_valid_passphrase ( master_passphrase ) : # pragma : no cover msg = \"Invalid passphrase\" raise ValueError ( msg ) args = [ \"--quick-add-key\" , master_key , algorithm , usage , str ( expire )] result = self . result_map [ \"addSubkey\" ]( self ) f = _make_binary_stream ( \"\" , self . encoding ) self . _handle_io ( args , f , result , passphrase = master_passphrase , binary = True ) return result","title":"add_subkey"},{"location":"reference/gnupg/#auto_locate_key","text":"def auto_locate_key ( self , email : 'str' , mechanisms : 'list[str] | None' = None , ** kwargs : 'list[str]' ) -> 'StatusHandler' Auto locate a public key by email . Parameters: Name Type Description Default email str The email address to search for. None mechanisms list[str] A list of mechanisms to use. Valid mechanisms can be found None here https None //www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration-Options.html None under \"--auto-key-locate\". Default None ['wkd', 'ntds', 'ldap', 'cert', 'dane', 'local'] None View Source def auto_locate_key ( self , email : str , mechanisms : list [ str ] | None = None , ** kwargs : list [ str ] ) -> StatusHandler : \"\"\" Auto locate a public key by `email`. Args: email (str): The email address to search for. mechanisms (list[str]): A list of mechanisms to use. Valid mechanisms can be found here https://www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration-Options.html under \" -- auto - key - locate \". Default: ['wkd', 'ntds', 'ldap', 'cert', 'dane', 'local'] \"\"\" mechanisms = mechanisms or [ \"wkd\", \"ntds\", \"ldap\", \"cert\", \"dane\", \"local\" ] args = [ \"--auto-key-locate\", \",\".join(mechanisms), \"--locate-keys\", email ] result = self . result_map [ \"auto-locate-key\" ] ( self ) if \"extra_args\" in kwargs : args . extend ( kwargs [ \"extra_args\" ] ) process = self . _open_subprocess ( args ) self . _collect_output ( process , result , stdin = process . stdin ) self . _decode_result ( result ) return result","title":"auto_locate_key"},{"location":"reference/gnupg/#decrypt","text":"def decrypt ( self , message : 'str' , ** kwargs : 'str | list[str]' ) -> 'CryptHandler' Decrypt the data in message . This method delegates most of the work to decrypt_file() . Parameters: Name Type Description Default message str bytes The data to decrypt. A default key will be used for decryption. kwargs dict Keyword arguments, which are passed to decrypt_file() : always_trust: Whether to always trust keys. passphrase (str): The passphrase to use. output (str): If specified, the path to write the decrypted data to. extra_args (list[str]): A list of extra arguments to pass to gpg . None View Source def decrypt ( self , message : str , ** kwargs : str | list [ str ] ) -> CryptHandler : \"\"\" Decrypt the data in *message*. This method delegates most of the work to `decrypt_file()`. Args: message (str|bytes): The data to decrypt. A default key will be used for decryption. kwargs (dict): Keyword arguments, which are passed to `decrypt_file()`: * always_trust: Whether to always trust keys. * passphrase (str): The passphrase to use. * output (str): If specified, the path to write the decrypted data to. * extra_args (list[str]): A list of extra arguments to pass to `gpg`. \"\"\" data = _make_binary_stream ( message , self . encoding ) result = self . decrypt_file ( data , ** kwargs ) data . close () return result","title":"decrypt"},{"location":"reference/gnupg/#decrypt_file","text":"def decrypt_file ( self , fileobj_or_path : 'str | bytes | BufferedReader | TextIOWrapper | BytesIO' , * , always_trust : 'bool' = False , passphrase : 'str | None' = None , output : 'str | None' = None , extra_args : 'None' = None ) -> 'CryptHandler' Decrypt data in a file or file-like object. Parameters: Name Type Description Default fileobj_or_path str file A path to a file or a file-like object containing the data to be decrypted. always_trust None Whether to always trust keys. None passphrase str The passphrase to use. None output str If specified, the path to write the decrypted data to. None extra_args list[str] A list of extra arguments to pass to gpg . None View Source def decrypt_file ( self , fileobj_or_path : str | bytes | BufferedReader | TextIOWrapper | BytesIO , * , always_trust : bool = False , passphrase : str | None = None , output : str | None = None , extra_args : None = None , ) -> CryptHandler : \" \"\" Decrypt data in a file or file-like object. Args: fileobj_or_path (str|file): A path to a file or a file-like object containing the data to be decrypted. always_trust: Whether to always trust keys. passphrase (str): The passphrase to use. output (str): If specified, the path to write the decrypted data to. extra_args (list[str]): A list of extra arguments to pass to `gpg`. \"\" \" if passphrase and not self . is_valid_passphrase ( passphrase ) : msg = \"Invalid passphrase\" raise ValueError ( msg ) args = [ \"--decrypt\" ] if output : # pragma: no cover # write the output to a file with the specified name self . set _output_without_confirmation ( args , output ) if always_trust : # pragma: no cover args . extend ( [ \"--trust-model\" , \"always\" ] ) if extra_args : # pragma: no cover args . extend ( extra_args ) result = self . result_map [ \"crypt\" ] ( self ) self . _handle_io ( args , fileobj_or_path , result , passphrase = passphrase , binary = True ) logger . debug ( \"decrypt result[:100]: %r\" , result . data [ : 100 ] ) return result","title":"decrypt_file"},{"location":"reference/gnupg/#delete_keys","text":"def delete_keys ( self , fingerprints : 'str' , * , secret : 'bool' = False , passphrase : 'str | None' = None , expect_passphrase : 'bool' = True , exclamation_mode : 'bool' = False ) -> 'DeleteResultHandler' Delete the indicated keys. Parameters: Name Type Description Default fingerprints str list[str] The keys to delete. secret bool Whether to delete secret keys. None passphrase str The passphrase to use. None expect_passphrase bool Whether a passphrase is expected. None exclamation_mode bool If specified, a '!' is appended to each fingerprint. This deletes only a subkey or an entire key, depending on what the fingerprint refers to. None View Source def delete_keys ( self , fingerprints : str , * , secret : bool = False , passphrase : str | None = None , expect_passphrase : bool = True , exclamation_mode : bool = False , ) -> DeleteResultHandler : \"\"\" Delete the indicated keys. Args: fingerprints (str|list[str]): The keys to delete. secret (bool): Whether to delete secret keys. passphrase (str): The passphrase to use. expect_passphrase (bool): Whether a passphrase is expected. exclamation_mode (bool): If specified, a `'!'` is appended to each fingerprint. This deletes only a subkey or an entire key, depending on what the fingerprint refers to. .. note:: Passphrases Since GnuPG 2.1, you can't delete secret keys without providing a passphrase. However, if you're expecting the passphrase to go to `gpg` via pinentry, you should specify expect_passphrase=False. (It's only checked for GnuPG >= 2.1). \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ) : # pragma : no cover msg = \"Invalid passphrase\" raise ValueError ( msg ) which = \"key\" if secret : # pragma : no cover if self . version >= ( 2 , 1 ) and passphrase is None and expect_passphrase : msg = \"For GnuPG >= 2.1, deleting secret keys needs a passphrase to be provided\" raise ValueError ( msg ) which = \"secret-key\" fingerprints = list ( fingerprints ) if _is_sequence ( fingerprints ) else [ fingerprints ] if exclamation_mode : fingerprints = [ f + \"!\" for f in fingerprints ] args = [ f\"--delete-{which}\" ] if secret and self . version >= ( 2 , 1 ) : args . insert ( 0 , \"--yes\" ) args . extend ( fingerprints ) result = self . result_map [ \"delete\" ] ( self ) if not secret or self . version < ( 2 , 1 ) : p = self . _open_subprocess ( args ) self . _collect_output ( p , result , stdin = p . stdin ) else : # Need to send in a passphrase . f = _make_binary_stream ( \"\" , self . encoding ) try : self . _handle_io ( args , f , result , passphrase = passphrase , binary = True ) finally : f . close () return result","title":"delete_keys"},{"location":"reference/gnupg/#encrypt","text":"def encrypt ( self , data : 'str | bytes' , recipients : 'str | list[str] | tuple[str, str] | None' , ** kwargs : 'str | bool | list[str]' ) -> 'CryptHandler' Encrypt the message contained in the string data for recipients . This method delegates most of the work to encrypt_file() . Parameters: Name Type Description Default data str bytes The data to encrypt. recipients str list[str] A key id of a recipient of the encrypted data, or a list of such key ids. kwargs dict Keyword arguments, which are passed to encrypt_file() : sign (str): If specified, the key id of a signer to sign the encrypted data. always_trust (bool): Whether to always trust keys. passphrase (str): The passphrase to use for a signature. armor (bool): Whether to ASCII-armor the output. output (str): A path to write the encrypted output to. symmetric (bool): Whether to use symmetric encryption, * extra_args (list[str]): A list of additional arguments to pass to gpg . None View Source def encrypt ( self , data : str | bytes , recipients : str | list [ str ] | tuple [ str, str ] | None , ** kwargs : str | bool | list [ str ] , ) -> CryptHandler : \"\"\" Encrypt the message contained in the string *data* for *recipients*. This method delegates most of the work to `encrypt_file()`. Args: data (str|bytes): The data to encrypt. recipients (str|list[str]): A key id of a recipient of the encrypted data, or a list of such key ids. kwargs (dict): Keyword arguments, which are passed to `encrypt_file()`: * sign (str): If specified, the key id of a signer to sign the encrypted data. * always_trust (bool): Whether to always trust keys. * passphrase (str): The passphrase to use for a signature. * armor (bool): Whether to ASCII-armor the output. * output (str): A path to write the encrypted output to. * symmetric (bool): Whether to use symmetric encryption, * extra_args (list[str]): A list of additional arguments to pass to `gpg`. \"\"\" data = _make_binary_stream ( data , self . encoding ) result = self . encrypt_file ( data , recipients , ** kwargs ) data . close () return result","title":"encrypt"},{"location":"reference/gnupg/#encrypt_file","text":"def encrypt_file ( self , fileobj_or_path : 'BytesIO | str' , recipients : 'str | list[str] | tuple[str, str] | None' , * , sign : 'str | None' = None , always_trust : 'bool' = False , passphrase : 'str | None' = None , armor : 'bool' = True , output : 'str | None' = None , symmetric : 'bool | str' = False , extra_args : 'list[str] | None' = None ) -> 'CryptHandler' Encrypt data in a file or file-like object. Parameters: Name Type Description Default fileobj_or_path str file A path to a file or a file-like object containing the data to be encrypted. recipients str list A key id of a recipient of the encrypted data, or a list of such key ids. sign str If specified, the key id of a signer to sign the encrypted data. None always_trust bool Whether to always trust keys. None passphrase str The passphrase to use for a signature. None armor bool Whether to ASCII-armor the output. None output str A path to write the encrypted output to. None symmetric bool Whether to use symmetric encryption, None extra_args list[str] A list of additional arguments to pass to gpg . None View Source def encrypt_file ( # noqa : PLR0913 self , fileobj_or_path : BytesIO | str , recipients : str | list [ str ] | tuple [ str, str ] | None , * , sign : str | None = None , always_trust : bool = False , passphrase : str | None = None , armor : bool = True , output : str | None = None , symmetric : bool | str = False , extra_args : list [ str ] | None = None , ) -> CryptHandler : \"\"\" Encrypt data in a file or file-like object. Args: fileobj_or_path (str|file): A path to a file or a file-like object containing the data to be encrypted. recipients (str|list): A key id of a recipient of the encrypted data, or a list of such key ids. sign (str): If specified, the key id of a signer to sign the encrypted data. always_trust (bool): Whether to always trust keys. passphrase (str): The passphrase to use for a signature. armor (bool): Whether to ASCII-armor the output. output (str): A path to write the encrypted output to. symmetric (bool): Whether to use symmetric encryption, extra_args (list[str]): A list of additional arguments to pass to `gpg`. \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ) : msg = \"Invalid passphrase\" raise ValueError ( msg ) args = [ \"--encrypt\" ] if symmetric : # can ' t be False or None - could be True or a cipher algo value # such as AES256 args = [ \"--symmetric\" ] if symmetric is not True : args . extend ( [ \"--cipher-algo\", symmetric ] ) # else use the default , currently CAST5 else : if not recipients : msg = \"No recipients specified with asymmetric encryption\" raise ValueError ( msg ) if not _is_sequence ( recipients ) : recipients = ( recipients ,) for recipient in recipients : args . extend ( [ \"--recipient\", recipient ] ) if armor : # create ascii - armored output - False for binary output args . append ( \"--armor\" ) if output : # pragma : no cover # write the output to a file with the specified name self . set_output_without_confirmation ( args , output ) if sign is True : # pragma : no cover args . append ( \"--sign\" ) elif sign : # pragma : no cover args . extend ( [ \"--sign\", \"--default-key\", sign ] ) if always_trust : # pragma : no cover args . extend ( [ \"--trust-model\", \"always\" ] ) if extra_args : # pragma : no cover args . extend ( extra_args ) result = self . result_map [ \"crypt\" ] ( self ) self . _handle_io ( args , fileobj_or_path , result , passphrase = passphrase , binary = True ) logger . debug ( \"encrypt result[:100]: %r\" , result . data [ :100 ] ) return result","title":"encrypt_file"},{"location":"reference/gnupg/#export_keys","text":"def export_keys ( self , keyids : 'str | list[str]' , * , secret : 'bool' = False , armor : 'bool' = True , minimal : 'bool' = False , passphrase : 'str | None' = None , expect_passphrase : 'bool' = True , output : 'None' = None ) -> 'str | bytes' Export the indicated keys. A 'keyid' is anything gpg accepts. Parameters: Name Type Description Default keyids str list[str] A single keyid or a list of them. secret bool Whether to export secret keys. None armor bool Whether to ASCII-armor the output. None minimal bool Whether to pass --export-options export-minimal to gpg . None passphrase str The passphrase to use. None expect_passphrase bool Whether a passphrase is expected. None output str If specified, the path to write the exported key(s) to. None View Source def export_keys ( # noqa: PLR0913 self , keyids : str | list [ str ], * , secret : bool = False , armor : bool = True , minimal : bool = False , passphrase : str | None = None , expect_passphrase : bool = True , output : None = None , ) -> str | bytes : \"\"\" Export the indicated keys. A 'keyid' is anything `gpg` accepts. Args: keyids (str|list[str]): A single keyid or a list of them. secret (bool): Whether to export secret keys. armor (bool): Whether to ASCII-armor the output. minimal (bool): Whether to pass `--export-options export-minimal` to `gpg`. passphrase (str): The passphrase to use. expect_passphrase (bool): Whether a passphrase is expected. output (str): If specified, the path to write the exported key(s) to. .. note:: Passphrases Since GnuPG 2.1, you can't export secret keys without providing a passphrase. However, if you're expecting the passphrase to go to `gpg` via pinentry, you should specify expect_passphrase=False. (It's only checked for GnuPG >= 2.1). \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ): # pragma: no cover msg = \"Invalid passphrase\" raise ValueError ( msg ) which = \"\" if secret : which = \"-secret-key\" if self . version >= ( 2 , 1 ) and passphrase is None and expect_passphrase : # pragma: no cover msg = \"For GnuPG >= 2.1, exporting secret keys needs a passphrase to be provided\" raise ValueError ( msg ) keyids = list ( keyids ) if _is_sequence ( keyids ) else [ keyids ] args = [ f \"--export{which}\" ] if armor : args . append ( \"--armor\" ) if minimal : # pragma: no cover args . extend ([ \"--export-options\" , \"export-minimal\" ]) if output : # pragma: no cover # write the output to a file with the specified name self . set_output_without_confirmation ( args , output ) args . extend ( keyids ) # gpg --export produces no status-fd output; stdout will be # empty in case of failure result = self . result_map [ \"export\" ]( self ) if not secret or self . version < ( 2 , 1 ): p = self . _open_subprocess ( args ) self . _collect_output ( p , result , stdin = p . stdin ) else : # Need to send in a passphrase. f = _make_binary_stream ( \"\" , self . encoding ) try : self . _handle_io ( args , f , result , passphrase = passphrase , binary = True ) finally : f . close () logger . debug ( \"export_keys result[:100]: %r \" , result . data [: 100 ]) # Issue #49: Return bytes if armor not specified, else text result = result . data if armor : result = result . decode ( self . encoding , self . decode_errors ) return result","title":"export_keys"},{"location":"reference/gnupg/#gen_key","text":"def gen_key ( self , key_input : 'str' ) -> 'GenKeyHandler' Generate a key; you might use gen_key_input() to create the input. Parameters: Name Type Description Default key_input str The input to the key creation operation. None View Source def gen_key ( self , key_input : str ) - > GenKeyHandler : \"\"\" Generate a key; you might use `gen_key_input()` to create the input. Args: key_input (str): The input to the key creation operation. \"\"\" args = [ \"--gen-key\" ] result = self . result_map [ \"generate\" ] ( self ) f = _make_binary_stream ( key_input , self . encoding ) self . _handle_io ( args , f , result , binary = True ) f . close () return result","title":"gen_key"},{"location":"reference/gnupg/#gen_key_input","text":"def gen_key_input ( self , ** kwargs : 'bool | str | int' ) -> 'str' Generate --gen-key input (see gpg documentation in DETAILS). Parameters: Name Type Description Default kwargs dict A list of keyword arguments. None Returns: Type Description str A string suitable for passing to the gen_key() method. View Source def gen_key_input ( self , ** kwargs : bool | str | int ) -> str : \"\"\" Generate ` -- gen - key ` input ( see ` gpg ` documentation in DETAILS ). Args : kwargs ( dict ) : A list of keyword arguments . Returns : str : A string suitable for passing to the ` gen_key () ` method . \"\"\" parms = {} no_protection = kwargs . pop ( \"no_protection\" , False ) for key , val in [ item for item in kwargs . items () if str ( item [ 1 ]). strip ()] : parms [ key . replace ( \"_\" , \"-\" ). title ()] = val parms . setdefault ( \"Key-Type\" , \"RSA\" ) if \"key_curve\" not in kwargs : parms . setdefault ( \"Key-Length\" , 2048 ) parms . setdefault ( \"Name-Real\" , \"Autogenerated Key\" ) logname = os . environ . get ( \"LOGNAME\" ) or os . environ . get ( \"USERNAME\" ) or \"unspecified\" hostname = socket . gethostname () parms . setdefault ( \"Name-Email\" , \"{}@{}\" . format ( logname . replace ( \" \" , \"_\" ), hostname )) out = \"Key-Type: {} \\n \" . format ( parms . pop ( \"Key-Type\" )) for key , val in list ( parms . items ()) : out += f \"{key}: {val} \\n \" if no_protection : # pragma : no cover out += \"%no-protection \\n \" out += \"%commit \\n \" return out \"\"\" Key - Type : RSA Key - Length : 1024 Name - Real : ISdlink Server on %s Name - Comment : Created by %s Name - Email : isdlink @ %s Expire - Date : 0 %commit Key - Type : DSA Key - Length : 1024 Subkey - Type : ELG - E Subkey - Length : 1024 Name - Real : Joe Tester Name - Comment : with stupid passphrase Name - Email : joe @ foo . bar Expire - Date : 0 Passphrase : abc %pubring foo . pub %secring foo . sec %commit \"\"\" return None","title":"gen_key_input"},{"location":"reference/gnupg/#get_recipients","text":"def get_recipients ( self , message : 'str' , ** kwargs : 'list[str]' ) -> 'list[str]' Get the list of recipients for an encrypted message. This method delegates most of the work to get_recipients_file() . Parameters: Name Type Description Default message str bytes The encrypted message. kwargs dict Keyword arguments, which are passed to get_recipients_file() : * extra_args (list[str]): A list of extra arguments to pass to gpg . None View Source def get_recipients ( self , message : str , ** kwargs : list [ str ] ) -> list [ str ] : \"\"\"Get the list of recipients for an encrypted message. This method delegates most of the work to `get_recipients_file()`. Args: message (str|bytes): The encrypted message. kwargs (dict): Keyword arguments, which are passed to `get_recipients_file()`: * extra_args (list[str]): A list of extra arguments to pass to `gpg`. \"\"\" data = _make_binary_stream ( message , self . encoding ) result = self . get_recipients_file ( data , ** kwargs ) data . close () return result","title":"get_recipients"},{"location":"reference/gnupg/#get_recipients_file","text":"def get_recipients_file ( self , fileobj_or_path : 'BytesIO | str' , extra_args : 'list[str] | None' = None ) -> 'list[str]' Get the list of recipients for an encrypted message in a file or file-like object. Parameters: Name Type Description Default fileobj_or_path str file A path to a file or file-like object containing the encrypted data. extra_args list[str] A list of extra arguments to pass to gpg . None View Source def get_recipients_file ( self , fileobj_or_path : BytesIO | str , extra_args : list [ str ] | None = None ) -> list [ str ] : \"\"\" Get the list of recipients for an encrypted message in a file or file-like object. Args: fileobj_or_path (str|file): A path to a file or file-like object containing the encrypted data. extra_args (list[str]): A list of extra arguments to pass to `gpg`. \"\"\" args = [ \"--decrypt\", \"--list-only\", \"-v\" ] if extra_args : # pragma : no cover args . extend ( extra_args ) result = self . result_map [ \"crypt\" ] ( self ) self . _handle_io ( args , fileobj_or_path , result , binary = True ) return [ m.group(1) for m in PUBLIC_KEY_RE.finditer(result.stderr) ]","title":"get_recipients_file"},{"location":"reference/gnupg/#import_keys","text":"def import_keys ( self , key_data : 'str | bytes' , extra_args : 'None' = None , passphrase : 'None' = None ) -> 'ImportResultHandler' Import the key_data into our keyring. Parameters: Name Type Description Default key_data str bytes The key data to import. passphrase str The passphrase to use. None extra_args list[str] Additional arguments to pass to gpg . None View Source def import_keys ( self , key_data : str | bytes , extra_args : None = None , passphrase : None = None , ) -> ImportResultHandler : \" \"\" Import the key_data into our keyring. Args: key_data (str|bytes): The key data to import. passphrase (str): The passphrase to use. extra_args (list[str]): Additional arguments to pass to `gpg`. \"\" \" result = self . result_map [ \"import\" ] ( self ) logger . debug ( \"import_keys: %r\" , key_data [ : 256 ] ) data = _make_binary_stream ( key_data , self . encoding ) args = [ \"--import\" ] if extra_args : # pragma: no cover args . extend ( extra_args ) self . _handle_io ( args , data , result , passphrase = passphrase , binary = True ) logger . debug ( \"import_keys result: %r\" , result . __dict__ ) data . close () return result","title":"import_keys"},{"location":"reference/gnupg/#import_keys_file","text":"def import_keys_file ( self , key_path : 'str' , ** kwargs : 'str | list[str]' ) -> 'ImportResultHandler' Import the key data in key_path into our keyring. Parameters: Name Type Description Default key_path str A path to the key data to be imported. None View Source def import_keys_file ( self , key_path : str , ** kwargs : str | list [ str ] ) -> ImportResultHandler : \"\"\" Import the key data in key_path into our keyring. Args: key_path (str): A path to the key data to be imported. \"\"\" with Path ( key_path ). open ( \"rb\" ) as f : return self . import_keys ( f . read (), ** kwargs )","title":"import_keys_file"},{"location":"reference/gnupg/#is_valid_file","text":"def is_valid_file ( self , fileobj : 'str | bytes | BufferedReader | TextIOWrapper | BytesIO' ) -> 'bool' A simplistic check for a file-like object. Parameters: Name Type Description Default fileobj object The object to test. None Returns: Type Description bool True if it's a file-like object, else False . View Source def is_valid_file ( self , fileobj : str | bytes | BufferedReader | TextIOWrapper | BytesIO ) -> bool : \" \"\" A simplistic check for a file-like object. Args: fileobj (object): The object to test. Returns: bool: ``True`` if it's a file-like object, else ``False``. \"\" \" return hasattr ( fileobj , \"read\" )","title":"is_valid_file"},{"location":"reference/gnupg/#is_valid_passphrase","text":"def is_valid_passphrase ( self , passphrase : 'str' ) -> 'bool' Confirm that the passphrase doesn't contain newline-type characters - it is passed in a pipe to gpg , and so not checking could lead to spoofing attacks by passing arbitrary text after passphrase and newline. Parameters: Name Type Description Default passphrase str The passphrase to test. None Returns: Type Description bool True if it's a valid passphrase, else False . View Source def is_valid_passphrase ( self , passphrase : str ) -> bool : \" \"\" Confirm that the passphrase doesn't contain newline-type characters - it is passed in a pipe to `gpg`, and so not checking could lead to spoofing attacks by passing arbitrary text after passphrase and newline. Args: passphrase (str): The passphrase to test. Returns: bool: ``True`` if it's a valid passphrase, else ``False``. \"\" \" return \" \\n \" not in passphrase and \" \\r \" not in passphrase and \" \\ x00\" not in passphrase","title":"is_valid_passphrase"},{"location":"reference/gnupg/#list_keys","text":"def list_keys ( self , * , secret : 'bool' = False , keys : 'str | list[str] | None' = None , sigs : 'bool' = False ) -> 'ListKeysHandler' List the keys currently in the keyring. Parameters: Name Type Description Default secret bool Whether to list secret keys. None keys str list[str] A list of key ids to match. sigs bool Whether to include signature information. None Returns: Type Description list[dict] A list of dictionaries with key information. View Source def list_keys ( self , * , secret : bool = False , keys : str | list [ str ] | None = None , sigs : bool = False , ) -> ListKeysHandler : \"\"\" List the keys currently in the keyring. Args: secret (bool): Whether to list secret keys. keys (str|list[str]): A list of key ids to match. sigs (bool): Whether to include signature information. Returns: list[dict]: A list of dictionaries with key information. \"\"\" which = \"secret-keys\" if secret else \"sigs\" if sigs else \"keys\" args = [ f\"--list-{which}\", \"--fingerprint\", \"--fingerprint\" ] # get subkey FPs , too if self . version >= ( 2 , 1 ) : args . append ( \"--with-keygrip\" ) if keys : if isinstance ( keys , str ) : keys = [ keys ] args . extend ( keys ) p = self . _open_subprocess ( args ) return self . _get_list_output ( p , \"list\" )","title":"list_keys"},{"location":"reference/gnupg/#make_args","text":"def make_args ( self , args : 'list[str]' , * , passphrase : 'bool | None' = False ) -> 'list[str]' Make a list of command line elements for GPG. The value of args will be appended. The passphrase argument needs to be True if a passphrase will be sent to gpg , else False. Parameters: Name Type Description Default args list[str] A list of arguments. None passphrase str The passphrase to use. None View Source def make_args ( self , args : list [ str ] , * , passphrase : bool | None = False ) -> list [ str ] : \" \"\" Make a list of command line elements for GPG. The value of ``args`` will be appended. The ``passphrase`` argument needs to be True if a passphrase will be sent to `gpg`, else False. Args: args (list[str]): A list of arguments. passphrase (str): The passphrase to use. \"\" \" cmd = [ self . gpgbinary , \"--status-fd\" , \"2\" , \"--no-tty\" , \"--no-verbose\" ] if \"DEBUG_IPC\" in os . environ : # pragma: no cover cmd . extend ( [ \"--debug\" , \"ipc\" ] ) if passphrase and hasattr ( self , \"version\" ) and self . version >= ( 2 , 1 ) : cmd [ 1 : 1 ] = [ \"--pinentry-mode\" , \"loopback\" ] cmd . extend ( [ \"--fixed-list-mode\" , \"--batch\" , \"--with-colons\" ] ) if self . gnupghome : cmd . extend ( [ \"--homedir\" , str ( self . gnupghome ) ] ) if self . keyring : cmd . append ( \"--no-default-keyring\" ) for fn in self . keyring : cmd . extend ( [ \"--keyring\" , fn ] ) if self . secret_keyring : # pragma: no cover for fn in self . secret_keyring : cmd . extend ( [ \"--secret-keyring\" , fn ] ) if passphrase : cmd . extend ( [ \"--passphrase-fd\" , \"0\" ] ) if self . use_agent : # pragma: no cover cmd . append ( \"--use-agent\" ) if self . options : cmd . extend ( self . options ) cmd . extend ( args ) return cmd","title":"make_args"},{"location":"reference/gnupg/#recv_keys","text":"def recv_keys ( self , keyserver : 'str' , * keyids : 'str' , ** kwargs : 'list[str]' ) -> 'ImportResultHandler' Import one or more keys from a keyserver. Parameters: Name Type Description Default keyserver str The key server hostname. None keyids str A list of key ids to receive. None View Source def recv_keys ( self , keyserver : str , * keyids : str , ** kwargs : list [ str ] ) -> ImportResultHandler : \"\"\" Import one or more keys from a keyserver. Args: keyserver (str): The key server hostname. keyids (str): A list of key ids to receive. \"\"\" result = self . result_map [ \"import\" ] ( self ) logger . debug ( \"recv_keys: %r\" , keyids ) data = _make_binary_stream ( \"\" , self . encoding ) args = [ \"--keyserver\", keyserver ] if \"extra_args\" in kwargs : # pragma : no cover args . extend ( kwargs [ \"extra_args\" ] ) args . append ( \"--recv-keys\" ) args . extend ( list ( keyids )) self . _handle_io ( args , data , result , binary = True ) logger . debug ( \"recv_keys result: %r\" , result . __dict__ ) data . close () return result","title":"recv_keys"},{"location":"reference/gnupg/#scan_keys","text":"def scan_keys ( self , filename : 'str' ) -> 'ScanKeysHandler' List details of an ascii armored or binary key file without first importing it to the local keyring. Parameters: Name Type Description Default filename str The path to the file containing the key(s). None View Source def scan_keys ( self , filename : str ) -> ScanKeysHandler : \"\"\" List details of an ascii armored or binary key file without first importing it to the local keyring. Args: filename (str): The path to the file containing the key(s). .. warning:: Warning: Care is needed. The function works on modern GnuPG by running: $ gpg --dry-run --import-options import-show --import filename On older versions, it does the *much* riskier: $ gpg --with-fingerprint --with-colons filename \"\"\" if self . version >= ( 2 , 1 ): args = [ \"--dry-run\" , \"--import-options\" , \"import-show\" , \"--import\" ] else : logger . warning ( \"Trying to list packets, but if the file is not a keyring, might accidentally decrypt\" ) args = [ \"--with-fingerprint\" , \"--with-colons\" , \"--fixed-list-mode\" ] args . append ( filename ) p = self . _open_subprocess ( args ) return self . _get_list_output ( p , \"scan\" )","title":"scan_keys"},{"location":"reference/gnupg/#scan_keys_mem","text":"def scan_keys_mem ( self , key_data : 'str' ) -> 'ScanKeysHandler' List details of an ascii armored or binary key without first importing it to the local keyring. Parameters: Name Type Description Default key_data str bytes The key data to import. View Source def scan_keys_mem ( self , key_data : str ) -> ScanKeysHandler : \"\"\" List details of an ascii armored or binary key without first importing it to the local keyring. Args: key_data (str|bytes): The key data to import. .. warning:: Warning: Care is needed. The function works on modern GnuPG by running: $ gpg --dry-run --import-options import-show --import filename On older versions, it does the *much* riskier: $ gpg --with-fingerprint --with-colons filename \"\"\" result = self . result_map [ \"scan\" ]( self ) logger . debug ( \"scan_keys: %r \" , key_data [: 256 ]) data = _make_binary_stream ( key_data , self . encoding ) if self . version >= ( 2 , 1 ): args = [ \"--dry-run\" , \"--import-options\" , \"import-show\" , \"--import\" ] else : logger . warning ( \"Trying to list packets, but if the file is not a keyring, might accidentally decrypt\" ) args = [ \"--with-fingerprint\" , \"--with-colons\" , \"--fixed-list-mode\" ] self . _handle_io ( args , data , result , binary = True ) logger . debug ( \"scan_keys result: %r \" , result . __dict__ ) data . close () return self . _decode_result ( result )","title":"scan_keys_mem"},{"location":"reference/gnupg/#search_keys","text":"def search_keys ( self , query : 'str' , keyserver : 'str' = 'pgp.mit.edu' , extra_args : 'list[str] | None' = None ) -> 'StatusHandler' search a keyserver by query (using the --search-keys option). Parameters: Name Type Description Default query str The query to use. None keyserver str The key server hostname. None extra_args list[str] Additional arguments to pass to gpg . None View Source def search_keys ( self , query : str , keyserver : str = \"pgp.mit.edu\" , extra_args : list [ str ] | None = None , ) -> StatusHandler : \"\"\" search a keyserver by query (using the `--search-keys` option). Args: query(str): The query to use. keyserver (str): The key server hostname. extra_args (list[str]): Additional arguments to pass to `gpg`. \"\"\" query = query . strip () if HEX_DIGITS_RE . match ( query ) : query = \"0x\" + query args = [ \"--fingerprint\", \"--keyserver\", keyserver ] if extra_args : # pragma : no cover args . extend ( extra_args ) args . extend ( [ \"--search-keys\", query ] ) p = self . _open_subprocess ( args ) # Get the response information result = self . result_map [ \"search\" ] ( self ) self . _collect_output ( p , result , stdin = p . stdin ) lines = result . data . decode ( self . encoding , self . decode_errors ). splitlines () valid_keywords = [ \"pub\", \"uid\" ] for line in lines : if self . verbose : # pragma : no cover pass logger . debug ( \"line: %r\" , line . rstrip ()) if not line : # sometimes get blank lines on Windows continue fields = line . strip (). split ( \":\" ) if not fields : # pragma : no cover continue keyword = fields [ 0 ] if keyword in valid_keywords : getattr ( result , keyword )( fields ) return result","title":"search_keys"},{"location":"reference/gnupg/#send_keys","text":"def send_keys ( self , keyserver : 'str' , * keyids : 'str' , ** kwargs : 'list[str]' ) -> 'StatusHandler' Send one or more keys to a keyserver. Parameters: Name Type Description Default keyserver str The key server hostname. None keyids list[str] A list of key ids to send. None View Source def send_keys ( self , keyserver : str , * keyids : str , ** kwargs : list [ str ] ) -> StatusHandler : # pragma : no cover \"\"\" Send one or more keys to a keyserver. Args: keyserver (str): The key server hostname. keyids (list[str]): A list of key ids to send. \"\"\" # Note : it ' s not practical to test this function without sending # arbitrary data to live keyservers . result = self . result_map [ \"send\" ] ( self ) logger . debug ( \"send_keys: %r\" , keyids ) data = _make_binary_stream ( \"\" , self . encoding ) args = [ \"--keyserver\", keyserver ] if \"extra_args\" in kwargs : args . extend ( kwargs [ \"extra_args\" ] ) args . append ( \"--send-keys\" ) args . extend ( list ( keyids )) self . _handle_io ( args , data , result , binary = True ) logger . debug ( \"send_keys result: %r\" , result . __dict__ ) data . close () return result","title":"send_keys"},{"location":"reference/gnupg/#set_output_without_confirmation","text":"def set_output_without_confirmation ( self , args : 'list[str]' , output : 'str' ) -> 'None' If writing to a file which exists, avoid a confirmation message by updating the args value in place to set the output path and avoid any cpmfirmation prompt. Parameters: Name Type Description Default args list[str] A list of arguments. None output str The path to the outpur file. None View Source def set_output_without_confirmation ( self , args : list [ str ] , output : str ) -> None : \"\"\" If writing to a file which exists, avoid a confirmation message by updating the *args* value in place to set the output path and avoid any cpmfirmation prompt. Args: args (list[str]): A list of arguments. output (str): The path to the outpur file. \"\"\" if Path ( output ). exists () : # We need to avoid an overwrite confirmation message args . extend ( [ \"--yes\" ] ) args . extend ( [ \"--output\", output ] )","title":"set_output_without_confirmation"},{"location":"reference/gnupg/#sign","text":"def sign ( self , message : 'bytes' , ** kwargs : 'str | bool | list[str]' ) -> 'SignHandler' Sign a message. This method delegates most of the work to the sign_file() method. Parameters: Name Type Description Default message str bytes The data to sign. kwargs dict Keyword arguments, which are passed to sign_file() : keyid (str): The key id of the signer. passphrase (str): The passphrase for the key. clearsign (bool): Whether to use clear signing. detach (bool): Whether to produce a detached signature. binary (bool): Whether to produce a binary signature. output (str): The path to write a detached signature to. * extra_args (list[str]): Additional arguments to pass to gpg . None View Source def sign ( self , message : bytes , ** kwargs : str | bool | list [ str ] ) -> SignHandler : \"\"\" Sign a message. This method delegates most of the work to the `sign_file()` method. Args: message (str|bytes): The data to sign. kwargs (dict): Keyword arguments, which are passed to `sign_file()`: * keyid (str): The key id of the signer. * passphrase (str): The passphrase for the key. * clearsign (bool): Whether to use clear signing. * detach (bool): Whether to produce a detached signature. * binary (bool): Whether to produce a binary signature. * output (str): The path to write a detached signature to. * extra_args (list[str]): Additional arguments to pass to `gpg`. \"\"\" f = _make_binary_stream ( message , self . encoding ) result = self . sign_file ( f , ** kwargs ) f . close () return result","title":"sign"},{"location":"reference/gnupg/#sign_file","text":"def sign_file ( self , fileobj_or_path : 'BufferedReader | BytesIO | str' , * , keyid : 'str | None' = None , passphrase : 'str | None' = None , clearsign : 'bool' = True , detach : 'bool' = False , binary : 'bool' = False , output : 'str | None' = None , extra_args : 'None' = None ) -> 'SignHandler' Sign data in a file or file-like object. Parameters: Name Type Description Default fileobj_or_path str file The file or file-like object to sign. keyid str The key id of the signer. None passphrase str The passphrase for the key. None clearsign bool Whether to use clear signing. None detach bool Whether to produce a detached signature. None binary bool Whether to produce a binary signature. None output str The path to write a detached signature to. None extra_args list[str] Additional arguments to pass to gpg . None View Source def sign_file ( # noqa: PLR0913 self , fileobj_or_path : BufferedReader | BytesIO | str , * , keyid : str | None = None , passphrase : str | None = None , clearsign : bool = True , detach : bool = False , binary : bool = False , output : str | None = None , extra_args : None = None , ) -> SignHandler : \" \"\" Sign data in a file or file-like object. Args: fileobj_or_path (str|file): The file or file-like object to sign. keyid (str): The key id of the signer. passphrase (str): The passphrase for the key. clearsign (bool): Whether to use clear signing. detach (bool): Whether to produce a detached signature. binary (bool): Whether to produce a binary signature. output (str): The path to write a detached signature to. extra_args (list[str]): Additional arguments to pass to `gpg`. \"\" \" if passphrase and not self . is_valid_passphrase ( passphrase ) : msg = \"Invalid passphrase\" raise ValueError ( msg ) logger . debug ( \"sign_file: %s\" , fileobj_or_path ) args = [ \"-s\" ] if binary else [ \"-sa\" ] # You can't specify detach-sign and clearsign together: gpg ignores # the detach-sign in that case. if detach : args . append ( \"--detach-sign\" ) elif clearsign : args . append ( \"--clearsign\" ) if keyid : args . extend ( [ \"--default-key\" , keyid ] ) if output : # pragma: no cover # write the output to a file with the specified name self . set _output_without_confirmation ( args , output ) if extra_args : # pragma: no cover args . extend ( extra_args ) result = self . result_map [ \"sign\" ] ( self ) # We could use _handle_io here except for the fact that if the # passphrase is bad, gpg bails and you can't write the message. fileobj = self . _get_fileobj ( fileobj_or_path ) p = self . _open_subprocess ( args , passphrase = passphrase is not None ) try : stdin = p . stdin if passphrase : _write_passphrase ( stdin , passphrase , self . encoding ) writer = _threaded_copy_data ( fileobj , stdin , self . buffer_size ) except OSError : # pragma: no cover logging . exception ( \"error writing message\" ) writer = None finally : if writer : writer . join ( 0.01 ) if fileobj is not fileobj_or_path : fileobj . close () self . _collect_output ( p , result , writer , stdin ) return result","title":"sign_file"},{"location":"reference/gnupg/#trust_keys","text":"def trust_keys ( self , fingerprints : 'str | list[str]' , trustlevel : 'str' ) -> 'StatusHandler' Set the trust level for one or more keys. Parameters: Name Type Description Default fingerprints str list[str] A key id for which to set the trust level, or a list of such key ids. trustlevel str The trust level. This is one of the following. 'TRUST_EXPIRED' 'TRUST_UNDEFINED' 'TRUST_NEVER' 'TRUST_MARGINAL' 'TRUST_FULLY' 'TRUST_ULTIMATE' None View Source def trust_keys ( self , fingerprints : str | list [ str ] , trustlevel : str ) -> StatusHandler : \"\"\" Set the trust level for one or more keys. Args: fingerprints (str|list[str]): A key id for which to set the trust level, or a list of such key ids. trustlevel (str): The trust level. This is one of the following. * ``'TRUST_EXPIRED'`` * ``'TRUST_UNDEFINED'`` * ``'TRUST_NEVER'`` * ``'TRUST_MARGINAL'`` * ``'TRUST_FULLY'`` * ``'TRUST_ULTIMATE'`` \"\"\" levels = VerifyHandler . TRUST_LEVELS if trustlevel not in levels : poss = \", \" . join ( sorted ( levels )) msg = f 'Invalid trust level: \"{trustlevel}\" (must be one of {poss})' raise ValueError ( msg ) trustlevel = levels [ trustlevel ] + 1 import tempfile try : fd , fn = tempfile . mkstemp ( prefix = \"pygpg-\" ) if isinstance ( fingerprints , str ) : fingerprints = [ fingerprints ] lines = [ f\"{f}:{trustlevel}:\" for f in fingerprints ] # The trailing newline is required ! s = os . linesep . join ( lines ) + os . linesep logger . debug ( \"writing ownertrust info: %s\" , s ) os . write ( fd , s . encode ( self . encoding )) os . close ( fd ) result = self . result_map [ \"trust\" ] ( self ) p = self . _open_subprocess ( [ \"--import-ownertrust\", fn ] ) self . _collect_output ( p , result , stdin = p . stdin ) if p . returncode != 0 : raise ValueError ( \"gpg returned an error - return code %d\" % p . returncode ) finally : Path ( fn ). unlink () return result","title":"trust_keys"},{"location":"reference/gnupg/#verify","text":"def verify ( self , data : 'bytes' , ** kwargs : 'str | bool | list[str] | IO' ) -> 'VerifyHandler' Verify the signature on the contents of the string data . This method delegates most of the work to verify_file() . Parameters: Name Type Description Default data str bytes The data to verify. kwargs dict Keyword arguments, which are passed to verify_file() : * fileobj_or_path (str file): A path to a signature, or a file-like object containing one. data_filename (str): If the signature is a detached one, the path to the data that was signed. close_file (bool): If a file-like object is passed in, whether to close it. * extra_args (list[str]): Additional arguments to pass to gpg . View Source def verify ( self , data : bytes , ** kwargs : str | bool | list [ str ] | IO ) -> VerifyHandler : \"\"\" Verify the signature on the contents of the string *data*. This method delegates most of the work to `verify_file()`. Args: data (str|bytes): The data to verify. kwargs (dict): Keyword arguments, which are passed to `verify_file()`: * fileobj_or_path (str|file): A path to a signature, or a file-like object containing one. * data_filename (str): If the signature is a detached one, the path to the data that was signed. * close_file (bool): If a file-like object is passed in, whether to close it. * extra_args (list[str]): Additional arguments to pass to `gpg`. \"\"\" f = _make_binary_stream ( data , self . encoding ) result = self . verify_file ( f , ** kwargs ) f . close () return result","title":"verify"},{"location":"reference/gnupg/#verify_data","text":"def verify_data ( self , sig_filename : 'str' , data : 'bytes' , extra_args : 'None' = None ) -> 'VerifyHandler' Verify the signature in sig_filename against data in memory Parameters: Name Type Description Default sig_filename str The path to a signature. None data str bytes The data to be verified. extra_args list[str] Additional arguments to pass to gpg . None View Source def verify_data ( self , sig_filename : str , data : bytes , extra_args : None = None ) -> VerifyHandler : \" \"\" Verify the signature in sig_filename against data in memory Args: sig_filename (str): The path to a signature. data (str|bytes): The data to be verified. extra_args (list[str]): Additional arguments to pass to `gpg`. \"\" \" logger . debug ( \"verify_data: %r, %r ...\" , sig_filename , data [ : 16 ] ) result = self . result_map [ \"verify\" ] ( self ) args = [ \"--verify\" ] if extra_args : # pragma: no cover args . extend ( extra_args ) args . extend ( [ sig_filename , \"-\" ] ) stream = BytesIO ( data ) self . _handle_io ( args , stream , result , binary = True ) return result","title":"verify_data"},{"location":"reference/gnupg/#verify_file","text":"def verify_file ( self , fileobj_or_path : 'BytesIO | str' , * , data_filename : 'str | None' = None , close_file : 'bool' = True , extra_args : 'None' = None ) -> 'VerifyHandler' Verify a signature. Parameters: Name Type Description Default fileobj_or_path str file A path to a signature, or a file-like object containing one. data_filename str If the signature is a detached one, the path to the data that was signed. None close_file bool If a file-like object is passed in, whether to close it. None extra_args list[str] Additional arguments to pass to gpg . None View Source def verify_file ( self , fileobj_or_path : BytesIO | str , * , data_filename : str | None = None , close_file : bool = True , extra_args : None = None , ) -> VerifyHandler : \" \"\" Verify a signature. Args: fileobj_or_path (str|file): A path to a signature, or a file-like object containing one. data_filename (str): If the signature is a detached one, the path to the data that was signed. close_file (bool): If a file-like object is passed in, whether to close it. extra_args (list[str]): Additional arguments to pass to `gpg`. \"\" \" logger . debug ( \"verify_file: %r, %r\" , fileobj_or_path , data_filename ) result = self . result_map [ \"verify\" ] ( self ) args = [ \"--verify\" ] if extra_args : # pragma: no cover args . extend ( extra_args ) if data_filename is None : self . _handle_io ( args , fileobj_or_path , result , binary = True ) else : logger . debug ( \"Handling detached verification\" ) import tempfile fd , fn = tempfile . mkstemp ( prefix = \"pygpg-\" ) s = fileobj_or_path . read () if close_file : fileobj_or_path . close () logger . debug ( \"Wrote to temp file: %r\" , s ) os . write ( fd , s ) os . close ( fd ) args . append ( fn ) args . append ( data_filename ) try : p = self . _open_subprocess ( args ) self . _collect_output ( p , result , stdin = p . stdin ) finally : Path ( fn ). unlink () return result","title":"verify_file"},{"location":"reference/gnupg/gnupg/","text":"Module gnupg.gnupg View Source from __future__ import annotations import codecs import contextlib import logging import os import re import socket import threading from io import BufferedReader , BufferedWriter , BytesIO , TextIOWrapper from pathlib import Path from subprocess import PIPE , Popen from types import MappingProxyType from typing import IO , TYPE_CHECKING , Any , Callable from .handlers import ( AddSubkeyHandler , AutoLocateKeyHandler , CryptHandler , DeleteResultHandler , ExportResultHandler , GenKeyHandler , ImportResultHandler , ListKeysHandler , ScanKeysHandler , SearchKeysHandler , SendResultHandler , SignHandler , TrustResultHandler , VerifyHandler , ) from .helper import _get_logger , _is_sequence , _make_binary_stream , _threaded_copy_data , _write_passphrase if TYPE_CHECKING : from gnupg.handlers.status_handler import StatusHandler VERSION_RE = re . compile ( r \"^cfg:version:(\\d+(\\.\\d+)*)\" . encode ( \"ascii\" )) HEX_DIGITS_RE = re . compile ( r \"[0-9a-f]+$\" , re . IGNORECASE ) PUBLIC_KEY_RE = re . compile ( r \"gpg: public key is (\\w+)\" ) STARTUPINFO = None if os . name == \"nt\" : # pragma: no cover from subprocess import STARTF_USESHOWWINDOW , STARTUPINFO , SW_HIDE logger = _get_logger ( __name__ ) # See gh-196: Logging could show sensitive data. It also produces some voluminous # output. Hence, split into two tiers - stuff that's always logged, and stuff that's # only logged if log_everything is True. (This is set by the test script.) # # For now, only debug logging of chunks falls into the optionally-logged category. log_everything = False class GPG : \"\"\" This class provides a high-level programmatic interface for `gpg`. \"\"\" error_map = None decode_errors = \"strict\" buffer_size = 16384 # override in instance if needed result_map = MappingProxyType ( { \"crypt\" : CryptHandler , \"delete\" : DeleteResultHandler , \"generate\" : GenKeyHandler , \"addSubkey\" : AddSubkeyHandler , \"import\" : ImportResultHandler , \"send\" : SendResultHandler , \"list\" : ListKeysHandler , \"scan\" : ScanKeysHandler , \"search\" : SearchKeysHandler , \"sign\" : SignHandler , \"trust\" : TrustResultHandler , \"verify\" : VerifyHandler , \"export\" : ExportResultHandler , \"auto-locate-key\" : AutoLocateKeyHandler , }, ) \"A map of GPG operations to result object types.\" def __init__ ( # noqa: PLR0913 self , * , gpgbinary : str = \"gpg\" , gnupghome : str | None = None , verbose : bool = False , use_agent : bool = False , keyring : str | None = None , options : None = None , secret_keyring : None = None , env : None = None , ) -> None : \"\"\"Initialize a GPG process wrapper. Args: gpgbinary (str): A pathname for the GPG binary to use. gnupghome (str): A pathname to where we can find the public and private keyrings. The default is whatever `gpg` defaults to. keyring (str|list): The name of alternative keyring file to use, or a list of such keyring files. If specified, the default keyring is not used. options (list): A list of additional options to pass to the GPG binary. secret_keyring (str|list): The name of an alternative secret keyring file to use, or a list of such keyring files. env (dict): A dict of environment variables to be used for the GPG subprocess. \"\"\" self . gpgbinary = gpgbinary self . gnupghome = None if not gnupghome else Path ( gnupghome ) self . env = env # issue 112: fail if the specified value isn't a directory if self . gnupghome and not self . gnupghome . is_dir (): msg = f \"gnupghome should be a directory (it isn't): { self . gnupghome } \" raise ValueError ( msg ) # Allow passing a string or another iterable. Make it uniformly # a list of keyring filenames if keyring and isinstance ( keyring , str ): keyring = [ keyring ] self . keyring = keyring # Allow passing a string or another iterable. Make it uniformly # a list of keyring filenames if secret_keyring and isinstance ( secret_keyring , str ): # pragma: no cover secret_keyring = [ secret_keyring ] self . secret_keyring = secret_keyring self . verbose = verbose self . use_agent = use_agent if isinstance ( options , str ): # pragma: no cover options = [ options ] self . options = options self . on_data = None # or a callable - will be called with data chunks # Changed in 0.3.7 to use Latin-1 encoding rather than # locale.getpreferredencoding falling back to sys.stdin.encoding # falling back to utf-8, because gpg itself uses latin-1 as the default # encoding. self . encoding = \"latin-1\" if self . gnupghome and not self . gnupghome . is_dir (): # pragma: no cover self . gnupghome . mkdir ( mode = 0o700 , parents = True ) try : p = self . _open_subprocess ([ \"--list-config\" , \"--with-colons\" ]) except OSError : msg = f \"Unable to run gpg ( { self . gpgbinary } ) - it may not be available.\" logger . exception ( msg ) raise OSError ( msg ) from None result = self . result_map [ \"verify\" ]( self ) # any result will do for this self . _collect_output ( p , result , stdin = p . stdin ) if p . returncode != 0 : # pragma: no cover msg = f \"Error invoking gpg: { p . returncode } : { result . stderr } \" raise ValueError ( msg ) m = VERSION_RE . match ( result . data ) if not m : # pragma: no cover self . version = None else : dot = \".\" . encode ( \"ascii\" ) self . version = tuple ([ int ( s ) for s in m . groups ()[ 0 ] . split ( dot )]) # See issue #97. It seems gpg allow duplicate keys in keyrings, so we # can't be too strict. self . check_fingerprint_collisions = False def make_args ( self , args : list [ str ], * , passphrase : bool | None = False ) -> list [ str ]: \"\"\" Make a list of command line elements for GPG. The value of ``args`` will be appended. The ``passphrase`` argument needs to be True if a passphrase will be sent to `gpg`, else False. Args: args (list[str]): A list of arguments. passphrase (str): The passphrase to use. \"\"\" cmd = [ self . gpgbinary , \"--status-fd\" , \"2\" , \"--no-tty\" , \"--no-verbose\" ] if \"DEBUG_IPC\" in os . environ : # pragma: no cover cmd . extend ([ \"--debug\" , \"ipc\" ]) if passphrase and hasattr ( self , \"version\" ) and self . version >= ( 2 , 1 ): cmd [ 1 : 1 ] = [ \"--pinentry-mode\" , \"loopback\" ] cmd . extend ([ \"--fixed-list-mode\" , \"--batch\" , \"--with-colons\" ]) if self . gnupghome : cmd . extend ([ \"--homedir\" , str ( self . gnupghome )]) if self . keyring : cmd . append ( \"--no-default-keyring\" ) for fn in self . keyring : cmd . extend ([ \"--keyring\" , fn ]) if self . secret_keyring : # pragma: no cover for fn in self . secret_keyring : cmd . extend ([ \"--secret-keyring\" , fn ]) if passphrase : cmd . extend ([ \"--passphrase-fd\" , \"0\" ]) if self . use_agent : # pragma: no cover cmd . append ( \"--use-agent\" ) if self . options : cmd . extend ( self . options ) cmd . extend ( args ) return cmd def _open_subprocess ( self , args : list [ str ], * , passphrase : bool | None = False ) -> Popen : # Internal method: open a pipe to a GPG subprocess and return # the file objects for communicating with it. from subprocess import list2cmdline as debug_print cmd = self . make_args ( args , passphrase = passphrase ) if self . verbose : # pragma: no cover pass if not STARTUPINFO : si = None else : # pragma: no cover si = STARTUPINFO () si . dwFlags = STARTF_USESHOWWINDOW si . wShowWindow = SW_HIDE result = Popen ( # noqa: S603 cmd , shell = False , stdin = PIPE , stdout = PIPE , stderr = PIPE , startupinfo = si , env = self . env , ) logger . debug ( \" %s : %s \" , result . pid , debug_print ( cmd )) return result def _read_response ( self , stream : IO , result : StatusHandler ) -> None : # Internal method: reads all the stderr output from GPG, taking notice # only of lines that begin with the magic [GNUPG:] prefix. # # Calls methods on the response object for each valid token found, # with the arg being the remainder of the status line. lines = [] while True : line = stream . readline () if len ( line ) == 0 : break lines . append ( line ) line = line . rstrip () if self . verbose : # pragma: no cover pass logger . debug ( \" %s \" , line ) if line [ 0 : 9 ] == \"[GNUPG:] \" : # Chop off the prefix line = line [ 9 :] . split ( None , 1 ) keyword = line [ 0 ] value = line [ 1 ] if len ( line ) > 1 else \"\" result . handle_status ( keyword , value ) result . stderr = \"\" . join ( lines ) def _read_data ( self , stream : IO , result : StatusHandler , * , on_data : Callable [[ str | bytes ], Any ] | None = None , buffer_size : int = 1024 , ) -> None : # Read the contents of the file from GPG's stdout assert buffer_size > 0 # noqa: S101 chunks = [] while True : data = stream . read ( buffer_size ) if len ( data ) == 0 : if on_data : on_data ( data ) break if log_everything : msg = f \"chunk: { data [: 256 ] !r} \" logger . debug ( msg ) append = True if on_data : append = on_data ( data ) is not False if append : chunks . append ( data ) # Join using b'' or '', as appropriate result . data = type ( data )() . join ( chunks ) def _collect_output ( self , process : Popen , result : StatusHandler , writer : threading . Thread | None = None , stdin : BufferedWriter | None = None , ) -> int : \"\"\" Drain the subprocesses output streams, writing the collected output to the result. If a writer thread (writing to the subprocess) is given, make sure it's joined before returning. If a stdin stream is given, close it before returning. \"\"\" stderr = codecs . getreader ( self . encoding )( process . stderr ) rr = threading . Thread ( target = self . _read_response , args = ( stderr , result )) rr . daemon = True logger . debug ( \"stderr reader: %r \" , rr ) rr . start () stdout = process . stdout dr = threading . Thread ( target = self . _read_data , args = ( stdout , result ), kwargs = { \"on_data\" : self . on_data , \"buffer_size\" : self . buffer_size }, ) dr . daemon = True logger . debug ( \"stdout reader: %r \" , dr ) dr . start () dr . join () rr . join () if writer is not None : writer . join ( 0.01 ) process . wait () result . returncode = rc = process . returncode if rc != 0 : logger . warning ( \"gpg returned a non-zero error code: %d \" , rc ) if stdin is not None : with contextlib . suppress ( OSError ): stdin . close () stderr . close () stdout . close () return rc def is_valid_file ( self , fileobj : str | bytes | BufferedReader | TextIOWrapper | BytesIO ) -> bool : \"\"\" A simplistic check for a file-like object. Args: fileobj (object): The object to test. Returns: bool: ``True`` if it's a file-like object, else ``False``. \"\"\" return hasattr ( fileobj , \"read\" ) def _get_fileobj ( self , fileobj_or_path : str | bytes | BufferedReader | TextIOWrapper | BytesIO , ) -> BufferedReader | BytesIO | TextIOWrapper : if self . is_valid_file ( fileobj_or_path ): result = fileobj_or_path elif not isinstance ( fileobj_or_path , str ): msg = f \"Not a valid file or path: { fileobj_or_path } \" raise TypeError ( msg ) elif not Path ( fileobj_or_path ) . exists (): msg = f \"No such file: { fileobj_or_path } \" raise ValueError ( msg ) else : result = Path ( fileobj_or_path ) . open ( \"rb\" ) # noqa: SIM115 return result def _handle_io ( self , args : list [ str ], fileobj_or_path : str | bytes | BufferedReader | TextIOWrapper | BytesIO , result : StatusHandler , * , passphrase : str | None = None , binary : bool = False , ) -> StatusHandler : \"Handle a call to GPG - pass input data, collect output data\" # Handle a basic data call - pass data to GPG, handle the output # including status information. Garbage In, Garbage Out :) fileobj = self . _get_fileobj ( fileobj_or_path ) try : p = self . _open_subprocess ( args , passphrase = passphrase is not None ) stdin = p . stdin if binary else codecs . getwriter ( self . encoding )( p . stdin ) writer = None # See issue #237 if passphrase : _write_passphrase ( stdin , passphrase , self . encoding ) writer = _threaded_copy_data ( fileobj , stdin , self . buffer_size ) self . _collect_output ( p , result , writer , stdin ) return result finally : if writer : writer . join ( 0.01 ) if fileobj is not fileobj_or_path : fileobj . close () # # SIGNATURE METHODS # def sign ( self , message : bytes , ** kwargs : str | bool | list [ str ]) -> SignHandler : \"\"\" Sign a message. This method delegates most of the work to the `sign_file()` method. Args: message (str|bytes): The data to sign. kwargs (dict): Keyword arguments, which are passed to `sign_file()`: * keyid (str): The key id of the signer. * passphrase (str): The passphrase for the key. * clearsign (bool): Whether to use clear signing. * detach (bool): Whether to produce a detached signature. * binary (bool): Whether to produce a binary signature. * output (str): The path to write a detached signature to. * extra_args (list[str]): Additional arguments to pass to `gpg`. \"\"\" f = _make_binary_stream ( message , self . encoding ) result = self . sign_file ( f , ** kwargs ) f . close () return result def set_output_without_confirmation ( self , args : list [ str ], output : str ) -> None : \"\"\" If writing to a file which exists, avoid a confirmation message by updating the *args* value in place to set the output path and avoid any cpmfirmation prompt. Args: args (list[str]): A list of arguments. output (str): The path to the outpur file. \"\"\" if Path ( output ) . exists (): # We need to avoid an overwrite confirmation message args . extend ([ \"--yes\" ]) args . extend ([ \"--output\" , output ]) def is_valid_passphrase ( self , passphrase : str ) -> bool : \"\"\" Confirm that the passphrase doesn't contain newline-type characters - it is passed in a pipe to `gpg`, and so not checking could lead to spoofing attacks by passing arbitrary text after passphrase and newline. Args: passphrase (str): The passphrase to test. Returns: bool: ``True`` if it's a valid passphrase, else ``False``. \"\"\" return \" \\n \" not in passphrase and \" \\r \" not in passphrase and \" \\x00 \" not in passphrase def sign_file ( # noqa: PLR0913 self , fileobj_or_path : BufferedReader | BytesIO | str , * , keyid : str | None = None , passphrase : str | None = None , clearsign : bool = True , detach : bool = False , binary : bool = False , output : str | None = None , extra_args : None = None , ) -> SignHandler : \"\"\" Sign data in a file or file-like object. Args: fileobj_or_path (str|file): The file or file-like object to sign. keyid (str): The key id of the signer. passphrase (str): The passphrase for the key. clearsign (bool): Whether to use clear signing. detach (bool): Whether to produce a detached signature. binary (bool): Whether to produce a binary signature. output (str): The path to write a detached signature to. extra_args (list[str]): Additional arguments to pass to `gpg`. \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ): msg = \"Invalid passphrase\" raise ValueError ( msg ) logger . debug ( \"sign_file: %s \" , fileobj_or_path ) args = [ \"-s\" ] if binary else [ \"-sa\" ] # You can't specify detach-sign and clearsign together: gpg ignores # the detach-sign in that case. if detach : args . append ( \"--detach-sign\" ) elif clearsign : args . append ( \"--clearsign\" ) if keyid : args . extend ([ \"--default-key\" , keyid ]) if output : # pragma: no cover # write the output to a file with the specified name self . set_output_without_confirmation ( args , output ) if extra_args : # pragma: no cover args . extend ( extra_args ) result = self . result_map [ \"sign\" ]( self ) # We could use _handle_io here except for the fact that if the # passphrase is bad, gpg bails and you can't write the message. fileobj = self . _get_fileobj ( fileobj_or_path ) p = self . _open_subprocess ( args , passphrase = passphrase is not None ) try : stdin = p . stdin if passphrase : _write_passphrase ( stdin , passphrase , self . encoding ) writer = _threaded_copy_data ( fileobj , stdin , self . buffer_size ) except OSError : # pragma: no cover logging . exception ( \"error writing message\" ) writer = None finally : if writer : writer . join ( 0.01 ) if fileobj is not fileobj_or_path : fileobj . close () self . _collect_output ( p , result , writer , stdin ) return result def verify ( self , data : bytes , ** kwargs : str | bool | list [ str ] | IO ) -> VerifyHandler : \"\"\" Verify the signature on the contents of the string *data*. This method delegates most of the work to `verify_file()`. Args: data (str|bytes): The data to verify. kwargs (dict): Keyword arguments, which are passed to `verify_file()`: * fileobj_or_path (str|file): A path to a signature, or a file-like object containing one. * data_filename (str): If the signature is a detached one, the path to the data that was signed. * close_file (bool): If a file-like object is passed in, whether to close it. * extra_args (list[str]): Additional arguments to pass to `gpg`. \"\"\" f = _make_binary_stream ( data , self . encoding ) result = self . verify_file ( f , ** kwargs ) f . close () return result def verify_file ( self , fileobj_or_path : BytesIO | str , * , data_filename : str | None = None , close_file : bool = True , extra_args : None = None , ) -> VerifyHandler : \"\"\" Verify a signature. Args: fileobj_or_path (str|file): A path to a signature, or a file-like object containing one. data_filename (str): If the signature is a detached one, the path to the data that was signed. close_file (bool): If a file-like object is passed in, whether to close it. extra_args (list[str]): Additional arguments to pass to `gpg`. \"\"\" logger . debug ( \"verify_file: %r , %r \" , fileobj_or_path , data_filename ) result = self . result_map [ \"verify\" ]( self ) args = [ \"--verify\" ] if extra_args : # pragma: no cover args . extend ( extra_args ) if data_filename is None : self . _handle_io ( args , fileobj_or_path , result , binary = True ) else : logger . debug ( \"Handling detached verification\" ) import tempfile fd , fn = tempfile . mkstemp ( prefix = \"pygpg-\" ) s = fileobj_or_path . read () if close_file : fileobj_or_path . close () logger . debug ( \"Wrote to temp file: %r \" , s ) os . write ( fd , s ) os . close ( fd ) args . append ( fn ) args . append ( data_filename ) try : p = self . _open_subprocess ( args ) self . _collect_output ( p , result , stdin = p . stdin ) finally : Path ( fn ) . unlink () return result def verify_data ( self , sig_filename : str , data : bytes , extra_args : None = None ) -> VerifyHandler : \"\"\" Verify the signature in sig_filename against data in memory Args: sig_filename (str): The path to a signature. data (str|bytes): The data to be verified. extra_args (list[str]): Additional arguments to pass to `gpg`. \"\"\" logger . debug ( \"verify_data: %r , %r ...\" , sig_filename , data [: 16 ]) result = self . result_map [ \"verify\" ]( self ) args = [ \"--verify\" ] if extra_args : # pragma: no cover args . extend ( extra_args ) args . extend ([ sig_filename , \"-\" ]) stream = BytesIO ( data ) self . _handle_io ( args , stream , result , binary = True ) return result # # KEY MANAGEMENT # def import_keys ( self , key_data : str | bytes , extra_args : None = None , passphrase : None = None , ) -> ImportResultHandler : \"\"\" Import the key_data into our keyring. Args: key_data (str|bytes): The key data to import. passphrase (str): The passphrase to use. extra_args (list[str]): Additional arguments to pass to `gpg`. \"\"\" result = self . result_map [ \"import\" ]( self ) logger . debug ( \"import_keys: %r \" , key_data [: 256 ]) data = _make_binary_stream ( key_data , self . encoding ) args = [ \"--import\" ] if extra_args : # pragma: no cover args . extend ( extra_args ) self . _handle_io ( args , data , result , passphrase = passphrase , binary = True ) logger . debug ( \"import_keys result: %r \" , result . __dict__ ) data . close () return result def import_keys_file ( self , key_path : str , ** kwargs : str | list [ str ]) -> ImportResultHandler : \"\"\" Import the key data in key_path into our keyring. Args: key_path (str): A path to the key data to be imported. \"\"\" with Path ( key_path ) . open ( \"rb\" ) as f : return self . import_keys ( f . read (), ** kwargs ) def recv_keys ( self , keyserver : str , * keyids : str , ** kwargs : list [ str ]) -> ImportResultHandler : \"\"\" Import one or more keys from a keyserver. Args: keyserver (str): The key server hostname. keyids (str): A list of key ids to receive. \"\"\" result = self . result_map [ \"import\" ]( self ) logger . debug ( \"recv_keys: %r \" , keyids ) data = _make_binary_stream ( \"\" , self . encoding ) args = [ \"--keyserver\" , keyserver ] if \"extra_args\" in kwargs : # pragma: no cover args . extend ( kwargs [ \"extra_args\" ]) args . append ( \"--recv-keys\" ) args . extend ( list ( keyids )) self . _handle_io ( args , data , result , binary = True ) logger . debug ( \"recv_keys result: %r \" , result . __dict__ ) data . close () return result # This function isn't exercised by tests, to avoid polluting external # key servers with test keys def send_keys ( self , keyserver : str , * keyids : str , ** kwargs : list [ str ]) -> StatusHandler : # pragma: no cover \"\"\" Send one or more keys to a keyserver. Args: keyserver (str): The key server hostname. keyids (list[str]): A list of key ids to send. \"\"\" # Note: it's not practical to test this function without sending # arbitrary data to live keyservers. result = self . result_map [ \"send\" ]( self ) logger . debug ( \"send_keys: %r \" , keyids ) data = _make_binary_stream ( \"\" , self . encoding ) args = [ \"--keyserver\" , keyserver ] if \"extra_args\" in kwargs : args . extend ( kwargs [ \"extra_args\" ]) args . append ( \"--send-keys\" ) args . extend ( list ( keyids )) self . _handle_io ( args , data , result , binary = True ) logger . debug ( \"send_keys result: %r \" , result . __dict__ ) data . close () return result def delete_keys ( self , fingerprints : str , * , secret : bool = False , passphrase : str | None = None , expect_passphrase : bool = True , exclamation_mode : bool = False , ) -> DeleteResultHandler : \"\"\" Delete the indicated keys. Args: fingerprints (str|list[str]): The keys to delete. secret (bool): Whether to delete secret keys. passphrase (str): The passphrase to use. expect_passphrase (bool): Whether a passphrase is expected. exclamation_mode (bool): If specified, a `'!'` is appended to each fingerprint. This deletes only a subkey or an entire key, depending on what the fingerprint refers to. .. note:: Passphrases Since GnuPG 2.1, you can't delete secret keys without providing a passphrase. However, if you're expecting the passphrase to go to `gpg` via pinentry, you should specify expect_passphrase=False. (It's only checked for GnuPG >= 2.1). \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ): # pragma: no cover msg = \"Invalid passphrase\" raise ValueError ( msg ) which = \"key\" if secret : # pragma: no cover if self . version >= ( 2 , 1 ) and passphrase is None and expect_passphrase : msg = \"For GnuPG >= 2.1, deleting secret keys needs a passphrase to be provided\" raise ValueError ( msg ) which = \"secret-key\" fingerprints = list ( fingerprints ) if _is_sequence ( fingerprints ) else [ fingerprints ] if exclamation_mode : fingerprints = [ f + \"!\" for f in fingerprints ] args = [ f \"--delete- { which } \" ] if secret and self . version >= ( 2 , 1 ): args . insert ( 0 , \"--yes\" ) args . extend ( fingerprints ) result = self . result_map [ \"delete\" ]( self ) if not secret or self . version < ( 2 , 1 ): p = self . _open_subprocess ( args ) self . _collect_output ( p , result , stdin = p . stdin ) else : # Need to send in a passphrase. f = _make_binary_stream ( \"\" , self . encoding ) try : self . _handle_io ( args , f , result , passphrase = passphrase , binary = True ) finally : f . close () return result def export_keys ( # noqa: PLR0913 self , keyids : str | list [ str ], * , secret : bool = False , armor : bool = True , minimal : bool = False , passphrase : str | None = None , expect_passphrase : bool = True , output : None = None , ) -> str | bytes : \"\"\" Export the indicated keys. A 'keyid' is anything `gpg` accepts. Args: keyids (str|list[str]): A single keyid or a list of them. secret (bool): Whether to export secret keys. armor (bool): Whether to ASCII-armor the output. minimal (bool): Whether to pass `--export-options export-minimal` to `gpg`. passphrase (str): The passphrase to use. expect_passphrase (bool): Whether a passphrase is expected. output (str): If specified, the path to write the exported key(s) to. .. note:: Passphrases Since GnuPG 2.1, you can't export secret keys without providing a passphrase. However, if you're expecting the passphrase to go to `gpg` via pinentry, you should specify expect_passphrase=False. (It's only checked for GnuPG >= 2.1). \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ): # pragma: no cover msg = \"Invalid passphrase\" raise ValueError ( msg ) which = \"\" if secret : which = \"-secret-key\" if self . version >= ( 2 , 1 ) and passphrase is None and expect_passphrase : # pragma: no cover msg = \"For GnuPG >= 2.1, exporting secret keys needs a passphrase to be provided\" raise ValueError ( msg ) keyids = list ( keyids ) if _is_sequence ( keyids ) else [ keyids ] args = [ f \"--export { which } \" ] if armor : args . append ( \"--armor\" ) if minimal : # pragma: no cover args . extend ([ \"--export-options\" , \"export-minimal\" ]) if output : # pragma: no cover # write the output to a file with the specified name self . set_output_without_confirmation ( args , output ) args . extend ( keyids ) # gpg --export produces no status-fd output; stdout will be # empty in case of failure result = self . result_map [ \"export\" ]( self ) if not secret or self . version < ( 2 , 1 ): p = self . _open_subprocess ( args ) self . _collect_output ( p , result , stdin = p . stdin ) else : # Need to send in a passphrase. f = _make_binary_stream ( \"\" , self . encoding ) try : self . _handle_io ( args , f , result , passphrase = passphrase , binary = True ) finally : f . close () logger . debug ( \"export_keys result[:100]: %r \" , result . data [: 100 ]) # Issue #49: Return bytes if armor not specified, else text result = result . data if armor : result = result . decode ( self . encoding , self . decode_errors ) return result def _decode_result ( self , result : ListKeysHandler | ScanKeysHandler , ) -> ListKeysHandler | ScanKeysHandler : lines = result . data . decode ( self . encoding , self . decode_errors ) . splitlines () valid_keywords = \"pub uid sec fpr sub ssb sig grp\" . split () for line in lines : if self . verbose : # pragma: no cover pass logger . debug ( \"line: %r \" , line . rstrip ()) if not line : # pragma: no cover break fields = line . strip () . split ( \":\" ) if not fields : # pragma: no cover continue keyword = fields [ 0 ] if keyword in valid_keywords : getattr ( result , keyword )( fields ) return result def _get_list_output ( self , p : Popen , kind : str ) -> ListKeysHandler | ScanKeysHandler : # Get the response information result = self . result_map [ kind ]( self ) self . _collect_output ( p , result , stdin = p . stdin ) return self . _decode_result ( result ) def list_keys ( self , * , secret : bool = False , keys : str | list [ str ] | None = None , sigs : bool = False , ) -> ListKeysHandler : \"\"\" List the keys currently in the keyring. Args: secret (bool): Whether to list secret keys. keys (str|list[str]): A list of key ids to match. sigs (bool): Whether to include signature information. Returns: list[dict]: A list of dictionaries with key information. \"\"\" which = \"secret-keys\" if secret else \"sigs\" if sigs else \"keys\" args = [ f \"--list- { which } \" , \"--fingerprint\" , \"--fingerprint\" ] # get subkey FPs, too if self . version >= ( 2 , 1 ): args . append ( \"--with-keygrip\" ) if keys : if isinstance ( keys , str ): keys = [ keys ] args . extend ( keys ) p = self . _open_subprocess ( args ) return self . _get_list_output ( p , \"list\" ) def scan_keys ( self , filename : str ) -> ScanKeysHandler : \"\"\" List details of an ascii armored or binary key file without first importing it to the local keyring. Args: filename (str): The path to the file containing the key(s). .. warning:: Warning: Care is needed. The function works on modern GnuPG by running: $ gpg --dry-run --import-options import-show --import filename On older versions, it does the *much* riskier: $ gpg --with-fingerprint --with-colons filename \"\"\" if self . version >= ( 2 , 1 ): args = [ \"--dry-run\" , \"--import-options\" , \"import-show\" , \"--import\" ] else : logger . warning ( \"Trying to list packets, but if the file is not a keyring, might accidentally decrypt\" ) args = [ \"--with-fingerprint\" , \"--with-colons\" , \"--fixed-list-mode\" ] args . append ( filename ) p = self . _open_subprocess ( args ) return self . _get_list_output ( p , \"scan\" ) def scan_keys_mem ( self , key_data : str ) -> ScanKeysHandler : \"\"\" List details of an ascii armored or binary key without first importing it to the local keyring. Args: key_data (str|bytes): The key data to import. .. warning:: Warning: Care is needed. The function works on modern GnuPG by running: $ gpg --dry-run --import-options import-show --import filename On older versions, it does the *much* riskier: $ gpg --with-fingerprint --with-colons filename \"\"\" result = self . result_map [ \"scan\" ]( self ) logger . debug ( \"scan_keys: %r \" , key_data [: 256 ]) data = _make_binary_stream ( key_data , self . encoding ) if self . version >= ( 2 , 1 ): args = [ \"--dry-run\" , \"--import-options\" , \"import-show\" , \"--import\" ] else : logger . warning ( \"Trying to list packets, but if the file is not a keyring, might accidentally decrypt\" ) args = [ \"--with-fingerprint\" , \"--with-colons\" , \"--fixed-list-mode\" ] self . _handle_io ( args , data , result , binary = True ) logger . debug ( \"scan_keys result: %r \" , result . __dict__ ) data . close () return self . _decode_result ( result ) def search_keys ( self , query : str , keyserver : str = \"pgp.mit.edu\" , extra_args : list [ str ] | None = None , ) -> StatusHandler : \"\"\" search a keyserver by query (using the `--search-keys` option). Args: query(str): The query to use. keyserver (str): The key server hostname. extra_args (list[str]): Additional arguments to pass to `gpg`. \"\"\" query = query . strip () if HEX_DIGITS_RE . match ( query ): query = \"0x\" + query args = [ \"--fingerprint\" , \"--keyserver\" , keyserver ] if extra_args : # pragma: no cover args . extend ( extra_args ) args . extend ([ \"--search-keys\" , query ]) p = self . _open_subprocess ( args ) # Get the response information result = self . result_map [ \"search\" ]( self ) self . _collect_output ( p , result , stdin = p . stdin ) lines = result . data . decode ( self . encoding , self . decode_errors ) . splitlines () valid_keywords = [ \"pub\" , \"uid\" ] for line in lines : if self . verbose : # pragma: no cover pass logger . debug ( \"line: %r \" , line . rstrip ()) if not line : # sometimes get blank lines on Windows continue fields = line . strip () . split ( \":\" ) if not fields : # pragma: no cover continue keyword = fields [ 0 ] if keyword in valid_keywords : getattr ( result , keyword )( fields ) return result def auto_locate_key ( self , email : str , mechanisms : list [ str ] | None = None , ** kwargs : list [ str ]) -> StatusHandler : \"\"\" Auto locate a public key by `email`. Args: email (str): The email address to search for. mechanisms (list[str]): A list of mechanisms to use. Valid mechanisms can be found here https://www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration-Options.html under \"--auto-key-locate\". Default: ['wkd', 'ntds', 'ldap', 'cert', 'dane', 'local'] \"\"\" mechanisms = mechanisms or [ \"wkd\" , \"ntds\" , \"ldap\" , \"cert\" , \"dane\" , \"local\" ] args = [ \"--auto-key-locate\" , \",\" . join ( mechanisms ), \"--locate-keys\" , email ] result = self . result_map [ \"auto-locate-key\" ]( self ) if \"extra_args\" in kwargs : args . extend ( kwargs [ \"extra_args\" ]) process = self . _open_subprocess ( args ) self . _collect_output ( process , result , stdin = process . stdin ) self . _decode_result ( result ) return result def gen_key ( self , key_input : str ) -> GenKeyHandler : \"\"\" Generate a key; you might use `gen_key_input()` to create the input. Args: key_input (str): The input to the key creation operation. \"\"\" args = [ \"--gen-key\" ] result = self . result_map [ \"generate\" ]( self ) f = _make_binary_stream ( key_input , self . encoding ) self . _handle_io ( args , f , result , binary = True ) f . close () return result def gen_key_input ( self , ** kwargs : bool | str | int ) -> str : \"\"\" Generate `--gen-key` input (see `gpg` documentation in DETAILS). Args: kwargs (dict): A list of keyword arguments. Returns: str: A string suitable for passing to the `gen_key()` method. \"\"\" parms = {} no_protection = kwargs . pop ( \"no_protection\" , False ) for key , val in [ item for item in kwargs . items () if str ( item [ 1 ]) . strip ()]: parms [ key . replace ( \"_\" , \"-\" ) . title ()] = val parms . setdefault ( \"Key-Type\" , \"RSA\" ) if \"key_curve\" not in kwargs : parms . setdefault ( \"Key-Length\" , 2048 ) parms . setdefault ( \"Name-Real\" , \"Autogenerated Key\" ) logname = os . environ . get ( \"LOGNAME\" ) or os . environ . get ( \"USERNAME\" ) or \"unspecified\" hostname = socket . gethostname () parms . setdefault ( \"Name-Email\" , \" {} @ {} \" . format ( logname . replace ( \" \" , \"_\" ), hostname )) out = \"Key-Type: {} \\n \" . format ( parms . pop ( \"Key-Type\" )) for key , val in list ( parms . items ()): out += f \" { key } : { val } \\n \" if no_protection : # pragma: no cover out += \"%no-protection \\n \" out += \" %c ommit \\n \" return out \"\"\" Key-Type: RSA Key-Length: 1024 Name-Real: ISdlink Server on %s Name-Comment: Created by %s Name-Email: isdlink@ %s Expire-Date: 0 %c ommit Key-Type: DSA Key-Length: 1024 Subkey-Type: ELG-E Subkey-Length: 1024 Name-Real: Joe Tester Name-Comment: with stupid passphrase Name-Email: joe@foo.bar Expire-Date: 0 Passphrase: abc %pubring foo.pub %s ecring foo.sec %c ommit \"\"\" return None def add_subkey ( self , master_key : str , master_passphrase : str | None = None , algorithm : str = \"rsa\" , usage : str = \"encrypt\" , expire : int = \"-\" , ) -> AddSubkeyHandler : \"\"\" Add subkeys to a master key, Args: master_key (str): The master key. master_passphrase (str): The passphrase for the master key. algorithm (str): The key algorithm to use. usage (str): The desired uses for the subkey. expire (str): The expiration date of the subkey. \"\"\" if self . version [ 0 ] < 2 : # noqa: PLR2004 msg = \"Not available in GnuPG 1.x\" raise NotImplementedError ( msg ) if not master_key : # pragma: no cover msg = \"No master key fingerprint specified\" raise ValueError ( msg ) if master_passphrase and not self . is_valid_passphrase ( master_passphrase ): # pragma: no cover msg = \"Invalid passphrase\" raise ValueError ( msg ) args = [ \"--quick-add-key\" , master_key , algorithm , usage , str ( expire )] result = self . result_map [ \"addSubkey\" ]( self ) f = _make_binary_stream ( \"\" , self . encoding ) self . _handle_io ( args , f , result , passphrase = master_passphrase , binary = True ) return result # # ENCRYPTION # def encrypt_file ( # noqa: PLR0913 self , fileobj_or_path : BytesIO | str , recipients : str | list [ str ] | tuple [ str , str ] | None , * , sign : str | None = None , always_trust : bool = False , passphrase : str | None = None , armor : bool = True , output : str | None = None , symmetric : bool | str = False , extra_args : list [ str ] | None = None , ) -> CryptHandler : \"\"\" Encrypt data in a file or file-like object. Args: fileobj_or_path (str|file): A path to a file or a file-like object containing the data to be encrypted. recipients (str|list): A key id of a recipient of the encrypted data, or a list of such key ids. sign (str): If specified, the key id of a signer to sign the encrypted data. always_trust (bool): Whether to always trust keys. passphrase (str): The passphrase to use for a signature. armor (bool): Whether to ASCII-armor the output. output (str): A path to write the encrypted output to. symmetric (bool): Whether to use symmetric encryption, extra_args (list[str]): A list of additional arguments to pass to `gpg`. \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ): msg = \"Invalid passphrase\" raise ValueError ( msg ) args = [ \"--encrypt\" ] if symmetric : # can't be False or None - could be True or a cipher algo value # such as AES256 args = [ \"--symmetric\" ] if symmetric is not True : args . extend ([ \"--cipher-algo\" , symmetric ]) # else use the default, currently CAST5 else : if not recipients : msg = \"No recipients specified with asymmetric encryption\" raise ValueError ( msg ) if not _is_sequence ( recipients ): recipients = ( recipients ,) for recipient in recipients : args . extend ([ \"--recipient\" , recipient ]) if armor : # create ascii-armored output - False for binary output args . append ( \"--armor\" ) if output : # pragma: no cover # write the output to a file with the specified name self . set_output_without_confirmation ( args , output ) if sign is True : # pragma: no cover args . append ( \"--sign\" ) elif sign : # pragma: no cover args . extend ([ \"--sign\" , \"--default-key\" , sign ]) if always_trust : # pragma: no cover args . extend ([ \"--trust-model\" , \"always\" ]) if extra_args : # pragma: no cover args . extend ( extra_args ) result = self . result_map [ \"crypt\" ]( self ) self . _handle_io ( args , fileobj_or_path , result , passphrase = passphrase , binary = True ) logger . debug ( \"encrypt result[:100]: %r \" , result . data [: 100 ]) return result def encrypt ( self , data : str | bytes , recipients : str | list [ str ] | tuple [ str , str ] | None , ** kwargs : str | bool | list [ str ], ) -> CryptHandler : \"\"\" Encrypt the message contained in the string *data* for *recipients*. This method delegates most of the work to `encrypt_file()`. Args: data (str|bytes): The data to encrypt. recipients (str|list[str]): A key id of a recipient of the encrypted data, or a list of such key ids. kwargs (dict): Keyword arguments, which are passed to `encrypt_file()`: * sign (str): If specified, the key id of a signer to sign the encrypted data. * always_trust (bool): Whether to always trust keys. * passphrase (str): The passphrase to use for a signature. * armor (bool): Whether to ASCII-armor the output. * output (str): A path to write the encrypted output to. * symmetric (bool): Whether to use symmetric encryption, * extra_args (list[str]): A list of additional arguments to pass to `gpg`. \"\"\" data = _make_binary_stream ( data , self . encoding ) result = self . encrypt_file ( data , recipients , ** kwargs ) data . close () return result def decrypt ( self , message : str , ** kwargs : str | list [ str ]) -> CryptHandler : \"\"\" Decrypt the data in *message*. This method delegates most of the work to `decrypt_file()`. Args: message (str|bytes): The data to decrypt. A default key will be used for decryption. kwargs (dict): Keyword arguments, which are passed to `decrypt_file()`: * always_trust: Whether to always trust keys. * passphrase (str): The passphrase to use. * output (str): If specified, the path to write the decrypted data to. * extra_args (list[str]): A list of extra arguments to pass to `gpg`. \"\"\" data = _make_binary_stream ( message , self . encoding ) result = self . decrypt_file ( data , ** kwargs ) data . close () return result def decrypt_file ( self , fileobj_or_path : str | bytes | BufferedReader | TextIOWrapper | BytesIO , * , always_trust : bool = False , passphrase : str | None = None , output : str | None = None , extra_args : None = None , ) -> CryptHandler : \"\"\" Decrypt data in a file or file-like object. Args: fileobj_or_path (str|file): A path to a file or a file-like object containing the data to be decrypted. always_trust: Whether to always trust keys. passphrase (str): The passphrase to use. output (str): If specified, the path to write the decrypted data to. extra_args (list[str]): A list of extra arguments to pass to `gpg`. \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ): msg = \"Invalid passphrase\" raise ValueError ( msg ) args = [ \"--decrypt\" ] if output : # pragma: no cover # write the output to a file with the specified name self . set_output_without_confirmation ( args , output ) if always_trust : # pragma: no cover args . extend ([ \"--trust-model\" , \"always\" ]) if extra_args : # pragma: no cover args . extend ( extra_args ) result = self . result_map [ \"crypt\" ]( self ) self . _handle_io ( args , fileobj_or_path , result , passphrase = passphrase , binary = True ) logger . debug ( \"decrypt result[:100]: %r \" , result . data [: 100 ]) return result def get_recipients ( self , message : str , ** kwargs : list [ str ]) -> list [ str ]: \"\"\"Get the list of recipients for an encrypted message. This method delegates most of the work to `get_recipients_file()`. Args: message (str|bytes): The encrypted message. kwargs (dict): Keyword arguments, which are passed to `get_recipients_file()`: * extra_args (list[str]): A list of extra arguments to pass to `gpg`. \"\"\" data = _make_binary_stream ( message , self . encoding ) result = self . get_recipients_file ( data , ** kwargs ) data . close () return result def get_recipients_file ( self , fileobj_or_path : BytesIO | str , extra_args : list [ str ] | None = None ) -> list [ str ]: \"\"\" Get the list of recipients for an encrypted message in a file or file-like object. Args: fileobj_or_path (str|file): A path to a file or file-like object containing the encrypted data. extra_args (list[str]): A list of extra arguments to pass to `gpg`. \"\"\" args = [ \"--decrypt\" , \"--list-only\" , \"-v\" ] if extra_args : # pragma: no cover args . extend ( extra_args ) result = self . result_map [ \"crypt\" ]( self ) self . _handle_io ( args , fileobj_or_path , result , binary = True ) return [ m . group ( 1 ) for m in PUBLIC_KEY_RE . finditer ( result . stderr )] def trust_keys ( self , fingerprints : str | list [ str ], trustlevel : str ) -> StatusHandler : \"\"\" Set the trust level for one or more keys. Args: fingerprints (str|list[str]): A key id for which to set the trust level, or a list of such key ids. trustlevel (str): The trust level. This is one of the following. * ``'TRUST_EXPIRED'`` * ``'TRUST_UNDEFINED'`` * ``'TRUST_NEVER'`` * ``'TRUST_MARGINAL'`` * ``'TRUST_FULLY'`` * ``'TRUST_ULTIMATE'`` \"\"\" levels = VerifyHandler . TRUST_LEVELS if trustlevel not in levels : poss = \", \" . join ( sorted ( levels )) msg = f 'Invalid trust level: \" { trustlevel } \" (must be one of { poss } )' raise ValueError ( msg ) trustlevel = levels [ trustlevel ] + 1 import tempfile try : fd , fn = tempfile . mkstemp ( prefix = \"pygpg-\" ) if isinstance ( fingerprints , str ): fingerprints = [ fingerprints ] lines = [ f \" { f } : { trustlevel } :\" for f in fingerprints ] # The trailing newline is required! s = os . linesep . join ( lines ) + os . linesep logger . debug ( \"writing ownertrust info: %s \" , s ) os . write ( fd , s . encode ( self . encoding )) os . close ( fd ) result = self . result_map [ \"trust\" ]( self ) p = self . _open_subprocess ([ \"--import-ownertrust\" , fn ]) self . _collect_output ( p , result , stdin = p . stdin ) if p . returncode != 0 : raise ValueError ( \"gpg returned an error - return code %d \" % p . returncode ) finally : Path ( fn ) . unlink () return result Variables HEX_DIGITS_RE PIPE PUBLIC_KEY_RE STARTUPINFO TYPE_CHECKING VERSION_RE log_everything logger Classes GPG class GPG ( * , gpgbinary : 'str' = 'gpg' , gnupghome : 'str | None' = None , verbose : 'bool' = False , use_agent : 'bool' = False , keyring : 'str | None' = None , options : 'None' = None , secret_keyring : 'None' = None , env : 'None' = None ) This class provides a high-level programmatic interface for gpg . View Source class GPG : \"\"\" This class provides a high - level programmatic interface for ` gpg ` . \"\"\" error_map = None decode_errors = \"strict\" buffer_size = 16384 # override in instance if needed result_map = MappingProxyType ( { \"crypt\" : CryptHandler , \"delete\" : DeleteResultHandler , \"generate\" : GenKeyHandler , \"addSubkey\" : AddSubkeyHandler , \"import\" : ImportResultHandler , \"send\" : SendResultHandler , \"list\" : ListKeysHandler , \"scan\" : ScanKeysHandler , \"search\" : SearchKeysHandler , \"sign\" : SignHandler , \"trust\" : TrustResultHandler , \"verify\" : VerifyHandler , \"export\" : ExportResultHandler , \"auto-locate-key\" : AutoLocateKeyHandler , }, ) \"A map of GPG operations to result object types.\" def __init__ ( # noqa : PLR0913 self , * , gpgbinary : str = \"gpg\" , gnupghome : str | None = None , verbose : bool = False , use_agent : bool = False , keyring : str | None = None , options : None = None , secret_keyring : None = None , env : None = None , ) -> None : \"\"\"Initialize a GPG process wrapper. Args : gpgbinary ( str ) : A pathname for the GPG binary to use . gnupghome ( str ) : A pathname to where we can find the public and private keyrings . The default is whatever ` gpg ` defaults to . keyring ( str | list ) : The name of alternative keyring file to use , or a list of such keyring files . If specified , the default keyring is not used . options ( list ) : A list of additional options to pass to the GPG binary . secret_keyring ( str | list ) : The name of an alternative secret keyring file to use , or a list of such keyring files . env ( dict ) : A dict of environment variables to be used for the GPG subprocess . \"\"\" self . gpgbinary = gpgbinary self . gnupghome = None if not gnupghome else Path ( gnupghome ) self . env = env # issue 112: fail if the specified value isn't a directory if self . gnupghome and not self . gnupghome . is_dir () : msg = f \"gnupghome should be a directory (it isn't): {self.gnupghome}\" raise ValueError ( msg ) # Allow passing a string or another iterable. Make it uniformly # a list of keyring filenames if keyring and isinstance ( keyring , str ) : keyring = [ keyring ] self . keyring = keyring # Allow passing a string or another iterable. Make it uniformly # a list of keyring filenames if secret_keyring and isinstance ( secret_keyring , str ) : # pragma : no cover secret_keyring = [ secret_keyring ] self . secret_keyring = secret_keyring self . verbose = verbose self . use_agent = use_agent if isinstance ( options , str ) : # pragma : no cover options = [ options ] self . options = options self . on_data = None # or a callable - will be called with data chunks # Changed in 0.3.7 to use Latin-1 encoding rather than # locale.getpreferredencoding falling back to sys.stdin.encoding # falling back to utf-8, because gpg itself uses latin-1 as the default # encoding. self . encoding = \"latin-1\" if self . gnupghome and not self . gnupghome . is_dir () : # pragma : no cover self . gnupghome . mkdir ( mode = 0 o700 , parents = True ) try : p = self . _open_subprocess ([ \"--list-config\" , \"--with-colons\" ]) except OSError : msg = f \"Unable to run gpg ({self.gpgbinary}) - it may not be available.\" logger . exception ( msg ) raise OSError ( msg ) from None result = self . result_map [ \"verify\" ]( self ) # any result will do for this self . _collect_output ( p , result , stdin = p . stdin ) if p . returncode != 0 : # pragma : no cover msg = f \"Error invoking gpg: {p.returncode}: {result.stderr}\" raise ValueError ( msg ) m = VERSION_RE . match ( result . data ) if not m : # pragma : no cover self . version = None else : dot = \".\" . encode ( \"ascii\" ) self . version = tuple ([ int ( s ) for s in m . groups ()[ 0 ]. split ( dot )]) # See issue #97. It seems gpg allow duplicate keys in keyrings, so we # can't be too strict. self . check_fingerprint_collisions = False def make_args ( self , args : list [ str ], * , passphrase : bool | None = False ) -> list [ str ] : \"\"\" Make a list of command line elements for GPG . The value of `` args `` will be appended . The `` passphrase `` argument needs to be True if a passphrase will be sent to ` gpg ` , else False . Args : args ( list [ str ]) : A list of arguments . passphrase ( str ) : The passphrase to use . \"\"\" cmd = [ self . gpgbinary , \"--status-fd\" , \"2\" , \"--no-tty\" , \"--no-verbose\" ] if \"DEBUG_IPC\" in os . environ : # pragma : no cover cmd . extend ([ \"--debug\" , \"ipc\" ]) if passphrase and hasattr ( self , \"version\" ) and self . version >= ( 2 , 1 ) : cmd [ 1 : 1 ] = [ \"--pinentry-mode\" , \"loopback\" ] cmd . extend ([ \"--fixed-list-mode\" , \"--batch\" , \"--with-colons\" ]) if self . gnupghome : cmd . extend ([ \"--homedir\" , str ( self . gnupghome )]) if self . keyring : cmd . append ( \"--no-default-keyring\" ) for fn in self . keyring : cmd . extend ([ \"--keyring\" , fn ]) if self . secret_keyring : # pragma : no cover for fn in self . secret_keyring : cmd . extend ([ \"--secret-keyring\" , fn ]) if passphrase : cmd . extend ([ \"--passphrase-fd\" , \"0\" ]) if self . use_agent : # pragma : no cover cmd . append ( \"--use-agent\" ) if self . options : cmd . extend ( self . options ) cmd . extend ( args ) return cmd def _open_subprocess ( self , args : list [ str ], * , passphrase : bool | None = False ) -> Popen : # Internal method: open a pipe to a GPG subprocess and return # the file objects for communicating with it. from subprocess import list2cmdline as debug_print cmd = self . make_args ( args , passphrase = passphrase ) if self . verbose : # pragma : no cover pass if not STARTUPINFO : si = None else : # pragma : no cover si = STARTUPINFO () si . dwFlags = STARTF_USESHOWWINDOW si . wShowWindow = SW_HIDE result = Popen ( # noqa : S603 cmd , shell = False , stdin = PIPE , stdout = PIPE , stderr = PIPE , startupinfo = si , env = self . env , ) logger . debug ( \"%s: %s\" , result . pid , debug_print ( cmd )) return result def _read_response ( self , stream : IO , result : StatusHandler ) -> None : # Internal method: reads all the stderr output from GPG, taking notice # only of lines that begin with the magic [GNUPG:] prefix. # # Calls methods on the response object for each valid token found, # with the arg being the remainder of the status line. lines = [] while True : line = stream . readline () if len ( line ) == 0 : break lines . append ( line ) line = line . rstrip () if self . verbose : # pragma : no cover pass logger . debug ( \"%s\" , line ) if line [ 0 : 9 ] == \"[GNUPG:] \" : # Chop off the prefix line = line [ 9 : ]. split ( None , 1 ) keyword = line [ 0 ] value = line [ 1 ] if len ( line ) > 1 else \"\" result . handle_status ( keyword , value ) result . stderr = \"\" . join ( lines ) def _read_data ( self , stream : IO , result : StatusHandler , * , on_data : Callable [[ str | bytes ], Any ] | None = None , buffer_size : int = 1024 , ) -> None : # Read the contents of the file from GPG's stdout assert buffer_size > 0 # noqa : S101 chunks = [] while True : data = stream . read ( buffer_size ) if len ( data ) == 0 : if on_data : on_data ( data ) break if log_everything : msg = f \"chunk: {data[:256]!r}\" logger . debug ( msg ) append = True if on_data : append = on_data ( data ) is not False if append : chunks . append ( data ) # Join using b'' or '', as appropriate result . data = type ( data )(). join ( chunks ) def _collect_output ( self , process : Popen , result : StatusHandler , writer : threading . Thread | None = None , stdin : BufferedWriter | None = None , ) -> int : \"\"\" Drain the subprocesses output streams , writing the collected output to the result . If a writer thread ( writing to the subprocess ) is given , make sure it ' s joined before returning . If a stdin stream is given , close it before returning . \"\"\" stderr = codecs . getreader ( self . encoding )( process . stderr ) rr = threading . Thread ( target = self . _read_response , args = ( stderr , result )) rr . daemon = True logger . debug ( \"stderr reader: %r\" , rr ) rr . start () stdout = process . stdout dr = threading . Thread ( target = self . _read_data , args = ( stdout , result ), kwargs = { \"on_data\" : self . on_data , \"buffer_size\" : self . buffer_size }, ) dr . daemon = True logger . debug ( \"stdout reader: %r\" , dr ) dr . start () dr . join () rr . join () if writer is not None : writer . join ( 0.01 ) process . wait () result . returncode = rc = process . returncode if rc != 0 : logger . warning ( \"gpg returned a non-zero error code: %d\" , rc ) if stdin is not None : with contextlib . suppress ( OSError ) : stdin . close () stderr . close () stdout . close () return rc def is_valid_file ( self , fileobj : str | bytes | BufferedReader | TextIOWrapper | BytesIO ) -> bool : \"\"\" A simplistic check for a file - like object . Args : fileobj ( object ) : The object to test . Returns : bool : `` True `` if it ' s a file - like object , else `` False `` . \"\"\" return hasattr ( fileobj , \"read\" ) def _get_fileobj ( self , fileobj_or_path : str | bytes | BufferedReader | TextIOWrapper | BytesIO , ) -> BufferedReader | BytesIO | TextIOWrapper : if self . is_valid_file ( fileobj_or_path ) : result = fileobj_or_path elif not isinstance ( fileobj_or_path , str ) : msg = f \"Not a valid file or path: {fileobj_or_path}\" raise TypeError ( msg ) elif not Path ( fileobj_or_path ). exists () : msg = f \"No such file: {fileobj_or_path}\" raise ValueError ( msg ) else : result = Path ( fileobj_or_path ). open ( \"rb\" ) # noqa : SIM115 return result def _handle_io ( self , args : list [ str ], fileobj_or_path : str | bytes | BufferedReader | TextIOWrapper | BytesIO , result : StatusHandler , * , passphrase : str | None = None , binary : bool = False , ) -> StatusHandler : \"Handle a call to GPG - pass input data, collect output data\" # Handle a basic data call - pass data to GPG, handle the output # including status information. Garbage In, Garbage Out :) fileobj = self . _get_fileobj ( fileobj_or_path ) try : p = self . _open_subprocess ( args , passphrase = passphrase is not None ) stdin = p . stdin if binary else codecs . getwriter ( self . encoding )( p . stdin ) writer = None # See issue # 237 if passphrase : _write_passphrase ( stdin , passphrase , self . encoding ) writer = _threaded_copy_data ( fileobj , stdin , self . buffer_size ) self . _collect_output ( p , result , writer , stdin ) return result finally : if writer : writer . join ( 0.01 ) if fileobj is not fileobj_or_path : fileobj . close () # # SIGNATURE METHODS # def sign ( self , message : bytes , ** kwargs : str | bool | list [ str ]) -> SignHandler : \"\"\" Sign a message . This method delegates most of the work to the ` sign_file () ` method . Args : message ( str | bytes ) : The data to sign . kwargs ( dict ) : Keyword arguments , which are passed to ` sign_file () ` : * keyid ( str ) : The key id of the signer . * passphrase ( str ) : The passphrase for the key . * clearsign ( bool ) : Whether to use clear signing . * detach ( bool ) : Whether to produce a detached signature . * binary ( bool ) : Whether to produce a binary signature . * output ( str ) : The path to write a detached signature to . * extra_args ( list [ str ]) : Additional arguments to pass to ` gpg ` . \"\"\" f = _make_binary_stream ( message , self . encoding ) result = self . sign_file ( f , ** kwargs ) f . close () return result def set_output_without_confirmation ( self , args : list [ str ], output : str ) -> None : \"\"\" If writing to a file which exists , avoid a confirmation message by updating the * args * value in place to set the output path and avoid any cpmfirmation prompt . Args : args ( list [ str ]) : A list of arguments . output ( str ) : The path to the outpur file . \"\"\" if Path ( output ). exists () : # We need to avoid an overwrite confirmation message args . extend ([ \"--yes\" ]) args . extend ([ \"--output\" , output ]) def is_valid_passphrase ( self , passphrase : str ) -> bool : \"\"\" Confirm that the passphrase doesn ' t contain newline - type characters - it is passed in a pipe to ` gpg ` , and so not checking could lead to spoofing attacks by passing arbitrary text after passphrase and newline . Args : passphrase ( str ) : The passphrase to test . Returns : bool : `` True `` if it ' s a valid passphrase , else `` False `` . \"\"\" return \" \\n \" not in passphrase and \" \\r \" not in passphrase and \" \\x00 \" not in passphrase def sign_file ( # noqa : PLR0913 self , fileobj_or_path : BufferedReader | BytesIO | str , * , keyid : str | None = None , passphrase : str | None = None , clearsign : bool = True , detach : bool = False , binary : bool = False , output : str | None = None , extra_args : None = None , ) -> SignHandler : \"\"\" Sign data in a file or file - like object . Args : fileobj_or_path ( str | file ) : The file or file - like object to sign . keyid ( str ) : The key id of the signer . passphrase ( str ) : The passphrase for the key . clearsign ( bool ) : Whether to use clear signing . detach ( bool ) : Whether to produce a detached signature . binary ( bool ) : Whether to produce a binary signature . output ( str ) : The path to write a detached signature to . extra_args ( list [ str ]) : Additional arguments to pass to ` gpg ` . \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ) : msg = \"Invalid passphrase\" raise ValueError ( msg ) logger . debug ( \"sign_file: %s\" , fileobj_or_path ) args = [ \"-s\" ] if binary else [ \"-sa\" ] # You can't specify detach-sign and clearsign together: gpg ignores # the detach-sign in that case. if detach : args . append ( \"--detach-sign\" ) elif clearsign : args . append ( \"--clearsign\" ) if keyid : args . extend ([ \"--default-key\" , keyid ]) if output : # pragma : no cover # write the output to a file with the specified name self . set_output_without_confirmation ( args , output ) if extra_args : # pragma : no cover args . extend ( extra_args ) result = self . result_map [ \"sign\" ]( self ) # We could use _handle_io here except for the fact that if the # passphrase is bad, gpg bails and you can't write the message. fileobj = self . _get_fileobj ( fileobj_or_path ) p = self . _open_subprocess ( args , passphrase = passphrase is not None ) try : stdin = p . stdin if passphrase : _write_passphrase ( stdin , passphrase , self . encoding ) writer = _threaded_copy_data ( fileobj , stdin , self . buffer_size ) except OSError : # pragma : no cover logging . exception ( \"error writing message\" ) writer = None finally : if writer : writer . join ( 0.01 ) if fileobj is not fileobj_or_path : fileobj . close () self . _collect_output ( p , result , writer , stdin ) return result def verify ( self , data : bytes , ** kwargs : str | bool | list [ str ] | IO ) -> VerifyHandler : \"\"\" Verify the signature on the contents of the string * data * . This method delegates most of the work to ` verify_file () ` . Args : data ( str | bytes ) : The data to verify . kwargs ( dict ) : Keyword arguments , which are passed to ` verify_file () ` : * fileobj_or_path ( str | file ) : A path to a signature , or a file - like object containing one . * data_filename ( str ) : If the signature is a detached one , the path to the data that was signed . * close_file ( bool ) : If a file - like object is passed in , whether to close it . * extra_args ( list [ str ]) : Additional arguments to pass to ` gpg ` . \"\"\" f = _make_binary_stream ( data , self . encoding ) result = self . verify_file ( f , ** kwargs ) f . close () return result def verify_file ( self , fileobj_or_path : BytesIO | str , * , data_filename : str | None = None , close_file : bool = True , extra_args : None = None , ) -> VerifyHandler : \"\"\" Verify a signature . Args : fileobj_or_path ( str | file ) : A path to a signature , or a file - like object containing one . data_filename ( str ) : If the signature is a detached one , the path to the data that was signed . close_file ( bool ) : If a file - like object is passed in , whether to close it . extra_args ( list [ str ]) : Additional arguments to pass to ` gpg ` . \"\"\" logger . debug ( \"verify_file: %r, %r\" , fileobj_or_path , data_filename ) result = self . result_map [ \"verify\" ]( self ) args = [ \"--verify\" ] if extra_args : # pragma : no cover args . extend ( extra_args ) if data_filename is None : self . _handle_io ( args , fileobj_or_path , result , binary = True ) else : logger . debug ( \"Handling detached verification\" ) import tempfile fd , fn = tempfile . mkstemp ( prefix = \"pygpg-\" ) s = fileobj_or_path . read () if close_file : fileobj_or_path . close () logger . debug ( \"Wrote to temp file: %r\" , s ) os . write ( fd , s ) os . close ( fd ) args . append ( fn ) args . append ( data_filename ) try : p = self . _open_subprocess ( args ) self . _collect_output ( p , result , stdin = p . stdin ) finally : Path ( fn ). unlink () return result def verify_data ( self , sig_filename : str , data : bytes , extra_args : None = None ) -> VerifyHandler : \"\"\" Verify the signature in sig_filename against data in memory Args : sig_filename ( str ) : The path to a signature . data ( str | bytes ) : The data to be verified . extra_args ( list [ str ]) : Additional arguments to pass to ` gpg ` . \"\"\" logger . debug ( \"verify_data: %r, %r ...\" , sig_filename , data [ : 16 ]) result = self . result_map [ \"verify\" ]( self ) args = [ \"--verify\" ] if extra_args : # pragma : no cover args . extend ( extra_args ) args . extend ([ sig_filename , \"-\" ]) stream = BytesIO ( data ) self . _handle_io ( args , stream , result , binary = True ) return result # # KEY MANAGEMENT # def import_keys ( self , key_data : str | bytes , extra_args : None = None , passphrase : None = None , ) -> ImportResultHandler : \"\"\" Import the key_data into our keyring . Args : key_data ( str | bytes ) : The key data to import . passphrase ( str ) : The passphrase to use . extra_args ( list [ str ]) : Additional arguments to pass to ` gpg ` . \"\"\" result = self . result_map [ \"import\" ]( self ) logger . debug ( \"import_keys: %r\" , key_data [ : 256 ]) data = _make_binary_stream ( key_data , self . encoding ) args = [ \"--import\" ] if extra_args : # pragma : no cover args . extend ( extra_args ) self . _handle_io ( args , data , result , passphrase = passphrase , binary = True ) logger . debug ( \"import_keys result: %r\" , result . __dict__ ) data . close () return result def import_keys_file ( self , key_path : str , ** kwargs : str | list [ str ]) -> ImportResultHandler : \"\"\" Import the key data in key_path into our keyring . Args : key_path ( str ) : A path to the key data to be imported . \"\"\" with Path ( key_path ). open ( \"rb\" ) as f : return self . import_keys ( f . read (), ** kwargs ) def recv_keys ( self , keyserver : str , * keyids : str , ** kwargs : list [ str ]) -> ImportResultHandler : \"\"\" Import one or more keys from a keyserver . Args : keyserver ( str ) : The key server hostname . keyids ( str ) : A list of key ids to receive . \"\"\" result = self . result_map [ \"import\" ]( self ) logger . debug ( \"recv_keys: %r\" , keyids ) data = _make_binary_stream ( \"\" , self . encoding ) args = [ \"--keyserver\" , keyserver ] if \"extra_args\" in kwargs : # pragma : no cover args . extend ( kwargs [ \"extra_args\" ]) args . append ( \"--recv-keys\" ) args . extend ( list ( keyids )) self . _handle_io ( args , data , result , binary = True ) logger . debug ( \"recv_keys result: %r\" , result . __dict__ ) data . close () return result # This function isn't exercised by tests, to avoid polluting external # key servers with test keys def send_keys ( self , keyserver : str , * keyids : str , ** kwargs : list [ str ]) -> StatusHandler : # pragma : no cover \"\"\" Send one or more keys to a keyserver . Args : keyserver ( str ) : The key server hostname . keyids ( list [ str ]) : A list of key ids to send . \"\"\" # Note: it's not practical to test this function without sending # arbitrary data to live keyservers. result = self . result_map [ \"send\" ]( self ) logger . debug ( \"send_keys: %r\" , keyids ) data = _make_binary_stream ( \"\" , self . encoding ) args = [ \"--keyserver\" , keyserver ] if \"extra_args\" in kwargs : args . extend ( kwargs [ \"extra_args\" ]) args . append ( \"--send-keys\" ) args . extend ( list ( keyids )) self . _handle_io ( args , data , result , binary = True ) logger . debug ( \"send_keys result: %r\" , result . __dict__ ) data . close () return result def delete_keys ( self , fingerprints : str , * , secret : bool = False , passphrase : str | None = None , expect_passphrase : bool = True , exclamation_mode : bool = False , ) -> DeleteResultHandler : \"\"\" Delete the indicated keys . Args : fingerprints ( str | list [ str ]) : The keys to delete . secret ( bool ) : Whether to delete secret keys . passphrase ( str ) : The passphrase to use . expect_passphrase ( bool ) : Whether a passphrase is expected . exclamation_mode ( bool ) : If specified , a ` '!' ` is appended to each fingerprint . This deletes only a subkey or an entire key , depending on what the fingerprint refers to . .. note :: Passphrases Since GnuPG 2.1 , you can ' t delete secret keys without providing a passphrase . However , if you ' re expecting the passphrase to go to ` gpg ` via pinentry , you should specify expect_passphrase = False . ( It ' s only checked for GnuPG >= 2.1 ). \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ) : # pragma : no cover msg = \"Invalid passphrase\" raise ValueError ( msg ) which = \"key\" if secret : # pragma : no cover if self . version >= ( 2 , 1 ) and passphrase is None and expect_passphrase : msg = \"For GnuPG >= 2.1, deleting secret keys needs a passphrase to be provided\" raise ValueError ( msg ) which = \"secret-key\" fingerprints = list ( fingerprints ) if _is_sequence ( fingerprints ) else [ fingerprints ] if exclamation_mode : fingerprints = [ f + \"!\" for f in fingerprints ] args = [ f \"--delete-{which}\" ] if secret and self . version >= ( 2 , 1 ) : args . insert ( 0 , \"--yes\" ) args . extend ( fingerprints ) result = self . result_map [ \"delete\" ]( self ) if not secret or self . version < ( 2 , 1 ) : p = self . _open_subprocess ( args ) self . _collect_output ( p , result , stdin = p . stdin ) else : # Need to send in a passphrase. f = _make_binary_stream ( \"\" , self . encoding ) try : self . _handle_io ( args , f , result , passphrase = passphrase , binary = True ) finally : f . close () return result def export_keys ( # noqa : PLR0913 self , keyids : str | list [ str ], * , secret : bool = False , armor : bool = True , minimal : bool = False , passphrase : str | None = None , expect_passphrase : bool = True , output : None = None , ) -> str | bytes : \"\"\" Export the indicated keys . A ' keyid ' is anything ` gpg ` accepts . Args : keyids ( str | list [ str ]) : A single keyid or a list of them . secret ( bool ) : Whether to export secret keys . armor ( bool ) : Whether to ASCII - armor the output . minimal ( bool ) : Whether to pass ` -- export - options export - minimal ` to ` gpg ` . passphrase ( str ) : The passphrase to use . expect_passphrase ( bool ) : Whether a passphrase is expected . output ( str ) : If specified , the path to write the exported key ( s ) to . .. note :: Passphrases Since GnuPG 2.1 , you can ' t export secret keys without providing a passphrase . However , if you ' re expecting the passphrase to go to ` gpg ` via pinentry , you should specify expect_passphrase = False . ( It ' s only checked for GnuPG >= 2.1 ). \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ) : # pragma : no cover msg = \"Invalid passphrase\" raise ValueError ( msg ) which = \"\" if secret : which = \"-secret-key\" if self . version >= ( 2 , 1 ) and passphrase is None and expect_passphrase : # pragma : no cover msg = \"For GnuPG >= 2.1, exporting secret keys needs a passphrase to be provided\" raise ValueError ( msg ) keyids = list ( keyids ) if _is_sequence ( keyids ) else [ keyids ] args = [ f \"--export{which}\" ] if armor : args . append ( \"--armor\" ) if minimal : # pragma : no cover args . extend ([ \"--export-options\" , \"export-minimal\" ]) if output : # pragma : no cover # write the output to a file with the specified name self . set_output_without_confirmation ( args , output ) args . extend ( keyids ) # gpg --export produces no status-fd output; stdout will be # empty in case of failure result = self . result_map [ \"export\" ]( self ) if not secret or self . version < ( 2 , 1 ) : p = self . _open_subprocess ( args ) self . _collect_output ( p , result , stdin = p . stdin ) else : # Need to send in a passphrase. f = _make_binary_stream ( \"\" , self . encoding ) try : self . _handle_io ( args , f , result , passphrase = passphrase , binary = True ) finally : f . close () logger . debug ( \"export_keys result[:100]: %r\" , result . data [ : 100 ]) # Issue #49: Return bytes if armor not specified, else text result = result . data if armor : result = result . decode ( self . encoding , self . decode_errors ) return result def _decode_result ( self , result : ListKeysHandler | ScanKeysHandler , ) -> ListKeysHandler | ScanKeysHandler : lines = result . data . decode ( self . encoding , self . decode_errors ). splitlines () valid_keywords = \"pub uid sec fpr sub ssb sig grp\" . split () for line in lines : if self . verbose : # pragma : no cover pass logger . debug ( \"line: %r\" , line . rstrip ()) if not line : # pragma : no cover break fields = line . strip (). split ( \":\" ) if not fields : # pragma : no cover continue keyword = fields [ 0 ] if keyword in valid_keywords : getattr ( result , keyword )( fields ) return result def _get_list_output ( self , p : Popen , kind : str ) -> ListKeysHandler | ScanKeysHandler : # Get the response information result = self . result_map [ kind ]( self ) self . _collect_output ( p , result , stdin = p . stdin ) return self . _decode_result ( result ) def list_keys ( self , * , secret : bool = False , keys : str | list [ str ] | None = None , sigs : bool = False , ) -> ListKeysHandler : \"\"\" List the keys currently in the keyring . Args : secret ( bool ) : Whether to list secret keys . keys ( str | list [ str ]) : A list of key ids to match . sigs ( bool ) : Whether to include signature information . Returns : list [ dict ] : A list of dictionaries with key information . \"\"\" which = \"secret-keys\" if secret else \"sigs\" if sigs else \"keys\" args = [ f \"--list-{which}\" , \"--fingerprint\" , \"--fingerprint\" ] # get subkey FPs , too if self . version >= ( 2 , 1 ) : args . append ( \"--with-keygrip\" ) if keys : if isinstance ( keys , str ) : keys = [ keys ] args . extend ( keys ) p = self . _open_subprocess ( args ) return self . _get_list_output ( p , \"list\" ) def scan_keys ( self , filename : str ) -> ScanKeysHandler : \"\"\" List details of an ascii armored or binary key file without first importing it to the local keyring . Args : filename ( str ) : The path to the file containing the key ( s ). .. warning :: Warning : Care is needed . The function works on modern GnuPG by running : $ gpg -- dry - run -- import - options import - show -- import filename On older versions , it does the * much * riskier : $ gpg -- with - fingerprint -- with - colons filename \"\"\" if self . version >= ( 2 , 1 ) : args = [ \"--dry-run\" , \"--import-options\" , \"import-show\" , \"--import\" ] else : logger . warning ( \"Trying to list packets, but if the file is not a keyring, might accidentally decrypt\" ) args = [ \"--with-fingerprint\" , \"--with-colons\" , \"--fixed-list-mode\" ] args . append ( filename ) p = self . _open_subprocess ( args ) return self . _get_list_output ( p , \"scan\" ) def scan_keys_mem ( self , key_data : str ) -> ScanKeysHandler : \"\"\" List details of an ascii armored or binary key without first importing it to the local keyring . Args : key_data ( str | bytes ) : The key data to import . .. warning :: Warning : Care is needed . The function works on modern GnuPG by running : $ gpg -- dry - run -- import - options import - show -- import filename On older versions , it does the * much * riskier : $ gpg -- with - fingerprint -- with - colons filename \"\"\" result = self . result_map [ \"scan\" ]( self ) logger . debug ( \"scan_keys: %r\" , key_data [ : 256 ]) data = _make_binary_stream ( key_data , self . encoding ) if self . version >= ( 2 , 1 ) : args = [ \"--dry-run\" , \"--import-options\" , \"import-show\" , \"--import\" ] else : logger . warning ( \"Trying to list packets, but if the file is not a keyring, might accidentally decrypt\" ) args = [ \"--with-fingerprint\" , \"--with-colons\" , \"--fixed-list-mode\" ] self . _handle_io ( args , data , result , binary = True ) logger . debug ( \"scan_keys result: %r\" , result . __dict__ ) data . close () return self . _decode_result ( result ) def search_keys ( self , query : str , keyserver : str = \"pgp.mit.edu\" , extra_args : list [ str ] | None = None , ) -> StatusHandler : \"\"\" search a keyserver by query ( using the ` -- search - keys ` option ). Args : query ( str ) : The query to use . keyserver ( str ) : The key server hostname . extra_args ( list [ str ]) : Additional arguments to pass to ` gpg ` . \"\"\" query = query . strip () if HEX_DIGITS_RE . match ( query ) : query = \"0x\" + query args = [ \"--fingerprint\" , \"--keyserver\" , keyserver ] if extra_args : # pragma : no cover args . extend ( extra_args ) args . extend ([ \"--search-keys\" , query ]) p = self . _open_subprocess ( args ) # Get the response information result = self . result_map [ \"search\" ]( self ) self . _collect_output ( p , result , stdin = p . stdin ) lines = result . data . decode ( self . encoding , self . decode_errors ). splitlines () valid_keywords = [ \"pub\" , \"uid\" ] for line in lines : if self . verbose : # pragma : no cover pass logger . debug ( \"line: %r\" , line . rstrip ()) if not line : # sometimes get blank lines on Windows continue fields = line . strip (). split ( \":\" ) if not fields : # pragma : no cover continue keyword = fields [ 0 ] if keyword in valid_keywords : getattr ( result , keyword )( fields ) return result def auto_locate_key ( self , email : str , mechanisms : list [ str ] | None = None , ** kwargs : list [ str ]) -> StatusHandler : \"\"\" Auto locate a public key by ` email ` . Args : email ( str ) : The email address to search for . mechanisms ( list [ str ]) : A list of mechanisms to use . Valid mechanisms can be found here https : //www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration-Options.html under \"--auto-key-locate\" . Default : [ ' wkd ' , ' ntds ' , ' ldap ' , ' cert ' , ' dane ' , ' local ' ] \"\"\" mechanisms = mechanisms or [ \"wkd\" , \"ntds\" , \"ldap\" , \"cert\" , \"dane\" , \"local\" ] args = [ \"--auto-key-locate\" , \",\" . join ( mechanisms ), \"--locate-keys\" , email ] result = self . result_map [ \"auto-locate-key\" ]( self ) if \"extra_args\" in kwargs : args . extend ( kwargs [ \"extra_args\" ]) process = self . _open_subprocess ( args ) self . _collect_output ( process , result , stdin = process . stdin ) self . _decode_result ( result ) return result def gen_key ( self , key_input : str ) -> GenKeyHandler : \"\"\" Generate a key ; you might use ` gen_key_input () ` to create the input . Args : key_input ( str ) : The input to the key creation operation . \"\"\" args = [ \"--gen-key\" ] result = self . result_map [ \"generate\" ]( self ) f = _make_binary_stream ( key_input , self . encoding ) self . _handle_io ( args , f , result , binary = True ) f . close () return result def gen_key_input ( self , ** kwargs : bool | str | int ) -> str : \"\"\" Generate ` -- gen - key ` input ( see ` gpg ` documentation in DETAILS ). Args : kwargs ( dict ) : A list of keyword arguments . Returns : str : A string suitable for passing to the ` gen_key () ` method . \"\"\" parms = {} no_protection = kwargs . pop ( \"no_protection\" , False ) for key , val in [ item for item in kwargs . items () if str ( item [ 1 ]). strip ()] : parms [ key . replace ( \"_\" , \"-\" ). title ()] = val parms . setdefault ( \"Key-Type\" , \"RSA\" ) if \"key_curve\" not in kwargs : parms . setdefault ( \"Key-Length\" , 2048 ) parms . setdefault ( \"Name-Real\" , \"Autogenerated Key\" ) logname = os . environ . get ( \"LOGNAME\" ) or os . environ . get ( \"USERNAME\" ) or \"unspecified\" hostname = socket . gethostname () parms . setdefault ( \"Name-Email\" , \"{}@{}\" . format ( logname . replace ( \" \" , \"_\" ), hostname )) out = \"Key-Type: {} \\n \" . format ( parms . pop ( \"Key-Type\" )) for key , val in list ( parms . items ()) : out += f \"{key}: {val} \\n \" if no_protection : # pragma : no cover out += \"%no-protection \\n \" out += \"%commit \\n \" return out \"\"\" Key - Type : RSA Key - Length : 1024 Name - Real : ISdlink Server on %s Name - Comment : Created by %s Name - Email : isdlink @ %s Expire - Date : 0 %commit Key - Type : DSA Key - Length : 1024 Subkey - Type : ELG - E Subkey - Length : 1024 Name - Real : Joe Tester Name - Comment : with stupid passphrase Name - Email : joe @ foo . bar Expire - Date : 0 Passphrase : abc %pubring foo . pub %secring foo . sec %commit \"\"\" return None def add_subkey ( self , master_key : str , master_passphrase : str | None = None , algorithm : str = \"rsa\" , usage : str = \"encrypt\" , expire : int = \"-\" , ) -> AddSubkeyHandler : \"\"\" Add subkeys to a master key , Args : master_key ( str ) : The master key . master_passphrase ( str ) : The passphrase for the master key . algorithm ( str ) : The key algorithm to use . usage ( str ) : The desired uses for the subkey . expire ( str ) : The expiration date of the subkey . \"\"\" if self . version [ 0 ] < 2 : # noqa : PLR2004 msg = \"Not available in GnuPG 1.x\" raise NotImplementedError ( msg ) if not master_key : # pragma : no cover msg = \"No master key fingerprint specified\" raise ValueError ( msg ) if master_passphrase and not self . is_valid_passphrase ( master_passphrase ) : # pragma : no cover msg = \"Invalid passphrase\" raise ValueError ( msg ) args = [ \"--quick-add-key\" , master_key , algorithm , usage , str ( expire )] result = self . result_map [ \"addSubkey\" ]( self ) f = _make_binary_stream ( \"\" , self . encoding ) self . _handle_io ( args , f , result , passphrase = master_passphrase , binary = True ) return result # # ENCRYPTION # def encrypt_file ( # noqa : PLR0913 self , fileobj_or_path : BytesIO | str , recipients : str | list [ str ] | tuple [ str , str ] | None , * , sign : str | None = None , always_trust : bool = False , passphrase : str | None = None , armor : bool = True , output : str | None = None , symmetric : bool | str = False , extra_args : list [ str ] | None = None , ) -> CryptHandler : \"\"\" Encrypt data in a file or file - like object . Args : fileobj_or_path ( str | file ) : A path to a file or a file - like object containing the data to be encrypted . recipients ( str | list ) : A key id of a recipient of the encrypted data , or a list of such key ids . sign ( str ) : If specified , the key id of a signer to sign the encrypted data . always_trust ( bool ) : Whether to always trust keys . passphrase ( str ) : The passphrase to use for a signature . armor ( bool ) : Whether to ASCII - armor the output . output ( str ) : A path to write the encrypted output to . symmetric ( bool ) : Whether to use symmetric encryption , extra_args ( list [ str ]) : A list of additional arguments to pass to ` gpg ` . \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ) : msg = \"Invalid passphrase\" raise ValueError ( msg ) args = [ \"--encrypt\" ] if symmetric : # can't be False or None - could be True or a cipher algo value # such as AES256 args = [ \"--symmetric\" ] if symmetric is not True : args . extend ([ \"--cipher-algo\" , symmetric ]) # else use the default, currently CAST5 else : if not recipients : msg = \"No recipients specified with asymmetric encryption\" raise ValueError ( msg ) if not _is_sequence ( recipients ) : recipients = ( recipients ,) for recipient in recipients : args . extend ([ \"--recipient\" , recipient ]) if armor : # create ascii - armored output - False for binary output args . append ( \"--armor\" ) if output : # pragma : no cover # write the output to a file with the specified name self . set_output_without_confirmation ( args , output ) if sign is True : # pragma : no cover args . append ( \"--sign\" ) elif sign : # pragma : no cover args . extend ([ \"--sign\" , \"--default-key\" , sign ]) if always_trust : # pragma : no cover args . extend ([ \"--trust-model\" , \"always\" ]) if extra_args : # pragma : no cover args . extend ( extra_args ) result = self . result_map [ \"crypt\" ]( self ) self . _handle_io ( args , fileobj_or_path , result , passphrase = passphrase , binary = True ) logger . debug ( \"encrypt result[:100]: %r\" , result . data [ : 100 ]) return result def encrypt ( self , data : str | bytes , recipients : str | list [ str ] | tuple [ str , str ] | None , ** kwargs : str | bool | list [ str ], ) -> CryptHandler : \"\"\" Encrypt the message contained in the string * data * for * recipients * . This method delegates most of the work to ` encrypt_file () ` . Args : data ( str | bytes ) : The data to encrypt . recipients ( str | list [ str ]) : A key id of a recipient of the encrypted data , or a list of such key ids . kwargs ( dict ) : Keyword arguments , which are passed to ` encrypt_file () ` : * sign ( str ) : If specified , the key id of a signer to sign the encrypted data . * always_trust ( bool ) : Whether to always trust keys . * passphrase ( str ) : The passphrase to use for a signature . * armor ( bool ) : Whether to ASCII - armor the output . * output ( str ) : A path to write the encrypted output to . * symmetric ( bool ) : Whether to use symmetric encryption , * extra_args ( list [ str ]) : A list of additional arguments to pass to ` gpg ` . \"\"\" data = _make_binary_stream ( data , self . encoding ) result = self . encrypt_file ( data , recipients , ** kwargs ) data . close () return result def decrypt ( self , message : str , ** kwargs : str | list [ str ]) -> CryptHandler : \"\"\" Decrypt the data in * message * . This method delegates most of the work to ` decrypt_file () ` . Args : message ( str | bytes ) : The data to decrypt . A default key will be used for decryption . kwargs ( dict ) : Keyword arguments , which are passed to ` decrypt_file () ` : * always_trust : Whether to always trust keys . * passphrase ( str ) : The passphrase to use . * output ( str ) : If specified , the path to write the decrypted data to . * extra_args ( list [ str ]) : A list of extra arguments to pass to ` gpg ` . \"\"\" data = _make_binary_stream ( message , self . encoding ) result = self . decrypt_file ( data , ** kwargs ) data . close () return result def decrypt_file ( self , fileobj_or_path : str | bytes | BufferedReader | TextIOWrapper | BytesIO , * , always_trust : bool = False , passphrase : str | None = None , output : str | None = None , extra_args : None = None , ) -> CryptHandler : \"\"\" Decrypt data in a file or file - like object . Args : fileobj_or_path ( str | file ) : A path to a file or a file - like object containing the data to be decrypted . always_trust : Whether to always trust keys . passphrase ( str ) : The passphrase to use . output ( str ) : If specified , the path to write the decrypted data to . extra_args ( list [ str ]) : A list of extra arguments to pass to ` gpg ` . \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ) : msg = \"Invalid passphrase\" raise ValueError ( msg ) args = [ \"--decrypt\" ] if output : # pragma : no cover # write the output to a file with the specified name self . set_output_without_confirmation ( args , output ) if always_trust : # pragma : no cover args . extend ([ \"--trust-model\" , \"always\" ]) if extra_args : # pragma : no cover args . extend ( extra_args ) result = self . result_map [ \"crypt\" ]( self ) self . _handle_io ( args , fileobj_or_path , result , passphrase = passphrase , binary = True ) logger . debug ( \"decrypt result[:100]: %r\" , result . data [ : 100 ]) return result def get_recipients ( self , message : str , ** kwargs : list [ str ]) -> list [ str ] : \"\"\"Get the list of recipients for an encrypted message. This method delegates most of the work to ` get_recipients_file () ` . Args : message ( str | bytes ) : The encrypted message . kwargs ( dict ) : Keyword arguments , which are passed to ` get_recipients_file () ` : * extra_args ( list [ str ]) : A list of extra arguments to pass to ` gpg ` . \"\"\" data = _make_binary_stream ( message , self . encoding ) result = self . get_recipients_file ( data , ** kwargs ) data . close () return result def get_recipients_file ( self , fileobj_or_path : BytesIO | str , extra_args : list [ str ] | None = None ) -> list [ str ] : \"\"\" Get the list of recipients for an encrypted message in a file or file - like object . Args : fileobj_or_path ( str | file ) : A path to a file or file - like object containing the encrypted data . extra_args ( list [ str ]) : A list of extra arguments to pass to ` gpg ` . \"\"\" args = [ \"--decrypt\" , \"--list-only\" , \"-v\" ] if extra_args : # pragma : no cover args . extend ( extra_args ) result = self . result_map [ \"crypt\" ]( self ) self . _handle_io ( args , fileobj_or_path , result , binary = True ) return [ m . group ( 1 ) for m in PUBLIC_KEY_RE . finditer ( result . stderr )] def trust_keys ( self , fingerprints : str | list [ str ], trustlevel : str ) -> StatusHandler : \"\"\" Set the trust level for one or more keys . Args : fingerprints ( str | list [ str ]) : A key id for which to set the trust level , or a list of such key ids . trustlevel ( str ) : The trust level . This is one of the following . * ``' TRUST_EXPIRED '`` * ``' TRUST_UNDEFINED '`` * ``' TRUST_NEVER '`` * ``' TRUST_MARGINAL '`` * ``' TRUST_FULLY '`` * ``' TRUST_ULTIMATE '`` \"\"\" levels = VerifyHandler . TRUST_LEVELS if trustlevel not in levels : poss = \", \" . join ( sorted ( levels )) msg = f ' Invalid trust level : \"{trustlevel}\" ( must be one of { poss }) ' raise ValueError ( msg ) trustlevel = levels [ trustlevel ] + 1 import tempfile try : fd , fn = tempfile . mkstemp ( prefix = \"pygpg-\" ) if isinstance ( fingerprints , str ) : fingerprints = [ fingerprints ] lines = [ f \"{f}:{trustlevel}:\" for f in fingerprints ] # The trailing newline is required! s = os . linesep . join ( lines ) + os . linesep logger . debug ( \"writing ownertrust info: %s\" , s ) os . write ( fd , s . encode ( self . encoding )) os . close ( fd ) result = self . result_map [ \"trust\" ]( self ) p = self . _open_subprocess ([ \"--import-ownertrust\" , fn ]) self . _collect_output ( p , result , stdin = p . stdin ) if p . returncode != 0 : raise ValueError ( \"gpg returned an error - return code %d\" % p . returncode ) finally : Path ( fn ). unlink () return result Class variables buffer_size decode_errors error_map result_map A map of GPG operations to result object types. Methods add_subkey def add_subkey ( self , master_key : 'str' , master_passphrase : 'str | None' = None , algorithm : 'str' = 'rsa' , usage : 'str' = 'encrypt' , expire : 'int' = '-' ) -> 'AddSubkeyHandler' Add subkeys to a master key, Parameters: Name Type Description Default master_key str The master key. None master_passphrase str The passphrase for the master key. None algorithm str The key algorithm to use. None usage str The desired uses for the subkey. None expire str The expiration date of the subkey. None View Source def add_subkey ( self , master_key : str , master_passphrase : str | None = None , algorithm : str = \"rsa\" , usage : str = \"encrypt\" , expire : int = \"-\" , ) -> AddSubkeyHandler : \"\"\" Add subkeys to a master key, Args: master_key (str): The master key. master_passphrase (str): The passphrase for the master key. algorithm (str): The key algorithm to use. usage (str): The desired uses for the subkey. expire (str): The expiration date of the subkey. \"\"\" if self . version [ 0 ] < 2 : # noqa : PLR2004 msg = \"Not available in GnuPG 1.x\" raise NotImplementedError ( msg ) if not master_key : # pragma : no cover msg = \"No master key fingerprint specified\" raise ValueError ( msg ) if master_passphrase and not self . is_valid_passphrase ( master_passphrase ) : # pragma : no cover msg = \"Invalid passphrase\" raise ValueError ( msg ) args = [ \"--quick-add-key\" , master_key , algorithm , usage , str ( expire )] result = self . result_map [ \"addSubkey\" ]( self ) f = _make_binary_stream ( \"\" , self . encoding ) self . _handle_io ( args , f , result , passphrase = master_passphrase , binary = True ) return result auto_locate_key def auto_locate_key ( self , email : 'str' , mechanisms : 'list[str] | None' = None , ** kwargs : 'list[str]' ) -> 'StatusHandler' Auto locate a public key by email . Parameters: Name Type Description Default email str The email address to search for. None mechanisms list[str] A list of mechanisms to use. Valid mechanisms can be found None here https None //www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration-Options.html None under \"--auto-key-locate\". Default None ['wkd', 'ntds', 'ldap', 'cert', 'dane', 'local'] None View Source def auto_locate_key ( self , email : str , mechanisms : list [ str ] | None = None , ** kwargs : list [ str ] ) -> StatusHandler : \"\"\" Auto locate a public key by `email`. Args: email (str): The email address to search for. mechanisms (list[str]): A list of mechanisms to use. Valid mechanisms can be found here https://www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration-Options.html under \" -- auto - key - locate \". Default: ['wkd', 'ntds', 'ldap', 'cert', 'dane', 'local'] \"\"\" mechanisms = mechanisms or [ \"wkd\", \"ntds\", \"ldap\", \"cert\", \"dane\", \"local\" ] args = [ \"--auto-key-locate\", \",\".join(mechanisms), \"--locate-keys\", email ] result = self . result_map [ \"auto-locate-key\" ] ( self ) if \"extra_args\" in kwargs : args . extend ( kwargs [ \"extra_args\" ] ) process = self . _open_subprocess ( args ) self . _collect_output ( process , result , stdin = process . stdin ) self . _decode_result ( result ) return result decrypt def decrypt ( self , message : 'str' , ** kwargs : 'str | list[str]' ) -> 'CryptHandler' Decrypt the data in message . This method delegates most of the work to decrypt_file() . Parameters: Name Type Description Default message str bytes The data to decrypt. A default key will be used for decryption. kwargs dict Keyword arguments, which are passed to decrypt_file() : always_trust: Whether to always trust keys. passphrase (str): The passphrase to use. output (str): If specified, the path to write the decrypted data to. extra_args (list[str]): A list of extra arguments to pass to gpg . None View Source def decrypt ( self , message : str , ** kwargs : str | list [ str ] ) -> CryptHandler : \"\"\" Decrypt the data in *message*. This method delegates most of the work to `decrypt_file()`. Args: message (str|bytes): The data to decrypt. A default key will be used for decryption. kwargs (dict): Keyword arguments, which are passed to `decrypt_file()`: * always_trust: Whether to always trust keys. * passphrase (str): The passphrase to use. * output (str): If specified, the path to write the decrypted data to. * extra_args (list[str]): A list of extra arguments to pass to `gpg`. \"\"\" data = _make_binary_stream ( message , self . encoding ) result = self . decrypt_file ( data , ** kwargs ) data . close () return result decrypt_file def decrypt_file ( self , fileobj_or_path : 'str | bytes | BufferedReader | TextIOWrapper | BytesIO' , * , always_trust : 'bool' = False , passphrase : 'str | None' = None , output : 'str | None' = None , extra_args : 'None' = None ) -> 'CryptHandler' Decrypt data in a file or file-like object. Parameters: Name Type Description Default fileobj_or_path str file A path to a file or a file-like object containing the data to be decrypted. always_trust None Whether to always trust keys. None passphrase str The passphrase to use. None output str If specified, the path to write the decrypted data to. None extra_args list[str] A list of extra arguments to pass to gpg . None View Source def decrypt_file ( self , fileobj_or_path : str | bytes | BufferedReader | TextIOWrapper | BytesIO , * , always_trust : bool = False , passphrase : str | None = None , output : str | None = None , extra_args : None = None , ) -> CryptHandler : \" \"\" Decrypt data in a file or file-like object. Args: fileobj_or_path (str|file): A path to a file or a file-like object containing the data to be decrypted. always_trust: Whether to always trust keys. passphrase (str): The passphrase to use. output (str): If specified, the path to write the decrypted data to. extra_args (list[str]): A list of extra arguments to pass to `gpg`. \"\" \" if passphrase and not self . is_valid_passphrase ( passphrase ) : msg = \"Invalid passphrase\" raise ValueError ( msg ) args = [ \"--decrypt\" ] if output : # pragma: no cover # write the output to a file with the specified name self . set _output_without_confirmation ( args , output ) if always_trust : # pragma: no cover args . extend ( [ \"--trust-model\" , \"always\" ] ) if extra_args : # pragma: no cover args . extend ( extra_args ) result = self . result_map [ \"crypt\" ] ( self ) self . _handle_io ( args , fileobj_or_path , result , passphrase = passphrase , binary = True ) logger . debug ( \"decrypt result[:100]: %r\" , result . data [ : 100 ] ) return result delete_keys def delete_keys ( self , fingerprints : 'str' , * , secret : 'bool' = False , passphrase : 'str | None' = None , expect_passphrase : 'bool' = True , exclamation_mode : 'bool' = False ) -> 'DeleteResultHandler' Delete the indicated keys. Parameters: Name Type Description Default fingerprints str list[str] The keys to delete. secret bool Whether to delete secret keys. None passphrase str The passphrase to use. None expect_passphrase bool Whether a passphrase is expected. None exclamation_mode bool If specified, a '!' is appended to each fingerprint. This deletes only a subkey or an entire key, depending on what the fingerprint refers to. None View Source def delete_keys ( self , fingerprints : str , * , secret : bool = False , passphrase : str | None = None , expect_passphrase : bool = True , exclamation_mode : bool = False , ) -> DeleteResultHandler : \"\"\" Delete the indicated keys. Args: fingerprints (str|list[str]): The keys to delete. secret (bool): Whether to delete secret keys. passphrase (str): The passphrase to use. expect_passphrase (bool): Whether a passphrase is expected. exclamation_mode (bool): If specified, a `'!'` is appended to each fingerprint. This deletes only a subkey or an entire key, depending on what the fingerprint refers to. .. note:: Passphrases Since GnuPG 2.1, you can't delete secret keys without providing a passphrase. However, if you're expecting the passphrase to go to `gpg` via pinentry, you should specify expect_passphrase=False. (It's only checked for GnuPG >= 2.1). \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ) : # pragma : no cover msg = \"Invalid passphrase\" raise ValueError ( msg ) which = \"key\" if secret : # pragma : no cover if self . version >= ( 2 , 1 ) and passphrase is None and expect_passphrase : msg = \"For GnuPG >= 2.1, deleting secret keys needs a passphrase to be provided\" raise ValueError ( msg ) which = \"secret-key\" fingerprints = list ( fingerprints ) if _is_sequence ( fingerprints ) else [ fingerprints ] if exclamation_mode : fingerprints = [ f + \"!\" for f in fingerprints ] args = [ f\"--delete-{which}\" ] if secret and self . version >= ( 2 , 1 ) : args . insert ( 0 , \"--yes\" ) args . extend ( fingerprints ) result = self . result_map [ \"delete\" ] ( self ) if not secret or self . version < ( 2 , 1 ) : p = self . _open_subprocess ( args ) self . _collect_output ( p , result , stdin = p . stdin ) else : # Need to send in a passphrase . f = _make_binary_stream ( \"\" , self . encoding ) try : self . _handle_io ( args , f , result , passphrase = passphrase , binary = True ) finally : f . close () return result encrypt def encrypt ( self , data : 'str | bytes' , recipients : 'str | list[str] | tuple[str, str] | None' , ** kwargs : 'str | bool | list[str]' ) -> 'CryptHandler' Encrypt the message contained in the string data for recipients . This method delegates most of the work to encrypt_file() . Parameters: Name Type Description Default data str bytes The data to encrypt. recipients str list[str] A key id of a recipient of the encrypted data, or a list of such key ids. kwargs dict Keyword arguments, which are passed to encrypt_file() : sign (str): If specified, the key id of a signer to sign the encrypted data. always_trust (bool): Whether to always trust keys. passphrase (str): The passphrase to use for a signature. armor (bool): Whether to ASCII-armor the output. output (str): A path to write the encrypted output to. symmetric (bool): Whether to use symmetric encryption, * extra_args (list[str]): A list of additional arguments to pass to gpg . None View Source def encrypt ( self , data : str | bytes , recipients : str | list [ str ] | tuple [ str, str ] | None , ** kwargs : str | bool | list [ str ] , ) -> CryptHandler : \"\"\" Encrypt the message contained in the string *data* for *recipients*. This method delegates most of the work to `encrypt_file()`. Args: data (str|bytes): The data to encrypt. recipients (str|list[str]): A key id of a recipient of the encrypted data, or a list of such key ids. kwargs (dict): Keyword arguments, which are passed to `encrypt_file()`: * sign (str): If specified, the key id of a signer to sign the encrypted data. * always_trust (bool): Whether to always trust keys. * passphrase (str): The passphrase to use for a signature. * armor (bool): Whether to ASCII-armor the output. * output (str): A path to write the encrypted output to. * symmetric (bool): Whether to use symmetric encryption, * extra_args (list[str]): A list of additional arguments to pass to `gpg`. \"\"\" data = _make_binary_stream ( data , self . encoding ) result = self . encrypt_file ( data , recipients , ** kwargs ) data . close () return result encrypt_file def encrypt_file ( self , fileobj_or_path : 'BytesIO | str' , recipients : 'str | list[str] | tuple[str, str] | None' , * , sign : 'str | None' = None , always_trust : 'bool' = False , passphrase : 'str | None' = None , armor : 'bool' = True , output : 'str | None' = None , symmetric : 'bool | str' = False , extra_args : 'list[str] | None' = None ) -> 'CryptHandler' Encrypt data in a file or file-like object. Parameters: Name Type Description Default fileobj_or_path str file A path to a file or a file-like object containing the data to be encrypted. recipients str list A key id of a recipient of the encrypted data, or a list of such key ids. sign str If specified, the key id of a signer to sign the encrypted data. None always_trust bool Whether to always trust keys. None passphrase str The passphrase to use for a signature. None armor bool Whether to ASCII-armor the output. None output str A path to write the encrypted output to. None symmetric bool Whether to use symmetric encryption, None extra_args list[str] A list of additional arguments to pass to gpg . None View Source def encrypt_file ( # noqa : PLR0913 self , fileobj_or_path : BytesIO | str , recipients : str | list [ str ] | tuple [ str, str ] | None , * , sign : str | None = None , always_trust : bool = False , passphrase : str | None = None , armor : bool = True , output : str | None = None , symmetric : bool | str = False , extra_args : list [ str ] | None = None , ) -> CryptHandler : \"\"\" Encrypt data in a file or file-like object. Args: fileobj_or_path (str|file): A path to a file or a file-like object containing the data to be encrypted. recipients (str|list): A key id of a recipient of the encrypted data, or a list of such key ids. sign (str): If specified, the key id of a signer to sign the encrypted data. always_trust (bool): Whether to always trust keys. passphrase (str): The passphrase to use for a signature. armor (bool): Whether to ASCII-armor the output. output (str): A path to write the encrypted output to. symmetric (bool): Whether to use symmetric encryption, extra_args (list[str]): A list of additional arguments to pass to `gpg`. \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ) : msg = \"Invalid passphrase\" raise ValueError ( msg ) args = [ \"--encrypt\" ] if symmetric : # can ' t be False or None - could be True or a cipher algo value # such as AES256 args = [ \"--symmetric\" ] if symmetric is not True : args . extend ( [ \"--cipher-algo\", symmetric ] ) # else use the default , currently CAST5 else : if not recipients : msg = \"No recipients specified with asymmetric encryption\" raise ValueError ( msg ) if not _is_sequence ( recipients ) : recipients = ( recipients ,) for recipient in recipients : args . extend ( [ \"--recipient\", recipient ] ) if armor : # create ascii - armored output - False for binary output args . append ( \"--armor\" ) if output : # pragma : no cover # write the output to a file with the specified name self . set_output_without_confirmation ( args , output ) if sign is True : # pragma : no cover args . append ( \"--sign\" ) elif sign : # pragma : no cover args . extend ( [ \"--sign\", \"--default-key\", sign ] ) if always_trust : # pragma : no cover args . extend ( [ \"--trust-model\", \"always\" ] ) if extra_args : # pragma : no cover args . extend ( extra_args ) result = self . result_map [ \"crypt\" ] ( self ) self . _handle_io ( args , fileobj_or_path , result , passphrase = passphrase , binary = True ) logger . debug ( \"encrypt result[:100]: %r\" , result . data [ :100 ] ) return result export_keys def export_keys ( self , keyids : 'str | list[str]' , * , secret : 'bool' = False , armor : 'bool' = True , minimal : 'bool' = False , passphrase : 'str | None' = None , expect_passphrase : 'bool' = True , output : 'None' = None ) -> 'str | bytes' Export the indicated keys. A 'keyid' is anything gpg accepts. Parameters: Name Type Description Default keyids str list[str] A single keyid or a list of them. secret bool Whether to export secret keys. None armor bool Whether to ASCII-armor the output. None minimal bool Whether to pass --export-options export-minimal to gpg . None passphrase str The passphrase to use. None expect_passphrase bool Whether a passphrase is expected. None output str If specified, the path to write the exported key(s) to. None View Source def export_keys ( # noqa: PLR0913 self , keyids : str | list [ str ], * , secret : bool = False , armor : bool = True , minimal : bool = False , passphrase : str | None = None , expect_passphrase : bool = True , output : None = None , ) -> str | bytes : \"\"\" Export the indicated keys. A 'keyid' is anything `gpg` accepts. Args: keyids (str|list[str]): A single keyid or a list of them. secret (bool): Whether to export secret keys. armor (bool): Whether to ASCII-armor the output. minimal (bool): Whether to pass `--export-options export-minimal` to `gpg`. passphrase (str): The passphrase to use. expect_passphrase (bool): Whether a passphrase is expected. output (str): If specified, the path to write the exported key(s) to. .. note:: Passphrases Since GnuPG 2.1, you can't export secret keys without providing a passphrase. However, if you're expecting the passphrase to go to `gpg` via pinentry, you should specify expect_passphrase=False. (It's only checked for GnuPG >= 2.1). \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ): # pragma: no cover msg = \"Invalid passphrase\" raise ValueError ( msg ) which = \"\" if secret : which = \"-secret-key\" if self . version >= ( 2 , 1 ) and passphrase is None and expect_passphrase : # pragma: no cover msg = \"For GnuPG >= 2.1, exporting secret keys needs a passphrase to be provided\" raise ValueError ( msg ) keyids = list ( keyids ) if _is_sequence ( keyids ) else [ keyids ] args = [ f \"--export{which}\" ] if armor : args . append ( \"--armor\" ) if minimal : # pragma: no cover args . extend ([ \"--export-options\" , \"export-minimal\" ]) if output : # pragma: no cover # write the output to a file with the specified name self . set_output_without_confirmation ( args , output ) args . extend ( keyids ) # gpg --export produces no status-fd output; stdout will be # empty in case of failure result = self . result_map [ \"export\" ]( self ) if not secret or self . version < ( 2 , 1 ): p = self . _open_subprocess ( args ) self . _collect_output ( p , result , stdin = p . stdin ) else : # Need to send in a passphrase. f = _make_binary_stream ( \"\" , self . encoding ) try : self . _handle_io ( args , f , result , passphrase = passphrase , binary = True ) finally : f . close () logger . debug ( \"export_keys result[:100]: %r \" , result . data [: 100 ]) # Issue #49: Return bytes if armor not specified, else text result = result . data if armor : result = result . decode ( self . encoding , self . decode_errors ) return result gen_key def gen_key ( self , key_input : 'str' ) -> 'GenKeyHandler' Generate a key; you might use gen_key_input() to create the input. Parameters: Name Type Description Default key_input str The input to the key creation operation. None View Source def gen_key ( self , key_input : str ) - > GenKeyHandler : \"\"\" Generate a key; you might use `gen_key_input()` to create the input. Args: key_input (str): The input to the key creation operation. \"\"\" args = [ \"--gen-key\" ] result = self . result_map [ \"generate\" ] ( self ) f = _make_binary_stream ( key_input , self . encoding ) self . _handle_io ( args , f , result , binary = True ) f . close () return result gen_key_input def gen_key_input ( self , ** kwargs : 'bool | str | int' ) -> 'str' Generate --gen-key input (see gpg documentation in DETAILS). Parameters: Name Type Description Default kwargs dict A list of keyword arguments. None Returns: Type Description str A string suitable for passing to the gen_key() method. View Source def gen_key_input ( self , ** kwargs : bool | str | int ) -> str : \"\"\" Generate ` -- gen - key ` input ( see ` gpg ` documentation in DETAILS ). Args : kwargs ( dict ) : A list of keyword arguments . Returns : str : A string suitable for passing to the ` gen_key () ` method . \"\"\" parms = {} no_protection = kwargs . pop ( \"no_protection\" , False ) for key , val in [ item for item in kwargs . items () if str ( item [ 1 ]). strip ()] : parms [ key . replace ( \"_\" , \"-\" ). title ()] = val parms . setdefault ( \"Key-Type\" , \"RSA\" ) if \"key_curve\" not in kwargs : parms . setdefault ( \"Key-Length\" , 2048 ) parms . setdefault ( \"Name-Real\" , \"Autogenerated Key\" ) logname = os . environ . get ( \"LOGNAME\" ) or os . environ . get ( \"USERNAME\" ) or \"unspecified\" hostname = socket . gethostname () parms . setdefault ( \"Name-Email\" , \"{}@{}\" . format ( logname . replace ( \" \" , \"_\" ), hostname )) out = \"Key-Type: {} \\n \" . format ( parms . pop ( \"Key-Type\" )) for key , val in list ( parms . items ()) : out += f \"{key}: {val} \\n \" if no_protection : # pragma : no cover out += \"%no-protection \\n \" out += \"%commit \\n \" return out \"\"\" Key - Type : RSA Key - Length : 1024 Name - Real : ISdlink Server on %s Name - Comment : Created by %s Name - Email : isdlink @ %s Expire - Date : 0 %commit Key - Type : DSA Key - Length : 1024 Subkey - Type : ELG - E Subkey - Length : 1024 Name - Real : Joe Tester Name - Comment : with stupid passphrase Name - Email : joe @ foo . bar Expire - Date : 0 Passphrase : abc %pubring foo . pub %secring foo . sec %commit \"\"\" return None get_recipients def get_recipients ( self , message : 'str' , ** kwargs : 'list[str]' ) -> 'list[str]' Get the list of recipients for an encrypted message. This method delegates most of the work to get_recipients_file() . Parameters: Name Type Description Default message str bytes The encrypted message. kwargs dict Keyword arguments, which are passed to get_recipients_file() : * extra_args (list[str]): A list of extra arguments to pass to gpg . None View Source def get_recipients ( self , message : str , ** kwargs : list [ str ] ) -> list [ str ] : \"\"\"Get the list of recipients for an encrypted message. This method delegates most of the work to `get_recipients_file()`. Args: message (str|bytes): The encrypted message. kwargs (dict): Keyword arguments, which are passed to `get_recipients_file()`: * extra_args (list[str]): A list of extra arguments to pass to `gpg`. \"\"\" data = _make_binary_stream ( message , self . encoding ) result = self . get_recipients_file ( data , ** kwargs ) data . close () return result get_recipients_file def get_recipients_file ( self , fileobj_or_path : 'BytesIO | str' , extra_args : 'list[str] | None' = None ) -> 'list[str]' Get the list of recipients for an encrypted message in a file or file-like object. Parameters: Name Type Description Default fileobj_or_path str file A path to a file or file-like object containing the encrypted data. extra_args list[str] A list of extra arguments to pass to gpg . None View Source def get_recipients_file ( self , fileobj_or_path : BytesIO | str , extra_args : list [ str ] | None = None ) -> list [ str ] : \"\"\" Get the list of recipients for an encrypted message in a file or file-like object. Args: fileobj_or_path (str|file): A path to a file or file-like object containing the encrypted data. extra_args (list[str]): A list of extra arguments to pass to `gpg`. \"\"\" args = [ \"--decrypt\", \"--list-only\", \"-v\" ] if extra_args : # pragma : no cover args . extend ( extra_args ) result = self . result_map [ \"crypt\" ] ( self ) self . _handle_io ( args , fileobj_or_path , result , binary = True ) return [ m.group(1) for m in PUBLIC_KEY_RE.finditer(result.stderr) ] import_keys def import_keys ( self , key_data : 'str | bytes' , extra_args : 'None' = None , passphrase : 'None' = None ) -> 'ImportResultHandler' Import the key_data into our keyring. Parameters: Name Type Description Default key_data str bytes The key data to import. passphrase str The passphrase to use. None extra_args list[str] Additional arguments to pass to gpg . None View Source def import_keys ( self , key_data : str | bytes , extra_args : None = None , passphrase : None = None , ) -> ImportResultHandler : \" \"\" Import the key_data into our keyring. Args: key_data (str|bytes): The key data to import. passphrase (str): The passphrase to use. extra_args (list[str]): Additional arguments to pass to `gpg`. \"\" \" result = self . result_map [ \"import\" ] ( self ) logger . debug ( \"import_keys: %r\" , key_data [ : 256 ] ) data = _make_binary_stream ( key_data , self . encoding ) args = [ \"--import\" ] if extra_args : # pragma: no cover args . extend ( extra_args ) self . _handle_io ( args , data , result , passphrase = passphrase , binary = True ) logger . debug ( \"import_keys result: %r\" , result . __dict__ ) data . close () return result import_keys_file def import_keys_file ( self , key_path : 'str' , ** kwargs : 'str | list[str]' ) -> 'ImportResultHandler' Import the key data in key_path into our keyring. Parameters: Name Type Description Default key_path str A path to the key data to be imported. None View Source def import_keys_file ( self , key_path : str , ** kwargs : str | list [ str ] ) -> ImportResultHandler : \"\"\" Import the key data in key_path into our keyring. Args: key_path (str): A path to the key data to be imported. \"\"\" with Path ( key_path ). open ( \"rb\" ) as f : return self . import_keys ( f . read (), ** kwargs ) is_valid_file def is_valid_file ( self , fileobj : 'str | bytes | BufferedReader | TextIOWrapper | BytesIO' ) -> 'bool' A simplistic check for a file-like object. Parameters: Name Type Description Default fileobj object The object to test. None Returns: Type Description bool True if it's a file-like object, else False . View Source def is_valid_file ( self , fileobj : str | bytes | BufferedReader | TextIOWrapper | BytesIO ) -> bool : \" \"\" A simplistic check for a file-like object. Args: fileobj (object): The object to test. Returns: bool: ``True`` if it's a file-like object, else ``False``. \"\" \" return hasattr ( fileobj , \"read\" ) is_valid_passphrase def is_valid_passphrase ( self , passphrase : 'str' ) -> 'bool' Confirm that the passphrase doesn't contain newline-type characters - it is passed in a pipe to gpg , and so not checking could lead to spoofing attacks by passing arbitrary text after passphrase and newline. Parameters: Name Type Description Default passphrase str The passphrase to test. None Returns: Type Description bool True if it's a valid passphrase, else False . View Source def is_valid_passphrase ( self , passphrase : str ) -> bool : \" \"\" Confirm that the passphrase doesn't contain newline-type characters - it is passed in a pipe to `gpg`, and so not checking could lead to spoofing attacks by passing arbitrary text after passphrase and newline. Args: passphrase (str): The passphrase to test. Returns: bool: ``True`` if it's a valid passphrase, else ``False``. \"\" \" return \" \\n \" not in passphrase and \" \\r \" not in passphrase and \" \\ x00\" not in passphrase list_keys def list_keys ( self , * , secret : 'bool' = False , keys : 'str | list[str] | None' = None , sigs : 'bool' = False ) -> 'ListKeysHandler' List the keys currently in the keyring. Parameters: Name Type Description Default secret bool Whether to list secret keys. None keys str list[str] A list of key ids to match. sigs bool Whether to include signature information. None Returns: Type Description list[dict] A list of dictionaries with key information. View Source def list_keys ( self , * , secret : bool = False , keys : str | list [ str ] | None = None , sigs : bool = False , ) -> ListKeysHandler : \"\"\" List the keys currently in the keyring. Args: secret (bool): Whether to list secret keys. keys (str|list[str]): A list of key ids to match. sigs (bool): Whether to include signature information. Returns: list[dict]: A list of dictionaries with key information. \"\"\" which = \"secret-keys\" if secret else \"sigs\" if sigs else \"keys\" args = [ f\"--list-{which}\", \"--fingerprint\", \"--fingerprint\" ] # get subkey FPs , too if self . version >= ( 2 , 1 ) : args . append ( \"--with-keygrip\" ) if keys : if isinstance ( keys , str ) : keys = [ keys ] args . extend ( keys ) p = self . _open_subprocess ( args ) return self . _get_list_output ( p , \"list\" ) make_args def make_args ( self , args : 'list[str]' , * , passphrase : 'bool | None' = False ) -> 'list[str]' Make a list of command line elements for GPG. The value of args will be appended. The passphrase argument needs to be True if a passphrase will be sent to gpg , else False. Parameters: Name Type Description Default args list[str] A list of arguments. None passphrase str The passphrase to use. None View Source def make_args ( self , args : list [ str ] , * , passphrase : bool | None = False ) -> list [ str ] : \" \"\" Make a list of command line elements for GPG. The value of ``args`` will be appended. The ``passphrase`` argument needs to be True if a passphrase will be sent to `gpg`, else False. Args: args (list[str]): A list of arguments. passphrase (str): The passphrase to use. \"\" \" cmd = [ self . gpgbinary , \"--status-fd\" , \"2\" , \"--no-tty\" , \"--no-verbose\" ] if \"DEBUG_IPC\" in os . environ : # pragma: no cover cmd . extend ( [ \"--debug\" , \"ipc\" ] ) if passphrase and hasattr ( self , \"version\" ) and self . version >= ( 2 , 1 ) : cmd [ 1 : 1 ] = [ \"--pinentry-mode\" , \"loopback\" ] cmd . extend ( [ \"--fixed-list-mode\" , \"--batch\" , \"--with-colons\" ] ) if self . gnupghome : cmd . extend ( [ \"--homedir\" , str ( self . gnupghome ) ] ) if self . keyring : cmd . append ( \"--no-default-keyring\" ) for fn in self . keyring : cmd . extend ( [ \"--keyring\" , fn ] ) if self . secret_keyring : # pragma: no cover for fn in self . secret_keyring : cmd . extend ( [ \"--secret-keyring\" , fn ] ) if passphrase : cmd . extend ( [ \"--passphrase-fd\" , \"0\" ] ) if self . use_agent : # pragma: no cover cmd . append ( \"--use-agent\" ) if self . options : cmd . extend ( self . options ) cmd . extend ( args ) return cmd recv_keys def recv_keys ( self , keyserver : 'str' , * keyids : 'str' , ** kwargs : 'list[str]' ) -> 'ImportResultHandler' Import one or more keys from a keyserver. Parameters: Name Type Description Default keyserver str The key server hostname. None keyids str A list of key ids to receive. None View Source def recv_keys ( self , keyserver : str , * keyids : str , ** kwargs : list [ str ] ) -> ImportResultHandler : \"\"\" Import one or more keys from a keyserver. Args: keyserver (str): The key server hostname. keyids (str): A list of key ids to receive. \"\"\" result = self . result_map [ \"import\" ] ( self ) logger . debug ( \"recv_keys: %r\" , keyids ) data = _make_binary_stream ( \"\" , self . encoding ) args = [ \"--keyserver\", keyserver ] if \"extra_args\" in kwargs : # pragma : no cover args . extend ( kwargs [ \"extra_args\" ] ) args . append ( \"--recv-keys\" ) args . extend ( list ( keyids )) self . _handle_io ( args , data , result , binary = True ) logger . debug ( \"recv_keys result: %r\" , result . __dict__ ) data . close () return result scan_keys def scan_keys ( self , filename : 'str' ) -> 'ScanKeysHandler' List details of an ascii armored or binary key file without first importing it to the local keyring. Parameters: Name Type Description Default filename str The path to the file containing the key(s). None View Source def scan_keys ( self , filename : str ) -> ScanKeysHandler : \"\"\" List details of an ascii armored or binary key file without first importing it to the local keyring. Args: filename (str): The path to the file containing the key(s). .. warning:: Warning: Care is needed. The function works on modern GnuPG by running: $ gpg --dry-run --import-options import-show --import filename On older versions, it does the *much* riskier: $ gpg --with-fingerprint --with-colons filename \"\"\" if self . version >= ( 2 , 1 ): args = [ \"--dry-run\" , \"--import-options\" , \"import-show\" , \"--import\" ] else : logger . warning ( \"Trying to list packets, but if the file is not a keyring, might accidentally decrypt\" ) args = [ \"--with-fingerprint\" , \"--with-colons\" , \"--fixed-list-mode\" ] args . append ( filename ) p = self . _open_subprocess ( args ) return self . _get_list_output ( p , \"scan\" ) scan_keys_mem def scan_keys_mem ( self , key_data : 'str' ) -> 'ScanKeysHandler' List details of an ascii armored or binary key without first importing it to the local keyring. Parameters: Name Type Description Default key_data str bytes The key data to import. View Source def scan_keys_mem ( self , key_data : str ) -> ScanKeysHandler : \"\"\" List details of an ascii armored or binary key without first importing it to the local keyring. Args: key_data (str|bytes): The key data to import. .. warning:: Warning: Care is needed. The function works on modern GnuPG by running: $ gpg --dry-run --import-options import-show --import filename On older versions, it does the *much* riskier: $ gpg --with-fingerprint --with-colons filename \"\"\" result = self . result_map [ \"scan\" ]( self ) logger . debug ( \"scan_keys: %r \" , key_data [: 256 ]) data = _make_binary_stream ( key_data , self . encoding ) if self . version >= ( 2 , 1 ): args = [ \"--dry-run\" , \"--import-options\" , \"import-show\" , \"--import\" ] else : logger . warning ( \"Trying to list packets, but if the file is not a keyring, might accidentally decrypt\" ) args = [ \"--with-fingerprint\" , \"--with-colons\" , \"--fixed-list-mode\" ] self . _handle_io ( args , data , result , binary = True ) logger . debug ( \"scan_keys result: %r \" , result . __dict__ ) data . close () return self . _decode_result ( result ) search_keys def search_keys ( self , query : 'str' , keyserver : 'str' = 'pgp.mit.edu' , extra_args : 'list[str] | None' = None ) -> 'StatusHandler' search a keyserver by query (using the --search-keys option). Parameters: Name Type Description Default query str The query to use. None keyserver str The key server hostname. None extra_args list[str] Additional arguments to pass to gpg . None View Source def search_keys ( self , query : str , keyserver : str = \"pgp.mit.edu\" , extra_args : list [ str ] | None = None , ) -> StatusHandler : \"\"\" search a keyserver by query (using the `--search-keys` option). Args: query(str): The query to use. keyserver (str): The key server hostname. extra_args (list[str]): Additional arguments to pass to `gpg`. \"\"\" query = query . strip () if HEX_DIGITS_RE . match ( query ) : query = \"0x\" + query args = [ \"--fingerprint\", \"--keyserver\", keyserver ] if extra_args : # pragma : no cover args . extend ( extra_args ) args . extend ( [ \"--search-keys\", query ] ) p = self . _open_subprocess ( args ) # Get the response information result = self . result_map [ \"search\" ] ( self ) self . _collect_output ( p , result , stdin = p . stdin ) lines = result . data . decode ( self . encoding , self . decode_errors ). splitlines () valid_keywords = [ \"pub\", \"uid\" ] for line in lines : if self . verbose : # pragma : no cover pass logger . debug ( \"line: %r\" , line . rstrip ()) if not line : # sometimes get blank lines on Windows continue fields = line . strip (). split ( \":\" ) if not fields : # pragma : no cover continue keyword = fields [ 0 ] if keyword in valid_keywords : getattr ( result , keyword )( fields ) return result send_keys def send_keys ( self , keyserver : 'str' , * keyids : 'str' , ** kwargs : 'list[str]' ) -> 'StatusHandler' Send one or more keys to a keyserver. Parameters: Name Type Description Default keyserver str The key server hostname. None keyids list[str] A list of key ids to send. None View Source def send_keys ( self , keyserver : str , * keyids : str , ** kwargs : list [ str ] ) -> StatusHandler : # pragma : no cover \"\"\" Send one or more keys to a keyserver. Args: keyserver (str): The key server hostname. keyids (list[str]): A list of key ids to send. \"\"\" # Note : it ' s not practical to test this function without sending # arbitrary data to live keyservers . result = self . result_map [ \"send\" ] ( self ) logger . debug ( \"send_keys: %r\" , keyids ) data = _make_binary_stream ( \"\" , self . encoding ) args = [ \"--keyserver\", keyserver ] if \"extra_args\" in kwargs : args . extend ( kwargs [ \"extra_args\" ] ) args . append ( \"--send-keys\" ) args . extend ( list ( keyids )) self . _handle_io ( args , data , result , binary = True ) logger . debug ( \"send_keys result: %r\" , result . __dict__ ) data . close () return result set_output_without_confirmation def set_output_without_confirmation ( self , args : 'list[str]' , output : 'str' ) -> 'None' If writing to a file which exists, avoid a confirmation message by updating the args value in place to set the output path and avoid any cpmfirmation prompt. Parameters: Name Type Description Default args list[str] A list of arguments. None output str The path to the outpur file. None View Source def set_output_without_confirmation ( self , args : list [ str ] , output : str ) -> None : \"\"\" If writing to a file which exists, avoid a confirmation message by updating the *args* value in place to set the output path and avoid any cpmfirmation prompt. Args: args (list[str]): A list of arguments. output (str): The path to the outpur file. \"\"\" if Path ( output ). exists () : # We need to avoid an overwrite confirmation message args . extend ( [ \"--yes\" ] ) args . extend ( [ \"--output\", output ] ) sign def sign ( self , message : 'bytes' , ** kwargs : 'str | bool | list[str]' ) -> 'SignHandler' Sign a message. This method delegates most of the work to the sign_file() method. Parameters: Name Type Description Default message str bytes The data to sign. kwargs dict Keyword arguments, which are passed to sign_file() : keyid (str): The key id of the signer. passphrase (str): The passphrase for the key. clearsign (bool): Whether to use clear signing. detach (bool): Whether to produce a detached signature. binary (bool): Whether to produce a binary signature. output (str): The path to write a detached signature to. * extra_args (list[str]): Additional arguments to pass to gpg . None View Source def sign ( self , message : bytes , ** kwargs : str | bool | list [ str ] ) -> SignHandler : \"\"\" Sign a message. This method delegates most of the work to the `sign_file()` method. Args: message (str|bytes): The data to sign. kwargs (dict): Keyword arguments, which are passed to `sign_file()`: * keyid (str): The key id of the signer. * passphrase (str): The passphrase for the key. * clearsign (bool): Whether to use clear signing. * detach (bool): Whether to produce a detached signature. * binary (bool): Whether to produce a binary signature. * output (str): The path to write a detached signature to. * extra_args (list[str]): Additional arguments to pass to `gpg`. \"\"\" f = _make_binary_stream ( message , self . encoding ) result = self . sign_file ( f , ** kwargs ) f . close () return result sign_file def sign_file ( self , fileobj_or_path : 'BufferedReader | BytesIO | str' , * , keyid : 'str | None' = None , passphrase : 'str | None' = None , clearsign : 'bool' = True , detach : 'bool' = False , binary : 'bool' = False , output : 'str | None' = None , extra_args : 'None' = None ) -> 'SignHandler' Sign data in a file or file-like object. Parameters: Name Type Description Default fileobj_or_path str file The file or file-like object to sign. keyid str The key id of the signer. None passphrase str The passphrase for the key. None clearsign bool Whether to use clear signing. None detach bool Whether to produce a detached signature. None binary bool Whether to produce a binary signature. None output str The path to write a detached signature to. None extra_args list[str] Additional arguments to pass to gpg . None View Source def sign_file ( # noqa: PLR0913 self , fileobj_or_path : BufferedReader | BytesIO | str , * , keyid : str | None = None , passphrase : str | None = None , clearsign : bool = True , detach : bool = False , binary : bool = False , output : str | None = None , extra_args : None = None , ) -> SignHandler : \" \"\" Sign data in a file or file-like object. Args: fileobj_or_path (str|file): The file or file-like object to sign. keyid (str): The key id of the signer. passphrase (str): The passphrase for the key. clearsign (bool): Whether to use clear signing. detach (bool): Whether to produce a detached signature. binary (bool): Whether to produce a binary signature. output (str): The path to write a detached signature to. extra_args (list[str]): Additional arguments to pass to `gpg`. \"\" \" if passphrase and not self . is_valid_passphrase ( passphrase ) : msg = \"Invalid passphrase\" raise ValueError ( msg ) logger . debug ( \"sign_file: %s\" , fileobj_or_path ) args = [ \"-s\" ] if binary else [ \"-sa\" ] # You can't specify detach-sign and clearsign together: gpg ignores # the detach-sign in that case. if detach : args . append ( \"--detach-sign\" ) elif clearsign : args . append ( \"--clearsign\" ) if keyid : args . extend ( [ \"--default-key\" , keyid ] ) if output : # pragma: no cover # write the output to a file with the specified name self . set _output_without_confirmation ( args , output ) if extra_args : # pragma: no cover args . extend ( extra_args ) result = self . result_map [ \"sign\" ] ( self ) # We could use _handle_io here except for the fact that if the # passphrase is bad, gpg bails and you can't write the message. fileobj = self . _get_fileobj ( fileobj_or_path ) p = self . _open_subprocess ( args , passphrase = passphrase is not None ) try : stdin = p . stdin if passphrase : _write_passphrase ( stdin , passphrase , self . encoding ) writer = _threaded_copy_data ( fileobj , stdin , self . buffer_size ) except OSError : # pragma: no cover logging . exception ( \"error writing message\" ) writer = None finally : if writer : writer . join ( 0.01 ) if fileobj is not fileobj_or_path : fileobj . close () self . _collect_output ( p , result , writer , stdin ) return result trust_keys def trust_keys ( self , fingerprints : 'str | list[str]' , trustlevel : 'str' ) -> 'StatusHandler' Set the trust level for one or more keys. Parameters: Name Type Description Default fingerprints str list[str] A key id for which to set the trust level, or a list of such key ids. trustlevel str The trust level. This is one of the following. 'TRUST_EXPIRED' 'TRUST_UNDEFINED' 'TRUST_NEVER' 'TRUST_MARGINAL' 'TRUST_FULLY' 'TRUST_ULTIMATE' None View Source def trust_keys ( self , fingerprints : str | list [ str ] , trustlevel : str ) -> StatusHandler : \"\"\" Set the trust level for one or more keys. Args: fingerprints (str|list[str]): A key id for which to set the trust level, or a list of such key ids. trustlevel (str): The trust level. This is one of the following. * ``'TRUST_EXPIRED'`` * ``'TRUST_UNDEFINED'`` * ``'TRUST_NEVER'`` * ``'TRUST_MARGINAL'`` * ``'TRUST_FULLY'`` * ``'TRUST_ULTIMATE'`` \"\"\" levels = VerifyHandler . TRUST_LEVELS if trustlevel not in levels : poss = \", \" . join ( sorted ( levels )) msg = f 'Invalid trust level: \"{trustlevel}\" (must be one of {poss})' raise ValueError ( msg ) trustlevel = levels [ trustlevel ] + 1 import tempfile try : fd , fn = tempfile . mkstemp ( prefix = \"pygpg-\" ) if isinstance ( fingerprints , str ) : fingerprints = [ fingerprints ] lines = [ f\"{f}:{trustlevel}:\" for f in fingerprints ] # The trailing newline is required ! s = os . linesep . join ( lines ) + os . linesep logger . debug ( \"writing ownertrust info: %s\" , s ) os . write ( fd , s . encode ( self . encoding )) os . close ( fd ) result = self . result_map [ \"trust\" ] ( self ) p = self . _open_subprocess ( [ \"--import-ownertrust\", fn ] ) self . _collect_output ( p , result , stdin = p . stdin ) if p . returncode != 0 : raise ValueError ( \"gpg returned an error - return code %d\" % p . returncode ) finally : Path ( fn ). unlink () return result verify def verify ( self , data : 'bytes' , ** kwargs : 'str | bool | list[str] | IO' ) -> 'VerifyHandler' Verify the signature on the contents of the string data . This method delegates most of the work to verify_file() . Parameters: Name Type Description Default data str bytes The data to verify. kwargs dict Keyword arguments, which are passed to verify_file() : * fileobj_or_path (str file): A path to a signature, or a file-like object containing one. data_filename (str): If the signature is a detached one, the path to the data that was signed. close_file (bool): If a file-like object is passed in, whether to close it. * extra_args (list[str]): Additional arguments to pass to gpg . View Source def verify ( self , data : bytes , ** kwargs : str | bool | list [ str ] | IO ) -> VerifyHandler : \"\"\" Verify the signature on the contents of the string *data*. This method delegates most of the work to `verify_file()`. Args: data (str|bytes): The data to verify. kwargs (dict): Keyword arguments, which are passed to `verify_file()`: * fileobj_or_path (str|file): A path to a signature, or a file-like object containing one. * data_filename (str): If the signature is a detached one, the path to the data that was signed. * close_file (bool): If a file-like object is passed in, whether to close it. * extra_args (list[str]): Additional arguments to pass to `gpg`. \"\"\" f = _make_binary_stream ( data , self . encoding ) result = self . verify_file ( f , ** kwargs ) f . close () return result verify_data def verify_data ( self , sig_filename : 'str' , data : 'bytes' , extra_args : 'None' = None ) -> 'VerifyHandler' Verify the signature in sig_filename against data in memory Parameters: Name Type Description Default sig_filename str The path to a signature. None data str bytes The data to be verified. extra_args list[str] Additional arguments to pass to gpg . None View Source def verify_data ( self , sig_filename : str , data : bytes , extra_args : None = None ) -> VerifyHandler : \" \"\" Verify the signature in sig_filename against data in memory Args: sig_filename (str): The path to a signature. data (str|bytes): The data to be verified. extra_args (list[str]): Additional arguments to pass to `gpg`. \"\" \" logger . debug ( \"verify_data: %r, %r ...\" , sig_filename , data [ : 16 ] ) result = self . result_map [ \"verify\" ] ( self ) args = [ \"--verify\" ] if extra_args : # pragma: no cover args . extend ( extra_args ) args . extend ( [ sig_filename , \"-\" ] ) stream = BytesIO ( data ) self . _handle_io ( args , stream , result , binary = True ) return result verify_file def verify_file ( self , fileobj_or_path : 'BytesIO | str' , * , data_filename : 'str | None' = None , close_file : 'bool' = True , extra_args : 'None' = None ) -> 'VerifyHandler' Verify a signature. Parameters: Name Type Description Default fileobj_or_path str file A path to a signature, or a file-like object containing one. data_filename str If the signature is a detached one, the path to the data that was signed. None close_file bool If a file-like object is passed in, whether to close it. None extra_args list[str] Additional arguments to pass to gpg . None View Source def verify_file ( self , fileobj_or_path : BytesIO | str , * , data_filename : str | None = None , close_file : bool = True , extra_args : None = None , ) -> VerifyHandler : \" \"\" Verify a signature. Args: fileobj_or_path (str|file): A path to a signature, or a file-like object containing one. data_filename (str): If the signature is a detached one, the path to the data that was signed. close_file (bool): If a file-like object is passed in, whether to close it. extra_args (list[str]): Additional arguments to pass to `gpg`. \"\" \" logger . debug ( \"verify_file: %r, %r\" , fileobj_or_path , data_filename ) result = self . result_map [ \"verify\" ] ( self ) args = [ \"--verify\" ] if extra_args : # pragma: no cover args . extend ( extra_args ) if data_filename is None : self . _handle_io ( args , fileobj_or_path , result , binary = True ) else : logger . debug ( \"Handling detached verification\" ) import tempfile fd , fn = tempfile . mkstemp ( prefix = \"pygpg-\" ) s = fileobj_or_path . read () if close_file : fileobj_or_path . close () logger . debug ( \"Wrote to temp file: %r\" , s ) os . write ( fd , s ) os . close ( fd ) args . append ( fn ) args . append ( data_filename ) try : p = self . _open_subprocess ( args ) self . _collect_output ( p , result , stdin = p . stdin ) finally : Path ( fn ). unlink () return result","title":"Gnupg"},{"location":"reference/gnupg/gnupg/#module-gnupggnupg","text":"View Source from __future__ import annotations import codecs import contextlib import logging import os import re import socket import threading from io import BufferedReader , BufferedWriter , BytesIO , TextIOWrapper from pathlib import Path from subprocess import PIPE , Popen from types import MappingProxyType from typing import IO , TYPE_CHECKING , Any , Callable from .handlers import ( AddSubkeyHandler , AutoLocateKeyHandler , CryptHandler , DeleteResultHandler , ExportResultHandler , GenKeyHandler , ImportResultHandler , ListKeysHandler , ScanKeysHandler , SearchKeysHandler , SendResultHandler , SignHandler , TrustResultHandler , VerifyHandler , ) from .helper import _get_logger , _is_sequence , _make_binary_stream , _threaded_copy_data , _write_passphrase if TYPE_CHECKING : from gnupg.handlers.status_handler import StatusHandler VERSION_RE = re . compile ( r \"^cfg:version:(\\d+(\\.\\d+)*)\" . encode ( \"ascii\" )) HEX_DIGITS_RE = re . compile ( r \"[0-9a-f]+$\" , re . IGNORECASE ) PUBLIC_KEY_RE = re . compile ( r \"gpg: public key is (\\w+)\" ) STARTUPINFO = None if os . name == \"nt\" : # pragma: no cover from subprocess import STARTF_USESHOWWINDOW , STARTUPINFO , SW_HIDE logger = _get_logger ( __name__ ) # See gh-196: Logging could show sensitive data. It also produces some voluminous # output. Hence, split into two tiers - stuff that's always logged, and stuff that's # only logged if log_everything is True. (This is set by the test script.) # # For now, only debug logging of chunks falls into the optionally-logged category. log_everything = False class GPG : \"\"\" This class provides a high-level programmatic interface for `gpg`. \"\"\" error_map = None decode_errors = \"strict\" buffer_size = 16384 # override in instance if needed result_map = MappingProxyType ( { \"crypt\" : CryptHandler , \"delete\" : DeleteResultHandler , \"generate\" : GenKeyHandler , \"addSubkey\" : AddSubkeyHandler , \"import\" : ImportResultHandler , \"send\" : SendResultHandler , \"list\" : ListKeysHandler , \"scan\" : ScanKeysHandler , \"search\" : SearchKeysHandler , \"sign\" : SignHandler , \"trust\" : TrustResultHandler , \"verify\" : VerifyHandler , \"export\" : ExportResultHandler , \"auto-locate-key\" : AutoLocateKeyHandler , }, ) \"A map of GPG operations to result object types.\" def __init__ ( # noqa: PLR0913 self , * , gpgbinary : str = \"gpg\" , gnupghome : str | None = None , verbose : bool = False , use_agent : bool = False , keyring : str | None = None , options : None = None , secret_keyring : None = None , env : None = None , ) -> None : \"\"\"Initialize a GPG process wrapper. Args: gpgbinary (str): A pathname for the GPG binary to use. gnupghome (str): A pathname to where we can find the public and private keyrings. The default is whatever `gpg` defaults to. keyring (str|list): The name of alternative keyring file to use, or a list of such keyring files. If specified, the default keyring is not used. options (list): A list of additional options to pass to the GPG binary. secret_keyring (str|list): The name of an alternative secret keyring file to use, or a list of such keyring files. env (dict): A dict of environment variables to be used for the GPG subprocess. \"\"\" self . gpgbinary = gpgbinary self . gnupghome = None if not gnupghome else Path ( gnupghome ) self . env = env # issue 112: fail if the specified value isn't a directory if self . gnupghome and not self . gnupghome . is_dir (): msg = f \"gnupghome should be a directory (it isn't): { self . gnupghome } \" raise ValueError ( msg ) # Allow passing a string or another iterable. Make it uniformly # a list of keyring filenames if keyring and isinstance ( keyring , str ): keyring = [ keyring ] self . keyring = keyring # Allow passing a string or another iterable. Make it uniformly # a list of keyring filenames if secret_keyring and isinstance ( secret_keyring , str ): # pragma: no cover secret_keyring = [ secret_keyring ] self . secret_keyring = secret_keyring self . verbose = verbose self . use_agent = use_agent if isinstance ( options , str ): # pragma: no cover options = [ options ] self . options = options self . on_data = None # or a callable - will be called with data chunks # Changed in 0.3.7 to use Latin-1 encoding rather than # locale.getpreferredencoding falling back to sys.stdin.encoding # falling back to utf-8, because gpg itself uses latin-1 as the default # encoding. self . encoding = \"latin-1\" if self . gnupghome and not self . gnupghome . is_dir (): # pragma: no cover self . gnupghome . mkdir ( mode = 0o700 , parents = True ) try : p = self . _open_subprocess ([ \"--list-config\" , \"--with-colons\" ]) except OSError : msg = f \"Unable to run gpg ( { self . gpgbinary } ) - it may not be available.\" logger . exception ( msg ) raise OSError ( msg ) from None result = self . result_map [ \"verify\" ]( self ) # any result will do for this self . _collect_output ( p , result , stdin = p . stdin ) if p . returncode != 0 : # pragma: no cover msg = f \"Error invoking gpg: { p . returncode } : { result . stderr } \" raise ValueError ( msg ) m = VERSION_RE . match ( result . data ) if not m : # pragma: no cover self . version = None else : dot = \".\" . encode ( \"ascii\" ) self . version = tuple ([ int ( s ) for s in m . groups ()[ 0 ] . split ( dot )]) # See issue #97. It seems gpg allow duplicate keys in keyrings, so we # can't be too strict. self . check_fingerprint_collisions = False def make_args ( self , args : list [ str ], * , passphrase : bool | None = False ) -> list [ str ]: \"\"\" Make a list of command line elements for GPG. The value of ``args`` will be appended. The ``passphrase`` argument needs to be True if a passphrase will be sent to `gpg`, else False. Args: args (list[str]): A list of arguments. passphrase (str): The passphrase to use. \"\"\" cmd = [ self . gpgbinary , \"--status-fd\" , \"2\" , \"--no-tty\" , \"--no-verbose\" ] if \"DEBUG_IPC\" in os . environ : # pragma: no cover cmd . extend ([ \"--debug\" , \"ipc\" ]) if passphrase and hasattr ( self , \"version\" ) and self . version >= ( 2 , 1 ): cmd [ 1 : 1 ] = [ \"--pinentry-mode\" , \"loopback\" ] cmd . extend ([ \"--fixed-list-mode\" , \"--batch\" , \"--with-colons\" ]) if self . gnupghome : cmd . extend ([ \"--homedir\" , str ( self . gnupghome )]) if self . keyring : cmd . append ( \"--no-default-keyring\" ) for fn in self . keyring : cmd . extend ([ \"--keyring\" , fn ]) if self . secret_keyring : # pragma: no cover for fn in self . secret_keyring : cmd . extend ([ \"--secret-keyring\" , fn ]) if passphrase : cmd . extend ([ \"--passphrase-fd\" , \"0\" ]) if self . use_agent : # pragma: no cover cmd . append ( \"--use-agent\" ) if self . options : cmd . extend ( self . options ) cmd . extend ( args ) return cmd def _open_subprocess ( self , args : list [ str ], * , passphrase : bool | None = False ) -> Popen : # Internal method: open a pipe to a GPG subprocess and return # the file objects for communicating with it. from subprocess import list2cmdline as debug_print cmd = self . make_args ( args , passphrase = passphrase ) if self . verbose : # pragma: no cover pass if not STARTUPINFO : si = None else : # pragma: no cover si = STARTUPINFO () si . dwFlags = STARTF_USESHOWWINDOW si . wShowWindow = SW_HIDE result = Popen ( # noqa: S603 cmd , shell = False , stdin = PIPE , stdout = PIPE , stderr = PIPE , startupinfo = si , env = self . env , ) logger . debug ( \" %s : %s \" , result . pid , debug_print ( cmd )) return result def _read_response ( self , stream : IO , result : StatusHandler ) -> None : # Internal method: reads all the stderr output from GPG, taking notice # only of lines that begin with the magic [GNUPG:] prefix. # # Calls methods on the response object for each valid token found, # with the arg being the remainder of the status line. lines = [] while True : line = stream . readline () if len ( line ) == 0 : break lines . append ( line ) line = line . rstrip () if self . verbose : # pragma: no cover pass logger . debug ( \" %s \" , line ) if line [ 0 : 9 ] == \"[GNUPG:] \" : # Chop off the prefix line = line [ 9 :] . split ( None , 1 ) keyword = line [ 0 ] value = line [ 1 ] if len ( line ) > 1 else \"\" result . handle_status ( keyword , value ) result . stderr = \"\" . join ( lines ) def _read_data ( self , stream : IO , result : StatusHandler , * , on_data : Callable [[ str | bytes ], Any ] | None = None , buffer_size : int = 1024 , ) -> None : # Read the contents of the file from GPG's stdout assert buffer_size > 0 # noqa: S101 chunks = [] while True : data = stream . read ( buffer_size ) if len ( data ) == 0 : if on_data : on_data ( data ) break if log_everything : msg = f \"chunk: { data [: 256 ] !r} \" logger . debug ( msg ) append = True if on_data : append = on_data ( data ) is not False if append : chunks . append ( data ) # Join using b'' or '', as appropriate result . data = type ( data )() . join ( chunks ) def _collect_output ( self , process : Popen , result : StatusHandler , writer : threading . Thread | None = None , stdin : BufferedWriter | None = None , ) -> int : \"\"\" Drain the subprocesses output streams, writing the collected output to the result. If a writer thread (writing to the subprocess) is given, make sure it's joined before returning. If a stdin stream is given, close it before returning. \"\"\" stderr = codecs . getreader ( self . encoding )( process . stderr ) rr = threading . Thread ( target = self . _read_response , args = ( stderr , result )) rr . daemon = True logger . debug ( \"stderr reader: %r \" , rr ) rr . start () stdout = process . stdout dr = threading . Thread ( target = self . _read_data , args = ( stdout , result ), kwargs = { \"on_data\" : self . on_data , \"buffer_size\" : self . buffer_size }, ) dr . daemon = True logger . debug ( \"stdout reader: %r \" , dr ) dr . start () dr . join () rr . join () if writer is not None : writer . join ( 0.01 ) process . wait () result . returncode = rc = process . returncode if rc != 0 : logger . warning ( \"gpg returned a non-zero error code: %d \" , rc ) if stdin is not None : with contextlib . suppress ( OSError ): stdin . close () stderr . close () stdout . close () return rc def is_valid_file ( self , fileobj : str | bytes | BufferedReader | TextIOWrapper | BytesIO ) -> bool : \"\"\" A simplistic check for a file-like object. Args: fileobj (object): The object to test. Returns: bool: ``True`` if it's a file-like object, else ``False``. \"\"\" return hasattr ( fileobj , \"read\" ) def _get_fileobj ( self , fileobj_or_path : str | bytes | BufferedReader | TextIOWrapper | BytesIO , ) -> BufferedReader | BytesIO | TextIOWrapper : if self . is_valid_file ( fileobj_or_path ): result = fileobj_or_path elif not isinstance ( fileobj_or_path , str ): msg = f \"Not a valid file or path: { fileobj_or_path } \" raise TypeError ( msg ) elif not Path ( fileobj_or_path ) . exists (): msg = f \"No such file: { fileobj_or_path } \" raise ValueError ( msg ) else : result = Path ( fileobj_or_path ) . open ( \"rb\" ) # noqa: SIM115 return result def _handle_io ( self , args : list [ str ], fileobj_or_path : str | bytes | BufferedReader | TextIOWrapper | BytesIO , result : StatusHandler , * , passphrase : str | None = None , binary : bool = False , ) -> StatusHandler : \"Handle a call to GPG - pass input data, collect output data\" # Handle a basic data call - pass data to GPG, handle the output # including status information. Garbage In, Garbage Out :) fileobj = self . _get_fileobj ( fileobj_or_path ) try : p = self . _open_subprocess ( args , passphrase = passphrase is not None ) stdin = p . stdin if binary else codecs . getwriter ( self . encoding )( p . stdin ) writer = None # See issue #237 if passphrase : _write_passphrase ( stdin , passphrase , self . encoding ) writer = _threaded_copy_data ( fileobj , stdin , self . buffer_size ) self . _collect_output ( p , result , writer , stdin ) return result finally : if writer : writer . join ( 0.01 ) if fileobj is not fileobj_or_path : fileobj . close () # # SIGNATURE METHODS # def sign ( self , message : bytes , ** kwargs : str | bool | list [ str ]) -> SignHandler : \"\"\" Sign a message. This method delegates most of the work to the `sign_file()` method. Args: message (str|bytes): The data to sign. kwargs (dict): Keyword arguments, which are passed to `sign_file()`: * keyid (str): The key id of the signer. * passphrase (str): The passphrase for the key. * clearsign (bool): Whether to use clear signing. * detach (bool): Whether to produce a detached signature. * binary (bool): Whether to produce a binary signature. * output (str): The path to write a detached signature to. * extra_args (list[str]): Additional arguments to pass to `gpg`. \"\"\" f = _make_binary_stream ( message , self . encoding ) result = self . sign_file ( f , ** kwargs ) f . close () return result def set_output_without_confirmation ( self , args : list [ str ], output : str ) -> None : \"\"\" If writing to a file which exists, avoid a confirmation message by updating the *args* value in place to set the output path and avoid any cpmfirmation prompt. Args: args (list[str]): A list of arguments. output (str): The path to the outpur file. \"\"\" if Path ( output ) . exists (): # We need to avoid an overwrite confirmation message args . extend ([ \"--yes\" ]) args . extend ([ \"--output\" , output ]) def is_valid_passphrase ( self , passphrase : str ) -> bool : \"\"\" Confirm that the passphrase doesn't contain newline-type characters - it is passed in a pipe to `gpg`, and so not checking could lead to spoofing attacks by passing arbitrary text after passphrase and newline. Args: passphrase (str): The passphrase to test. Returns: bool: ``True`` if it's a valid passphrase, else ``False``. \"\"\" return \" \\n \" not in passphrase and \" \\r \" not in passphrase and \" \\x00 \" not in passphrase def sign_file ( # noqa: PLR0913 self , fileobj_or_path : BufferedReader | BytesIO | str , * , keyid : str | None = None , passphrase : str | None = None , clearsign : bool = True , detach : bool = False , binary : bool = False , output : str | None = None , extra_args : None = None , ) -> SignHandler : \"\"\" Sign data in a file or file-like object. Args: fileobj_or_path (str|file): The file or file-like object to sign. keyid (str): The key id of the signer. passphrase (str): The passphrase for the key. clearsign (bool): Whether to use clear signing. detach (bool): Whether to produce a detached signature. binary (bool): Whether to produce a binary signature. output (str): The path to write a detached signature to. extra_args (list[str]): Additional arguments to pass to `gpg`. \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ): msg = \"Invalid passphrase\" raise ValueError ( msg ) logger . debug ( \"sign_file: %s \" , fileobj_or_path ) args = [ \"-s\" ] if binary else [ \"-sa\" ] # You can't specify detach-sign and clearsign together: gpg ignores # the detach-sign in that case. if detach : args . append ( \"--detach-sign\" ) elif clearsign : args . append ( \"--clearsign\" ) if keyid : args . extend ([ \"--default-key\" , keyid ]) if output : # pragma: no cover # write the output to a file with the specified name self . set_output_without_confirmation ( args , output ) if extra_args : # pragma: no cover args . extend ( extra_args ) result = self . result_map [ \"sign\" ]( self ) # We could use _handle_io here except for the fact that if the # passphrase is bad, gpg bails and you can't write the message. fileobj = self . _get_fileobj ( fileobj_or_path ) p = self . _open_subprocess ( args , passphrase = passphrase is not None ) try : stdin = p . stdin if passphrase : _write_passphrase ( stdin , passphrase , self . encoding ) writer = _threaded_copy_data ( fileobj , stdin , self . buffer_size ) except OSError : # pragma: no cover logging . exception ( \"error writing message\" ) writer = None finally : if writer : writer . join ( 0.01 ) if fileobj is not fileobj_or_path : fileobj . close () self . _collect_output ( p , result , writer , stdin ) return result def verify ( self , data : bytes , ** kwargs : str | bool | list [ str ] | IO ) -> VerifyHandler : \"\"\" Verify the signature on the contents of the string *data*. This method delegates most of the work to `verify_file()`. Args: data (str|bytes): The data to verify. kwargs (dict): Keyword arguments, which are passed to `verify_file()`: * fileobj_or_path (str|file): A path to a signature, or a file-like object containing one. * data_filename (str): If the signature is a detached one, the path to the data that was signed. * close_file (bool): If a file-like object is passed in, whether to close it. * extra_args (list[str]): Additional arguments to pass to `gpg`. \"\"\" f = _make_binary_stream ( data , self . encoding ) result = self . verify_file ( f , ** kwargs ) f . close () return result def verify_file ( self , fileobj_or_path : BytesIO | str , * , data_filename : str | None = None , close_file : bool = True , extra_args : None = None , ) -> VerifyHandler : \"\"\" Verify a signature. Args: fileobj_or_path (str|file): A path to a signature, or a file-like object containing one. data_filename (str): If the signature is a detached one, the path to the data that was signed. close_file (bool): If a file-like object is passed in, whether to close it. extra_args (list[str]): Additional arguments to pass to `gpg`. \"\"\" logger . debug ( \"verify_file: %r , %r \" , fileobj_or_path , data_filename ) result = self . result_map [ \"verify\" ]( self ) args = [ \"--verify\" ] if extra_args : # pragma: no cover args . extend ( extra_args ) if data_filename is None : self . _handle_io ( args , fileobj_or_path , result , binary = True ) else : logger . debug ( \"Handling detached verification\" ) import tempfile fd , fn = tempfile . mkstemp ( prefix = \"pygpg-\" ) s = fileobj_or_path . read () if close_file : fileobj_or_path . close () logger . debug ( \"Wrote to temp file: %r \" , s ) os . write ( fd , s ) os . close ( fd ) args . append ( fn ) args . append ( data_filename ) try : p = self . _open_subprocess ( args ) self . _collect_output ( p , result , stdin = p . stdin ) finally : Path ( fn ) . unlink () return result def verify_data ( self , sig_filename : str , data : bytes , extra_args : None = None ) -> VerifyHandler : \"\"\" Verify the signature in sig_filename against data in memory Args: sig_filename (str): The path to a signature. data (str|bytes): The data to be verified. extra_args (list[str]): Additional arguments to pass to `gpg`. \"\"\" logger . debug ( \"verify_data: %r , %r ...\" , sig_filename , data [: 16 ]) result = self . result_map [ \"verify\" ]( self ) args = [ \"--verify\" ] if extra_args : # pragma: no cover args . extend ( extra_args ) args . extend ([ sig_filename , \"-\" ]) stream = BytesIO ( data ) self . _handle_io ( args , stream , result , binary = True ) return result # # KEY MANAGEMENT # def import_keys ( self , key_data : str | bytes , extra_args : None = None , passphrase : None = None , ) -> ImportResultHandler : \"\"\" Import the key_data into our keyring. Args: key_data (str|bytes): The key data to import. passphrase (str): The passphrase to use. extra_args (list[str]): Additional arguments to pass to `gpg`. \"\"\" result = self . result_map [ \"import\" ]( self ) logger . debug ( \"import_keys: %r \" , key_data [: 256 ]) data = _make_binary_stream ( key_data , self . encoding ) args = [ \"--import\" ] if extra_args : # pragma: no cover args . extend ( extra_args ) self . _handle_io ( args , data , result , passphrase = passphrase , binary = True ) logger . debug ( \"import_keys result: %r \" , result . __dict__ ) data . close () return result def import_keys_file ( self , key_path : str , ** kwargs : str | list [ str ]) -> ImportResultHandler : \"\"\" Import the key data in key_path into our keyring. Args: key_path (str): A path to the key data to be imported. \"\"\" with Path ( key_path ) . open ( \"rb\" ) as f : return self . import_keys ( f . read (), ** kwargs ) def recv_keys ( self , keyserver : str , * keyids : str , ** kwargs : list [ str ]) -> ImportResultHandler : \"\"\" Import one or more keys from a keyserver. Args: keyserver (str): The key server hostname. keyids (str): A list of key ids to receive. \"\"\" result = self . result_map [ \"import\" ]( self ) logger . debug ( \"recv_keys: %r \" , keyids ) data = _make_binary_stream ( \"\" , self . encoding ) args = [ \"--keyserver\" , keyserver ] if \"extra_args\" in kwargs : # pragma: no cover args . extend ( kwargs [ \"extra_args\" ]) args . append ( \"--recv-keys\" ) args . extend ( list ( keyids )) self . _handle_io ( args , data , result , binary = True ) logger . debug ( \"recv_keys result: %r \" , result . __dict__ ) data . close () return result # This function isn't exercised by tests, to avoid polluting external # key servers with test keys def send_keys ( self , keyserver : str , * keyids : str , ** kwargs : list [ str ]) -> StatusHandler : # pragma: no cover \"\"\" Send one or more keys to a keyserver. Args: keyserver (str): The key server hostname. keyids (list[str]): A list of key ids to send. \"\"\" # Note: it's not practical to test this function without sending # arbitrary data to live keyservers. result = self . result_map [ \"send\" ]( self ) logger . debug ( \"send_keys: %r \" , keyids ) data = _make_binary_stream ( \"\" , self . encoding ) args = [ \"--keyserver\" , keyserver ] if \"extra_args\" in kwargs : args . extend ( kwargs [ \"extra_args\" ]) args . append ( \"--send-keys\" ) args . extend ( list ( keyids )) self . _handle_io ( args , data , result , binary = True ) logger . debug ( \"send_keys result: %r \" , result . __dict__ ) data . close () return result def delete_keys ( self , fingerprints : str , * , secret : bool = False , passphrase : str | None = None , expect_passphrase : bool = True , exclamation_mode : bool = False , ) -> DeleteResultHandler : \"\"\" Delete the indicated keys. Args: fingerprints (str|list[str]): The keys to delete. secret (bool): Whether to delete secret keys. passphrase (str): The passphrase to use. expect_passphrase (bool): Whether a passphrase is expected. exclamation_mode (bool): If specified, a `'!'` is appended to each fingerprint. This deletes only a subkey or an entire key, depending on what the fingerprint refers to. .. note:: Passphrases Since GnuPG 2.1, you can't delete secret keys without providing a passphrase. However, if you're expecting the passphrase to go to `gpg` via pinentry, you should specify expect_passphrase=False. (It's only checked for GnuPG >= 2.1). \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ): # pragma: no cover msg = \"Invalid passphrase\" raise ValueError ( msg ) which = \"key\" if secret : # pragma: no cover if self . version >= ( 2 , 1 ) and passphrase is None and expect_passphrase : msg = \"For GnuPG >= 2.1, deleting secret keys needs a passphrase to be provided\" raise ValueError ( msg ) which = \"secret-key\" fingerprints = list ( fingerprints ) if _is_sequence ( fingerprints ) else [ fingerprints ] if exclamation_mode : fingerprints = [ f + \"!\" for f in fingerprints ] args = [ f \"--delete- { which } \" ] if secret and self . version >= ( 2 , 1 ): args . insert ( 0 , \"--yes\" ) args . extend ( fingerprints ) result = self . result_map [ \"delete\" ]( self ) if not secret or self . version < ( 2 , 1 ): p = self . _open_subprocess ( args ) self . _collect_output ( p , result , stdin = p . stdin ) else : # Need to send in a passphrase. f = _make_binary_stream ( \"\" , self . encoding ) try : self . _handle_io ( args , f , result , passphrase = passphrase , binary = True ) finally : f . close () return result def export_keys ( # noqa: PLR0913 self , keyids : str | list [ str ], * , secret : bool = False , armor : bool = True , minimal : bool = False , passphrase : str | None = None , expect_passphrase : bool = True , output : None = None , ) -> str | bytes : \"\"\" Export the indicated keys. A 'keyid' is anything `gpg` accepts. Args: keyids (str|list[str]): A single keyid or a list of them. secret (bool): Whether to export secret keys. armor (bool): Whether to ASCII-armor the output. minimal (bool): Whether to pass `--export-options export-minimal` to `gpg`. passphrase (str): The passphrase to use. expect_passphrase (bool): Whether a passphrase is expected. output (str): If specified, the path to write the exported key(s) to. .. note:: Passphrases Since GnuPG 2.1, you can't export secret keys without providing a passphrase. However, if you're expecting the passphrase to go to `gpg` via pinentry, you should specify expect_passphrase=False. (It's only checked for GnuPG >= 2.1). \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ): # pragma: no cover msg = \"Invalid passphrase\" raise ValueError ( msg ) which = \"\" if secret : which = \"-secret-key\" if self . version >= ( 2 , 1 ) and passphrase is None and expect_passphrase : # pragma: no cover msg = \"For GnuPG >= 2.1, exporting secret keys needs a passphrase to be provided\" raise ValueError ( msg ) keyids = list ( keyids ) if _is_sequence ( keyids ) else [ keyids ] args = [ f \"--export { which } \" ] if armor : args . append ( \"--armor\" ) if minimal : # pragma: no cover args . extend ([ \"--export-options\" , \"export-minimal\" ]) if output : # pragma: no cover # write the output to a file with the specified name self . set_output_without_confirmation ( args , output ) args . extend ( keyids ) # gpg --export produces no status-fd output; stdout will be # empty in case of failure result = self . result_map [ \"export\" ]( self ) if not secret or self . version < ( 2 , 1 ): p = self . _open_subprocess ( args ) self . _collect_output ( p , result , stdin = p . stdin ) else : # Need to send in a passphrase. f = _make_binary_stream ( \"\" , self . encoding ) try : self . _handle_io ( args , f , result , passphrase = passphrase , binary = True ) finally : f . close () logger . debug ( \"export_keys result[:100]: %r \" , result . data [: 100 ]) # Issue #49: Return bytes if armor not specified, else text result = result . data if armor : result = result . decode ( self . encoding , self . decode_errors ) return result def _decode_result ( self , result : ListKeysHandler | ScanKeysHandler , ) -> ListKeysHandler | ScanKeysHandler : lines = result . data . decode ( self . encoding , self . decode_errors ) . splitlines () valid_keywords = \"pub uid sec fpr sub ssb sig grp\" . split () for line in lines : if self . verbose : # pragma: no cover pass logger . debug ( \"line: %r \" , line . rstrip ()) if not line : # pragma: no cover break fields = line . strip () . split ( \":\" ) if not fields : # pragma: no cover continue keyword = fields [ 0 ] if keyword in valid_keywords : getattr ( result , keyword )( fields ) return result def _get_list_output ( self , p : Popen , kind : str ) -> ListKeysHandler | ScanKeysHandler : # Get the response information result = self . result_map [ kind ]( self ) self . _collect_output ( p , result , stdin = p . stdin ) return self . _decode_result ( result ) def list_keys ( self , * , secret : bool = False , keys : str | list [ str ] | None = None , sigs : bool = False , ) -> ListKeysHandler : \"\"\" List the keys currently in the keyring. Args: secret (bool): Whether to list secret keys. keys (str|list[str]): A list of key ids to match. sigs (bool): Whether to include signature information. Returns: list[dict]: A list of dictionaries with key information. \"\"\" which = \"secret-keys\" if secret else \"sigs\" if sigs else \"keys\" args = [ f \"--list- { which } \" , \"--fingerprint\" , \"--fingerprint\" ] # get subkey FPs, too if self . version >= ( 2 , 1 ): args . append ( \"--with-keygrip\" ) if keys : if isinstance ( keys , str ): keys = [ keys ] args . extend ( keys ) p = self . _open_subprocess ( args ) return self . _get_list_output ( p , \"list\" ) def scan_keys ( self , filename : str ) -> ScanKeysHandler : \"\"\" List details of an ascii armored or binary key file without first importing it to the local keyring. Args: filename (str): The path to the file containing the key(s). .. warning:: Warning: Care is needed. The function works on modern GnuPG by running: $ gpg --dry-run --import-options import-show --import filename On older versions, it does the *much* riskier: $ gpg --with-fingerprint --with-colons filename \"\"\" if self . version >= ( 2 , 1 ): args = [ \"--dry-run\" , \"--import-options\" , \"import-show\" , \"--import\" ] else : logger . warning ( \"Trying to list packets, but if the file is not a keyring, might accidentally decrypt\" ) args = [ \"--with-fingerprint\" , \"--with-colons\" , \"--fixed-list-mode\" ] args . append ( filename ) p = self . _open_subprocess ( args ) return self . _get_list_output ( p , \"scan\" ) def scan_keys_mem ( self , key_data : str ) -> ScanKeysHandler : \"\"\" List details of an ascii armored or binary key without first importing it to the local keyring. Args: key_data (str|bytes): The key data to import. .. warning:: Warning: Care is needed. The function works on modern GnuPG by running: $ gpg --dry-run --import-options import-show --import filename On older versions, it does the *much* riskier: $ gpg --with-fingerprint --with-colons filename \"\"\" result = self . result_map [ \"scan\" ]( self ) logger . debug ( \"scan_keys: %r \" , key_data [: 256 ]) data = _make_binary_stream ( key_data , self . encoding ) if self . version >= ( 2 , 1 ): args = [ \"--dry-run\" , \"--import-options\" , \"import-show\" , \"--import\" ] else : logger . warning ( \"Trying to list packets, but if the file is not a keyring, might accidentally decrypt\" ) args = [ \"--with-fingerprint\" , \"--with-colons\" , \"--fixed-list-mode\" ] self . _handle_io ( args , data , result , binary = True ) logger . debug ( \"scan_keys result: %r \" , result . __dict__ ) data . close () return self . _decode_result ( result ) def search_keys ( self , query : str , keyserver : str = \"pgp.mit.edu\" , extra_args : list [ str ] | None = None , ) -> StatusHandler : \"\"\" search a keyserver by query (using the `--search-keys` option). Args: query(str): The query to use. keyserver (str): The key server hostname. extra_args (list[str]): Additional arguments to pass to `gpg`. \"\"\" query = query . strip () if HEX_DIGITS_RE . match ( query ): query = \"0x\" + query args = [ \"--fingerprint\" , \"--keyserver\" , keyserver ] if extra_args : # pragma: no cover args . extend ( extra_args ) args . extend ([ \"--search-keys\" , query ]) p = self . _open_subprocess ( args ) # Get the response information result = self . result_map [ \"search\" ]( self ) self . _collect_output ( p , result , stdin = p . stdin ) lines = result . data . decode ( self . encoding , self . decode_errors ) . splitlines () valid_keywords = [ \"pub\" , \"uid\" ] for line in lines : if self . verbose : # pragma: no cover pass logger . debug ( \"line: %r \" , line . rstrip ()) if not line : # sometimes get blank lines on Windows continue fields = line . strip () . split ( \":\" ) if not fields : # pragma: no cover continue keyword = fields [ 0 ] if keyword in valid_keywords : getattr ( result , keyword )( fields ) return result def auto_locate_key ( self , email : str , mechanisms : list [ str ] | None = None , ** kwargs : list [ str ]) -> StatusHandler : \"\"\" Auto locate a public key by `email`. Args: email (str): The email address to search for. mechanisms (list[str]): A list of mechanisms to use. Valid mechanisms can be found here https://www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration-Options.html under \"--auto-key-locate\". Default: ['wkd', 'ntds', 'ldap', 'cert', 'dane', 'local'] \"\"\" mechanisms = mechanisms or [ \"wkd\" , \"ntds\" , \"ldap\" , \"cert\" , \"dane\" , \"local\" ] args = [ \"--auto-key-locate\" , \",\" . join ( mechanisms ), \"--locate-keys\" , email ] result = self . result_map [ \"auto-locate-key\" ]( self ) if \"extra_args\" in kwargs : args . extend ( kwargs [ \"extra_args\" ]) process = self . _open_subprocess ( args ) self . _collect_output ( process , result , stdin = process . stdin ) self . _decode_result ( result ) return result def gen_key ( self , key_input : str ) -> GenKeyHandler : \"\"\" Generate a key; you might use `gen_key_input()` to create the input. Args: key_input (str): The input to the key creation operation. \"\"\" args = [ \"--gen-key\" ] result = self . result_map [ \"generate\" ]( self ) f = _make_binary_stream ( key_input , self . encoding ) self . _handle_io ( args , f , result , binary = True ) f . close () return result def gen_key_input ( self , ** kwargs : bool | str | int ) -> str : \"\"\" Generate `--gen-key` input (see `gpg` documentation in DETAILS). Args: kwargs (dict): A list of keyword arguments. Returns: str: A string suitable for passing to the `gen_key()` method. \"\"\" parms = {} no_protection = kwargs . pop ( \"no_protection\" , False ) for key , val in [ item for item in kwargs . items () if str ( item [ 1 ]) . strip ()]: parms [ key . replace ( \"_\" , \"-\" ) . title ()] = val parms . setdefault ( \"Key-Type\" , \"RSA\" ) if \"key_curve\" not in kwargs : parms . setdefault ( \"Key-Length\" , 2048 ) parms . setdefault ( \"Name-Real\" , \"Autogenerated Key\" ) logname = os . environ . get ( \"LOGNAME\" ) or os . environ . get ( \"USERNAME\" ) or \"unspecified\" hostname = socket . gethostname () parms . setdefault ( \"Name-Email\" , \" {} @ {} \" . format ( logname . replace ( \" \" , \"_\" ), hostname )) out = \"Key-Type: {} \\n \" . format ( parms . pop ( \"Key-Type\" )) for key , val in list ( parms . items ()): out += f \" { key } : { val } \\n \" if no_protection : # pragma: no cover out += \"%no-protection \\n \" out += \" %c ommit \\n \" return out \"\"\" Key-Type: RSA Key-Length: 1024 Name-Real: ISdlink Server on %s Name-Comment: Created by %s Name-Email: isdlink@ %s Expire-Date: 0 %c ommit Key-Type: DSA Key-Length: 1024 Subkey-Type: ELG-E Subkey-Length: 1024 Name-Real: Joe Tester Name-Comment: with stupid passphrase Name-Email: joe@foo.bar Expire-Date: 0 Passphrase: abc %pubring foo.pub %s ecring foo.sec %c ommit \"\"\" return None def add_subkey ( self , master_key : str , master_passphrase : str | None = None , algorithm : str = \"rsa\" , usage : str = \"encrypt\" , expire : int = \"-\" , ) -> AddSubkeyHandler : \"\"\" Add subkeys to a master key, Args: master_key (str): The master key. master_passphrase (str): The passphrase for the master key. algorithm (str): The key algorithm to use. usage (str): The desired uses for the subkey. expire (str): The expiration date of the subkey. \"\"\" if self . version [ 0 ] < 2 : # noqa: PLR2004 msg = \"Not available in GnuPG 1.x\" raise NotImplementedError ( msg ) if not master_key : # pragma: no cover msg = \"No master key fingerprint specified\" raise ValueError ( msg ) if master_passphrase and not self . is_valid_passphrase ( master_passphrase ): # pragma: no cover msg = \"Invalid passphrase\" raise ValueError ( msg ) args = [ \"--quick-add-key\" , master_key , algorithm , usage , str ( expire )] result = self . result_map [ \"addSubkey\" ]( self ) f = _make_binary_stream ( \"\" , self . encoding ) self . _handle_io ( args , f , result , passphrase = master_passphrase , binary = True ) return result # # ENCRYPTION # def encrypt_file ( # noqa: PLR0913 self , fileobj_or_path : BytesIO | str , recipients : str | list [ str ] | tuple [ str , str ] | None , * , sign : str | None = None , always_trust : bool = False , passphrase : str | None = None , armor : bool = True , output : str | None = None , symmetric : bool | str = False , extra_args : list [ str ] | None = None , ) -> CryptHandler : \"\"\" Encrypt data in a file or file-like object. Args: fileobj_or_path (str|file): A path to a file or a file-like object containing the data to be encrypted. recipients (str|list): A key id of a recipient of the encrypted data, or a list of such key ids. sign (str): If specified, the key id of a signer to sign the encrypted data. always_trust (bool): Whether to always trust keys. passphrase (str): The passphrase to use for a signature. armor (bool): Whether to ASCII-armor the output. output (str): A path to write the encrypted output to. symmetric (bool): Whether to use symmetric encryption, extra_args (list[str]): A list of additional arguments to pass to `gpg`. \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ): msg = \"Invalid passphrase\" raise ValueError ( msg ) args = [ \"--encrypt\" ] if symmetric : # can't be False or None - could be True or a cipher algo value # such as AES256 args = [ \"--symmetric\" ] if symmetric is not True : args . extend ([ \"--cipher-algo\" , symmetric ]) # else use the default, currently CAST5 else : if not recipients : msg = \"No recipients specified with asymmetric encryption\" raise ValueError ( msg ) if not _is_sequence ( recipients ): recipients = ( recipients ,) for recipient in recipients : args . extend ([ \"--recipient\" , recipient ]) if armor : # create ascii-armored output - False for binary output args . append ( \"--armor\" ) if output : # pragma: no cover # write the output to a file with the specified name self . set_output_without_confirmation ( args , output ) if sign is True : # pragma: no cover args . append ( \"--sign\" ) elif sign : # pragma: no cover args . extend ([ \"--sign\" , \"--default-key\" , sign ]) if always_trust : # pragma: no cover args . extend ([ \"--trust-model\" , \"always\" ]) if extra_args : # pragma: no cover args . extend ( extra_args ) result = self . result_map [ \"crypt\" ]( self ) self . _handle_io ( args , fileobj_or_path , result , passphrase = passphrase , binary = True ) logger . debug ( \"encrypt result[:100]: %r \" , result . data [: 100 ]) return result def encrypt ( self , data : str | bytes , recipients : str | list [ str ] | tuple [ str , str ] | None , ** kwargs : str | bool | list [ str ], ) -> CryptHandler : \"\"\" Encrypt the message contained in the string *data* for *recipients*. This method delegates most of the work to `encrypt_file()`. Args: data (str|bytes): The data to encrypt. recipients (str|list[str]): A key id of a recipient of the encrypted data, or a list of such key ids. kwargs (dict): Keyword arguments, which are passed to `encrypt_file()`: * sign (str): If specified, the key id of a signer to sign the encrypted data. * always_trust (bool): Whether to always trust keys. * passphrase (str): The passphrase to use for a signature. * armor (bool): Whether to ASCII-armor the output. * output (str): A path to write the encrypted output to. * symmetric (bool): Whether to use symmetric encryption, * extra_args (list[str]): A list of additional arguments to pass to `gpg`. \"\"\" data = _make_binary_stream ( data , self . encoding ) result = self . encrypt_file ( data , recipients , ** kwargs ) data . close () return result def decrypt ( self , message : str , ** kwargs : str | list [ str ]) -> CryptHandler : \"\"\" Decrypt the data in *message*. This method delegates most of the work to `decrypt_file()`. Args: message (str|bytes): The data to decrypt. A default key will be used for decryption. kwargs (dict): Keyword arguments, which are passed to `decrypt_file()`: * always_trust: Whether to always trust keys. * passphrase (str): The passphrase to use. * output (str): If specified, the path to write the decrypted data to. * extra_args (list[str]): A list of extra arguments to pass to `gpg`. \"\"\" data = _make_binary_stream ( message , self . encoding ) result = self . decrypt_file ( data , ** kwargs ) data . close () return result def decrypt_file ( self , fileobj_or_path : str | bytes | BufferedReader | TextIOWrapper | BytesIO , * , always_trust : bool = False , passphrase : str | None = None , output : str | None = None , extra_args : None = None , ) -> CryptHandler : \"\"\" Decrypt data in a file or file-like object. Args: fileobj_or_path (str|file): A path to a file or a file-like object containing the data to be decrypted. always_trust: Whether to always trust keys. passphrase (str): The passphrase to use. output (str): If specified, the path to write the decrypted data to. extra_args (list[str]): A list of extra arguments to pass to `gpg`. \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ): msg = \"Invalid passphrase\" raise ValueError ( msg ) args = [ \"--decrypt\" ] if output : # pragma: no cover # write the output to a file with the specified name self . set_output_without_confirmation ( args , output ) if always_trust : # pragma: no cover args . extend ([ \"--trust-model\" , \"always\" ]) if extra_args : # pragma: no cover args . extend ( extra_args ) result = self . result_map [ \"crypt\" ]( self ) self . _handle_io ( args , fileobj_or_path , result , passphrase = passphrase , binary = True ) logger . debug ( \"decrypt result[:100]: %r \" , result . data [: 100 ]) return result def get_recipients ( self , message : str , ** kwargs : list [ str ]) -> list [ str ]: \"\"\"Get the list of recipients for an encrypted message. This method delegates most of the work to `get_recipients_file()`. Args: message (str|bytes): The encrypted message. kwargs (dict): Keyword arguments, which are passed to `get_recipients_file()`: * extra_args (list[str]): A list of extra arguments to pass to `gpg`. \"\"\" data = _make_binary_stream ( message , self . encoding ) result = self . get_recipients_file ( data , ** kwargs ) data . close () return result def get_recipients_file ( self , fileobj_or_path : BytesIO | str , extra_args : list [ str ] | None = None ) -> list [ str ]: \"\"\" Get the list of recipients for an encrypted message in a file or file-like object. Args: fileobj_or_path (str|file): A path to a file or file-like object containing the encrypted data. extra_args (list[str]): A list of extra arguments to pass to `gpg`. \"\"\" args = [ \"--decrypt\" , \"--list-only\" , \"-v\" ] if extra_args : # pragma: no cover args . extend ( extra_args ) result = self . result_map [ \"crypt\" ]( self ) self . _handle_io ( args , fileobj_or_path , result , binary = True ) return [ m . group ( 1 ) for m in PUBLIC_KEY_RE . finditer ( result . stderr )] def trust_keys ( self , fingerprints : str | list [ str ], trustlevel : str ) -> StatusHandler : \"\"\" Set the trust level for one or more keys. Args: fingerprints (str|list[str]): A key id for which to set the trust level, or a list of such key ids. trustlevel (str): The trust level. This is one of the following. * ``'TRUST_EXPIRED'`` * ``'TRUST_UNDEFINED'`` * ``'TRUST_NEVER'`` * ``'TRUST_MARGINAL'`` * ``'TRUST_FULLY'`` * ``'TRUST_ULTIMATE'`` \"\"\" levels = VerifyHandler . TRUST_LEVELS if trustlevel not in levels : poss = \", \" . join ( sorted ( levels )) msg = f 'Invalid trust level: \" { trustlevel } \" (must be one of { poss } )' raise ValueError ( msg ) trustlevel = levels [ trustlevel ] + 1 import tempfile try : fd , fn = tempfile . mkstemp ( prefix = \"pygpg-\" ) if isinstance ( fingerprints , str ): fingerprints = [ fingerprints ] lines = [ f \" { f } : { trustlevel } :\" for f in fingerprints ] # The trailing newline is required! s = os . linesep . join ( lines ) + os . linesep logger . debug ( \"writing ownertrust info: %s \" , s ) os . write ( fd , s . encode ( self . encoding )) os . close ( fd ) result = self . result_map [ \"trust\" ]( self ) p = self . _open_subprocess ([ \"--import-ownertrust\" , fn ]) self . _collect_output ( p , result , stdin = p . stdin ) if p . returncode != 0 : raise ValueError ( \"gpg returned an error - return code %d \" % p . returncode ) finally : Path ( fn ) . unlink () return result","title":"Module gnupg.gnupg"},{"location":"reference/gnupg/gnupg/#variables","text":"HEX_DIGITS_RE PIPE PUBLIC_KEY_RE STARTUPINFO TYPE_CHECKING VERSION_RE log_everything logger","title":"Variables"},{"location":"reference/gnupg/gnupg/#classes","text":"","title":"Classes"},{"location":"reference/gnupg/gnupg/#gpg","text":"class GPG ( * , gpgbinary : 'str' = 'gpg' , gnupghome : 'str | None' = None , verbose : 'bool' = False , use_agent : 'bool' = False , keyring : 'str | None' = None , options : 'None' = None , secret_keyring : 'None' = None , env : 'None' = None ) This class provides a high-level programmatic interface for gpg . View Source class GPG : \"\"\" This class provides a high - level programmatic interface for ` gpg ` . \"\"\" error_map = None decode_errors = \"strict\" buffer_size = 16384 # override in instance if needed result_map = MappingProxyType ( { \"crypt\" : CryptHandler , \"delete\" : DeleteResultHandler , \"generate\" : GenKeyHandler , \"addSubkey\" : AddSubkeyHandler , \"import\" : ImportResultHandler , \"send\" : SendResultHandler , \"list\" : ListKeysHandler , \"scan\" : ScanKeysHandler , \"search\" : SearchKeysHandler , \"sign\" : SignHandler , \"trust\" : TrustResultHandler , \"verify\" : VerifyHandler , \"export\" : ExportResultHandler , \"auto-locate-key\" : AutoLocateKeyHandler , }, ) \"A map of GPG operations to result object types.\" def __init__ ( # noqa : PLR0913 self , * , gpgbinary : str = \"gpg\" , gnupghome : str | None = None , verbose : bool = False , use_agent : bool = False , keyring : str | None = None , options : None = None , secret_keyring : None = None , env : None = None , ) -> None : \"\"\"Initialize a GPG process wrapper. Args : gpgbinary ( str ) : A pathname for the GPG binary to use . gnupghome ( str ) : A pathname to where we can find the public and private keyrings . The default is whatever ` gpg ` defaults to . keyring ( str | list ) : The name of alternative keyring file to use , or a list of such keyring files . If specified , the default keyring is not used . options ( list ) : A list of additional options to pass to the GPG binary . secret_keyring ( str | list ) : The name of an alternative secret keyring file to use , or a list of such keyring files . env ( dict ) : A dict of environment variables to be used for the GPG subprocess . \"\"\" self . gpgbinary = gpgbinary self . gnupghome = None if not gnupghome else Path ( gnupghome ) self . env = env # issue 112: fail if the specified value isn't a directory if self . gnupghome and not self . gnupghome . is_dir () : msg = f \"gnupghome should be a directory (it isn't): {self.gnupghome}\" raise ValueError ( msg ) # Allow passing a string or another iterable. Make it uniformly # a list of keyring filenames if keyring and isinstance ( keyring , str ) : keyring = [ keyring ] self . keyring = keyring # Allow passing a string or another iterable. Make it uniformly # a list of keyring filenames if secret_keyring and isinstance ( secret_keyring , str ) : # pragma : no cover secret_keyring = [ secret_keyring ] self . secret_keyring = secret_keyring self . verbose = verbose self . use_agent = use_agent if isinstance ( options , str ) : # pragma : no cover options = [ options ] self . options = options self . on_data = None # or a callable - will be called with data chunks # Changed in 0.3.7 to use Latin-1 encoding rather than # locale.getpreferredencoding falling back to sys.stdin.encoding # falling back to utf-8, because gpg itself uses latin-1 as the default # encoding. self . encoding = \"latin-1\" if self . gnupghome and not self . gnupghome . is_dir () : # pragma : no cover self . gnupghome . mkdir ( mode = 0 o700 , parents = True ) try : p = self . _open_subprocess ([ \"--list-config\" , \"--with-colons\" ]) except OSError : msg = f \"Unable to run gpg ({self.gpgbinary}) - it may not be available.\" logger . exception ( msg ) raise OSError ( msg ) from None result = self . result_map [ \"verify\" ]( self ) # any result will do for this self . _collect_output ( p , result , stdin = p . stdin ) if p . returncode != 0 : # pragma : no cover msg = f \"Error invoking gpg: {p.returncode}: {result.stderr}\" raise ValueError ( msg ) m = VERSION_RE . match ( result . data ) if not m : # pragma : no cover self . version = None else : dot = \".\" . encode ( \"ascii\" ) self . version = tuple ([ int ( s ) for s in m . groups ()[ 0 ]. split ( dot )]) # See issue #97. It seems gpg allow duplicate keys in keyrings, so we # can't be too strict. self . check_fingerprint_collisions = False def make_args ( self , args : list [ str ], * , passphrase : bool | None = False ) -> list [ str ] : \"\"\" Make a list of command line elements for GPG . The value of `` args `` will be appended . The `` passphrase `` argument needs to be True if a passphrase will be sent to ` gpg ` , else False . Args : args ( list [ str ]) : A list of arguments . passphrase ( str ) : The passphrase to use . \"\"\" cmd = [ self . gpgbinary , \"--status-fd\" , \"2\" , \"--no-tty\" , \"--no-verbose\" ] if \"DEBUG_IPC\" in os . environ : # pragma : no cover cmd . extend ([ \"--debug\" , \"ipc\" ]) if passphrase and hasattr ( self , \"version\" ) and self . version >= ( 2 , 1 ) : cmd [ 1 : 1 ] = [ \"--pinentry-mode\" , \"loopback\" ] cmd . extend ([ \"--fixed-list-mode\" , \"--batch\" , \"--with-colons\" ]) if self . gnupghome : cmd . extend ([ \"--homedir\" , str ( self . gnupghome )]) if self . keyring : cmd . append ( \"--no-default-keyring\" ) for fn in self . keyring : cmd . extend ([ \"--keyring\" , fn ]) if self . secret_keyring : # pragma : no cover for fn in self . secret_keyring : cmd . extend ([ \"--secret-keyring\" , fn ]) if passphrase : cmd . extend ([ \"--passphrase-fd\" , \"0\" ]) if self . use_agent : # pragma : no cover cmd . append ( \"--use-agent\" ) if self . options : cmd . extend ( self . options ) cmd . extend ( args ) return cmd def _open_subprocess ( self , args : list [ str ], * , passphrase : bool | None = False ) -> Popen : # Internal method: open a pipe to a GPG subprocess and return # the file objects for communicating with it. from subprocess import list2cmdline as debug_print cmd = self . make_args ( args , passphrase = passphrase ) if self . verbose : # pragma : no cover pass if not STARTUPINFO : si = None else : # pragma : no cover si = STARTUPINFO () si . dwFlags = STARTF_USESHOWWINDOW si . wShowWindow = SW_HIDE result = Popen ( # noqa : S603 cmd , shell = False , stdin = PIPE , stdout = PIPE , stderr = PIPE , startupinfo = si , env = self . env , ) logger . debug ( \"%s: %s\" , result . pid , debug_print ( cmd )) return result def _read_response ( self , stream : IO , result : StatusHandler ) -> None : # Internal method: reads all the stderr output from GPG, taking notice # only of lines that begin with the magic [GNUPG:] prefix. # # Calls methods on the response object for each valid token found, # with the arg being the remainder of the status line. lines = [] while True : line = stream . readline () if len ( line ) == 0 : break lines . append ( line ) line = line . rstrip () if self . verbose : # pragma : no cover pass logger . debug ( \"%s\" , line ) if line [ 0 : 9 ] == \"[GNUPG:] \" : # Chop off the prefix line = line [ 9 : ]. split ( None , 1 ) keyword = line [ 0 ] value = line [ 1 ] if len ( line ) > 1 else \"\" result . handle_status ( keyword , value ) result . stderr = \"\" . join ( lines ) def _read_data ( self , stream : IO , result : StatusHandler , * , on_data : Callable [[ str | bytes ], Any ] | None = None , buffer_size : int = 1024 , ) -> None : # Read the contents of the file from GPG's stdout assert buffer_size > 0 # noqa : S101 chunks = [] while True : data = stream . read ( buffer_size ) if len ( data ) == 0 : if on_data : on_data ( data ) break if log_everything : msg = f \"chunk: {data[:256]!r}\" logger . debug ( msg ) append = True if on_data : append = on_data ( data ) is not False if append : chunks . append ( data ) # Join using b'' or '', as appropriate result . data = type ( data )(). join ( chunks ) def _collect_output ( self , process : Popen , result : StatusHandler , writer : threading . Thread | None = None , stdin : BufferedWriter | None = None , ) -> int : \"\"\" Drain the subprocesses output streams , writing the collected output to the result . If a writer thread ( writing to the subprocess ) is given , make sure it ' s joined before returning . If a stdin stream is given , close it before returning . \"\"\" stderr = codecs . getreader ( self . encoding )( process . stderr ) rr = threading . Thread ( target = self . _read_response , args = ( stderr , result )) rr . daemon = True logger . debug ( \"stderr reader: %r\" , rr ) rr . start () stdout = process . stdout dr = threading . Thread ( target = self . _read_data , args = ( stdout , result ), kwargs = { \"on_data\" : self . on_data , \"buffer_size\" : self . buffer_size }, ) dr . daemon = True logger . debug ( \"stdout reader: %r\" , dr ) dr . start () dr . join () rr . join () if writer is not None : writer . join ( 0.01 ) process . wait () result . returncode = rc = process . returncode if rc != 0 : logger . warning ( \"gpg returned a non-zero error code: %d\" , rc ) if stdin is not None : with contextlib . suppress ( OSError ) : stdin . close () stderr . close () stdout . close () return rc def is_valid_file ( self , fileobj : str | bytes | BufferedReader | TextIOWrapper | BytesIO ) -> bool : \"\"\" A simplistic check for a file - like object . Args : fileobj ( object ) : The object to test . Returns : bool : `` True `` if it ' s a file - like object , else `` False `` . \"\"\" return hasattr ( fileobj , \"read\" ) def _get_fileobj ( self , fileobj_or_path : str | bytes | BufferedReader | TextIOWrapper | BytesIO , ) -> BufferedReader | BytesIO | TextIOWrapper : if self . is_valid_file ( fileobj_or_path ) : result = fileobj_or_path elif not isinstance ( fileobj_or_path , str ) : msg = f \"Not a valid file or path: {fileobj_or_path}\" raise TypeError ( msg ) elif not Path ( fileobj_or_path ). exists () : msg = f \"No such file: {fileobj_or_path}\" raise ValueError ( msg ) else : result = Path ( fileobj_or_path ). open ( \"rb\" ) # noqa : SIM115 return result def _handle_io ( self , args : list [ str ], fileobj_or_path : str | bytes | BufferedReader | TextIOWrapper | BytesIO , result : StatusHandler , * , passphrase : str | None = None , binary : bool = False , ) -> StatusHandler : \"Handle a call to GPG - pass input data, collect output data\" # Handle a basic data call - pass data to GPG, handle the output # including status information. Garbage In, Garbage Out :) fileobj = self . _get_fileobj ( fileobj_or_path ) try : p = self . _open_subprocess ( args , passphrase = passphrase is not None ) stdin = p . stdin if binary else codecs . getwriter ( self . encoding )( p . stdin ) writer = None # See issue # 237 if passphrase : _write_passphrase ( stdin , passphrase , self . encoding ) writer = _threaded_copy_data ( fileobj , stdin , self . buffer_size ) self . _collect_output ( p , result , writer , stdin ) return result finally : if writer : writer . join ( 0.01 ) if fileobj is not fileobj_or_path : fileobj . close () # # SIGNATURE METHODS # def sign ( self , message : bytes , ** kwargs : str | bool | list [ str ]) -> SignHandler : \"\"\" Sign a message . This method delegates most of the work to the ` sign_file () ` method . Args : message ( str | bytes ) : The data to sign . kwargs ( dict ) : Keyword arguments , which are passed to ` sign_file () ` : * keyid ( str ) : The key id of the signer . * passphrase ( str ) : The passphrase for the key . * clearsign ( bool ) : Whether to use clear signing . * detach ( bool ) : Whether to produce a detached signature . * binary ( bool ) : Whether to produce a binary signature . * output ( str ) : The path to write a detached signature to . * extra_args ( list [ str ]) : Additional arguments to pass to ` gpg ` . \"\"\" f = _make_binary_stream ( message , self . encoding ) result = self . sign_file ( f , ** kwargs ) f . close () return result def set_output_without_confirmation ( self , args : list [ str ], output : str ) -> None : \"\"\" If writing to a file which exists , avoid a confirmation message by updating the * args * value in place to set the output path and avoid any cpmfirmation prompt . Args : args ( list [ str ]) : A list of arguments . output ( str ) : The path to the outpur file . \"\"\" if Path ( output ). exists () : # We need to avoid an overwrite confirmation message args . extend ([ \"--yes\" ]) args . extend ([ \"--output\" , output ]) def is_valid_passphrase ( self , passphrase : str ) -> bool : \"\"\" Confirm that the passphrase doesn ' t contain newline - type characters - it is passed in a pipe to ` gpg ` , and so not checking could lead to spoofing attacks by passing arbitrary text after passphrase and newline . Args : passphrase ( str ) : The passphrase to test . Returns : bool : `` True `` if it ' s a valid passphrase , else `` False `` . \"\"\" return \" \\n \" not in passphrase and \" \\r \" not in passphrase and \" \\x00 \" not in passphrase def sign_file ( # noqa : PLR0913 self , fileobj_or_path : BufferedReader | BytesIO | str , * , keyid : str | None = None , passphrase : str | None = None , clearsign : bool = True , detach : bool = False , binary : bool = False , output : str | None = None , extra_args : None = None , ) -> SignHandler : \"\"\" Sign data in a file or file - like object . Args : fileobj_or_path ( str | file ) : The file or file - like object to sign . keyid ( str ) : The key id of the signer . passphrase ( str ) : The passphrase for the key . clearsign ( bool ) : Whether to use clear signing . detach ( bool ) : Whether to produce a detached signature . binary ( bool ) : Whether to produce a binary signature . output ( str ) : The path to write a detached signature to . extra_args ( list [ str ]) : Additional arguments to pass to ` gpg ` . \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ) : msg = \"Invalid passphrase\" raise ValueError ( msg ) logger . debug ( \"sign_file: %s\" , fileobj_or_path ) args = [ \"-s\" ] if binary else [ \"-sa\" ] # You can't specify detach-sign and clearsign together: gpg ignores # the detach-sign in that case. if detach : args . append ( \"--detach-sign\" ) elif clearsign : args . append ( \"--clearsign\" ) if keyid : args . extend ([ \"--default-key\" , keyid ]) if output : # pragma : no cover # write the output to a file with the specified name self . set_output_without_confirmation ( args , output ) if extra_args : # pragma : no cover args . extend ( extra_args ) result = self . result_map [ \"sign\" ]( self ) # We could use _handle_io here except for the fact that if the # passphrase is bad, gpg bails and you can't write the message. fileobj = self . _get_fileobj ( fileobj_or_path ) p = self . _open_subprocess ( args , passphrase = passphrase is not None ) try : stdin = p . stdin if passphrase : _write_passphrase ( stdin , passphrase , self . encoding ) writer = _threaded_copy_data ( fileobj , stdin , self . buffer_size ) except OSError : # pragma : no cover logging . exception ( \"error writing message\" ) writer = None finally : if writer : writer . join ( 0.01 ) if fileobj is not fileobj_or_path : fileobj . close () self . _collect_output ( p , result , writer , stdin ) return result def verify ( self , data : bytes , ** kwargs : str | bool | list [ str ] | IO ) -> VerifyHandler : \"\"\" Verify the signature on the contents of the string * data * . This method delegates most of the work to ` verify_file () ` . Args : data ( str | bytes ) : The data to verify . kwargs ( dict ) : Keyword arguments , which are passed to ` verify_file () ` : * fileobj_or_path ( str | file ) : A path to a signature , or a file - like object containing one . * data_filename ( str ) : If the signature is a detached one , the path to the data that was signed . * close_file ( bool ) : If a file - like object is passed in , whether to close it . * extra_args ( list [ str ]) : Additional arguments to pass to ` gpg ` . \"\"\" f = _make_binary_stream ( data , self . encoding ) result = self . verify_file ( f , ** kwargs ) f . close () return result def verify_file ( self , fileobj_or_path : BytesIO | str , * , data_filename : str | None = None , close_file : bool = True , extra_args : None = None , ) -> VerifyHandler : \"\"\" Verify a signature . Args : fileobj_or_path ( str | file ) : A path to a signature , or a file - like object containing one . data_filename ( str ) : If the signature is a detached one , the path to the data that was signed . close_file ( bool ) : If a file - like object is passed in , whether to close it . extra_args ( list [ str ]) : Additional arguments to pass to ` gpg ` . \"\"\" logger . debug ( \"verify_file: %r, %r\" , fileobj_or_path , data_filename ) result = self . result_map [ \"verify\" ]( self ) args = [ \"--verify\" ] if extra_args : # pragma : no cover args . extend ( extra_args ) if data_filename is None : self . _handle_io ( args , fileobj_or_path , result , binary = True ) else : logger . debug ( \"Handling detached verification\" ) import tempfile fd , fn = tempfile . mkstemp ( prefix = \"pygpg-\" ) s = fileobj_or_path . read () if close_file : fileobj_or_path . close () logger . debug ( \"Wrote to temp file: %r\" , s ) os . write ( fd , s ) os . close ( fd ) args . append ( fn ) args . append ( data_filename ) try : p = self . _open_subprocess ( args ) self . _collect_output ( p , result , stdin = p . stdin ) finally : Path ( fn ). unlink () return result def verify_data ( self , sig_filename : str , data : bytes , extra_args : None = None ) -> VerifyHandler : \"\"\" Verify the signature in sig_filename against data in memory Args : sig_filename ( str ) : The path to a signature . data ( str | bytes ) : The data to be verified . extra_args ( list [ str ]) : Additional arguments to pass to ` gpg ` . \"\"\" logger . debug ( \"verify_data: %r, %r ...\" , sig_filename , data [ : 16 ]) result = self . result_map [ \"verify\" ]( self ) args = [ \"--verify\" ] if extra_args : # pragma : no cover args . extend ( extra_args ) args . extend ([ sig_filename , \"-\" ]) stream = BytesIO ( data ) self . _handle_io ( args , stream , result , binary = True ) return result # # KEY MANAGEMENT # def import_keys ( self , key_data : str | bytes , extra_args : None = None , passphrase : None = None , ) -> ImportResultHandler : \"\"\" Import the key_data into our keyring . Args : key_data ( str | bytes ) : The key data to import . passphrase ( str ) : The passphrase to use . extra_args ( list [ str ]) : Additional arguments to pass to ` gpg ` . \"\"\" result = self . result_map [ \"import\" ]( self ) logger . debug ( \"import_keys: %r\" , key_data [ : 256 ]) data = _make_binary_stream ( key_data , self . encoding ) args = [ \"--import\" ] if extra_args : # pragma : no cover args . extend ( extra_args ) self . _handle_io ( args , data , result , passphrase = passphrase , binary = True ) logger . debug ( \"import_keys result: %r\" , result . __dict__ ) data . close () return result def import_keys_file ( self , key_path : str , ** kwargs : str | list [ str ]) -> ImportResultHandler : \"\"\" Import the key data in key_path into our keyring . Args : key_path ( str ) : A path to the key data to be imported . \"\"\" with Path ( key_path ). open ( \"rb\" ) as f : return self . import_keys ( f . read (), ** kwargs ) def recv_keys ( self , keyserver : str , * keyids : str , ** kwargs : list [ str ]) -> ImportResultHandler : \"\"\" Import one or more keys from a keyserver . Args : keyserver ( str ) : The key server hostname . keyids ( str ) : A list of key ids to receive . \"\"\" result = self . result_map [ \"import\" ]( self ) logger . debug ( \"recv_keys: %r\" , keyids ) data = _make_binary_stream ( \"\" , self . encoding ) args = [ \"--keyserver\" , keyserver ] if \"extra_args\" in kwargs : # pragma : no cover args . extend ( kwargs [ \"extra_args\" ]) args . append ( \"--recv-keys\" ) args . extend ( list ( keyids )) self . _handle_io ( args , data , result , binary = True ) logger . debug ( \"recv_keys result: %r\" , result . __dict__ ) data . close () return result # This function isn't exercised by tests, to avoid polluting external # key servers with test keys def send_keys ( self , keyserver : str , * keyids : str , ** kwargs : list [ str ]) -> StatusHandler : # pragma : no cover \"\"\" Send one or more keys to a keyserver . Args : keyserver ( str ) : The key server hostname . keyids ( list [ str ]) : A list of key ids to send . \"\"\" # Note: it's not practical to test this function without sending # arbitrary data to live keyservers. result = self . result_map [ \"send\" ]( self ) logger . debug ( \"send_keys: %r\" , keyids ) data = _make_binary_stream ( \"\" , self . encoding ) args = [ \"--keyserver\" , keyserver ] if \"extra_args\" in kwargs : args . extend ( kwargs [ \"extra_args\" ]) args . append ( \"--send-keys\" ) args . extend ( list ( keyids )) self . _handle_io ( args , data , result , binary = True ) logger . debug ( \"send_keys result: %r\" , result . __dict__ ) data . close () return result def delete_keys ( self , fingerprints : str , * , secret : bool = False , passphrase : str | None = None , expect_passphrase : bool = True , exclamation_mode : bool = False , ) -> DeleteResultHandler : \"\"\" Delete the indicated keys . Args : fingerprints ( str | list [ str ]) : The keys to delete . secret ( bool ) : Whether to delete secret keys . passphrase ( str ) : The passphrase to use . expect_passphrase ( bool ) : Whether a passphrase is expected . exclamation_mode ( bool ) : If specified , a ` '!' ` is appended to each fingerprint . This deletes only a subkey or an entire key , depending on what the fingerprint refers to . .. note :: Passphrases Since GnuPG 2.1 , you can ' t delete secret keys without providing a passphrase . However , if you ' re expecting the passphrase to go to ` gpg ` via pinentry , you should specify expect_passphrase = False . ( It ' s only checked for GnuPG >= 2.1 ). \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ) : # pragma : no cover msg = \"Invalid passphrase\" raise ValueError ( msg ) which = \"key\" if secret : # pragma : no cover if self . version >= ( 2 , 1 ) and passphrase is None and expect_passphrase : msg = \"For GnuPG >= 2.1, deleting secret keys needs a passphrase to be provided\" raise ValueError ( msg ) which = \"secret-key\" fingerprints = list ( fingerprints ) if _is_sequence ( fingerprints ) else [ fingerprints ] if exclamation_mode : fingerprints = [ f + \"!\" for f in fingerprints ] args = [ f \"--delete-{which}\" ] if secret and self . version >= ( 2 , 1 ) : args . insert ( 0 , \"--yes\" ) args . extend ( fingerprints ) result = self . result_map [ \"delete\" ]( self ) if not secret or self . version < ( 2 , 1 ) : p = self . _open_subprocess ( args ) self . _collect_output ( p , result , stdin = p . stdin ) else : # Need to send in a passphrase. f = _make_binary_stream ( \"\" , self . encoding ) try : self . _handle_io ( args , f , result , passphrase = passphrase , binary = True ) finally : f . close () return result def export_keys ( # noqa : PLR0913 self , keyids : str | list [ str ], * , secret : bool = False , armor : bool = True , minimal : bool = False , passphrase : str | None = None , expect_passphrase : bool = True , output : None = None , ) -> str | bytes : \"\"\" Export the indicated keys . A ' keyid ' is anything ` gpg ` accepts . Args : keyids ( str | list [ str ]) : A single keyid or a list of them . secret ( bool ) : Whether to export secret keys . armor ( bool ) : Whether to ASCII - armor the output . minimal ( bool ) : Whether to pass ` -- export - options export - minimal ` to ` gpg ` . passphrase ( str ) : The passphrase to use . expect_passphrase ( bool ) : Whether a passphrase is expected . output ( str ) : If specified , the path to write the exported key ( s ) to . .. note :: Passphrases Since GnuPG 2.1 , you can ' t export secret keys without providing a passphrase . However , if you ' re expecting the passphrase to go to ` gpg ` via pinentry , you should specify expect_passphrase = False . ( It ' s only checked for GnuPG >= 2.1 ). \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ) : # pragma : no cover msg = \"Invalid passphrase\" raise ValueError ( msg ) which = \"\" if secret : which = \"-secret-key\" if self . version >= ( 2 , 1 ) and passphrase is None and expect_passphrase : # pragma : no cover msg = \"For GnuPG >= 2.1, exporting secret keys needs a passphrase to be provided\" raise ValueError ( msg ) keyids = list ( keyids ) if _is_sequence ( keyids ) else [ keyids ] args = [ f \"--export{which}\" ] if armor : args . append ( \"--armor\" ) if minimal : # pragma : no cover args . extend ([ \"--export-options\" , \"export-minimal\" ]) if output : # pragma : no cover # write the output to a file with the specified name self . set_output_without_confirmation ( args , output ) args . extend ( keyids ) # gpg --export produces no status-fd output; stdout will be # empty in case of failure result = self . result_map [ \"export\" ]( self ) if not secret or self . version < ( 2 , 1 ) : p = self . _open_subprocess ( args ) self . _collect_output ( p , result , stdin = p . stdin ) else : # Need to send in a passphrase. f = _make_binary_stream ( \"\" , self . encoding ) try : self . _handle_io ( args , f , result , passphrase = passphrase , binary = True ) finally : f . close () logger . debug ( \"export_keys result[:100]: %r\" , result . data [ : 100 ]) # Issue #49: Return bytes if armor not specified, else text result = result . data if armor : result = result . decode ( self . encoding , self . decode_errors ) return result def _decode_result ( self , result : ListKeysHandler | ScanKeysHandler , ) -> ListKeysHandler | ScanKeysHandler : lines = result . data . decode ( self . encoding , self . decode_errors ). splitlines () valid_keywords = \"pub uid sec fpr sub ssb sig grp\" . split () for line in lines : if self . verbose : # pragma : no cover pass logger . debug ( \"line: %r\" , line . rstrip ()) if not line : # pragma : no cover break fields = line . strip (). split ( \":\" ) if not fields : # pragma : no cover continue keyword = fields [ 0 ] if keyword in valid_keywords : getattr ( result , keyword )( fields ) return result def _get_list_output ( self , p : Popen , kind : str ) -> ListKeysHandler | ScanKeysHandler : # Get the response information result = self . result_map [ kind ]( self ) self . _collect_output ( p , result , stdin = p . stdin ) return self . _decode_result ( result ) def list_keys ( self , * , secret : bool = False , keys : str | list [ str ] | None = None , sigs : bool = False , ) -> ListKeysHandler : \"\"\" List the keys currently in the keyring . Args : secret ( bool ) : Whether to list secret keys . keys ( str | list [ str ]) : A list of key ids to match . sigs ( bool ) : Whether to include signature information . Returns : list [ dict ] : A list of dictionaries with key information . \"\"\" which = \"secret-keys\" if secret else \"sigs\" if sigs else \"keys\" args = [ f \"--list-{which}\" , \"--fingerprint\" , \"--fingerprint\" ] # get subkey FPs , too if self . version >= ( 2 , 1 ) : args . append ( \"--with-keygrip\" ) if keys : if isinstance ( keys , str ) : keys = [ keys ] args . extend ( keys ) p = self . _open_subprocess ( args ) return self . _get_list_output ( p , \"list\" ) def scan_keys ( self , filename : str ) -> ScanKeysHandler : \"\"\" List details of an ascii armored or binary key file without first importing it to the local keyring . Args : filename ( str ) : The path to the file containing the key ( s ). .. warning :: Warning : Care is needed . The function works on modern GnuPG by running : $ gpg -- dry - run -- import - options import - show -- import filename On older versions , it does the * much * riskier : $ gpg -- with - fingerprint -- with - colons filename \"\"\" if self . version >= ( 2 , 1 ) : args = [ \"--dry-run\" , \"--import-options\" , \"import-show\" , \"--import\" ] else : logger . warning ( \"Trying to list packets, but if the file is not a keyring, might accidentally decrypt\" ) args = [ \"--with-fingerprint\" , \"--with-colons\" , \"--fixed-list-mode\" ] args . append ( filename ) p = self . _open_subprocess ( args ) return self . _get_list_output ( p , \"scan\" ) def scan_keys_mem ( self , key_data : str ) -> ScanKeysHandler : \"\"\" List details of an ascii armored or binary key without first importing it to the local keyring . Args : key_data ( str | bytes ) : The key data to import . .. warning :: Warning : Care is needed . The function works on modern GnuPG by running : $ gpg -- dry - run -- import - options import - show -- import filename On older versions , it does the * much * riskier : $ gpg -- with - fingerprint -- with - colons filename \"\"\" result = self . result_map [ \"scan\" ]( self ) logger . debug ( \"scan_keys: %r\" , key_data [ : 256 ]) data = _make_binary_stream ( key_data , self . encoding ) if self . version >= ( 2 , 1 ) : args = [ \"--dry-run\" , \"--import-options\" , \"import-show\" , \"--import\" ] else : logger . warning ( \"Trying to list packets, but if the file is not a keyring, might accidentally decrypt\" ) args = [ \"--with-fingerprint\" , \"--with-colons\" , \"--fixed-list-mode\" ] self . _handle_io ( args , data , result , binary = True ) logger . debug ( \"scan_keys result: %r\" , result . __dict__ ) data . close () return self . _decode_result ( result ) def search_keys ( self , query : str , keyserver : str = \"pgp.mit.edu\" , extra_args : list [ str ] | None = None , ) -> StatusHandler : \"\"\" search a keyserver by query ( using the ` -- search - keys ` option ). Args : query ( str ) : The query to use . keyserver ( str ) : The key server hostname . extra_args ( list [ str ]) : Additional arguments to pass to ` gpg ` . \"\"\" query = query . strip () if HEX_DIGITS_RE . match ( query ) : query = \"0x\" + query args = [ \"--fingerprint\" , \"--keyserver\" , keyserver ] if extra_args : # pragma : no cover args . extend ( extra_args ) args . extend ([ \"--search-keys\" , query ]) p = self . _open_subprocess ( args ) # Get the response information result = self . result_map [ \"search\" ]( self ) self . _collect_output ( p , result , stdin = p . stdin ) lines = result . data . decode ( self . encoding , self . decode_errors ). splitlines () valid_keywords = [ \"pub\" , \"uid\" ] for line in lines : if self . verbose : # pragma : no cover pass logger . debug ( \"line: %r\" , line . rstrip ()) if not line : # sometimes get blank lines on Windows continue fields = line . strip (). split ( \":\" ) if not fields : # pragma : no cover continue keyword = fields [ 0 ] if keyword in valid_keywords : getattr ( result , keyword )( fields ) return result def auto_locate_key ( self , email : str , mechanisms : list [ str ] | None = None , ** kwargs : list [ str ]) -> StatusHandler : \"\"\" Auto locate a public key by ` email ` . Args : email ( str ) : The email address to search for . mechanisms ( list [ str ]) : A list of mechanisms to use . Valid mechanisms can be found here https : //www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration-Options.html under \"--auto-key-locate\" . Default : [ ' wkd ' , ' ntds ' , ' ldap ' , ' cert ' , ' dane ' , ' local ' ] \"\"\" mechanisms = mechanisms or [ \"wkd\" , \"ntds\" , \"ldap\" , \"cert\" , \"dane\" , \"local\" ] args = [ \"--auto-key-locate\" , \",\" . join ( mechanisms ), \"--locate-keys\" , email ] result = self . result_map [ \"auto-locate-key\" ]( self ) if \"extra_args\" in kwargs : args . extend ( kwargs [ \"extra_args\" ]) process = self . _open_subprocess ( args ) self . _collect_output ( process , result , stdin = process . stdin ) self . _decode_result ( result ) return result def gen_key ( self , key_input : str ) -> GenKeyHandler : \"\"\" Generate a key ; you might use ` gen_key_input () ` to create the input . Args : key_input ( str ) : The input to the key creation operation . \"\"\" args = [ \"--gen-key\" ] result = self . result_map [ \"generate\" ]( self ) f = _make_binary_stream ( key_input , self . encoding ) self . _handle_io ( args , f , result , binary = True ) f . close () return result def gen_key_input ( self , ** kwargs : bool | str | int ) -> str : \"\"\" Generate ` -- gen - key ` input ( see ` gpg ` documentation in DETAILS ). Args : kwargs ( dict ) : A list of keyword arguments . Returns : str : A string suitable for passing to the ` gen_key () ` method . \"\"\" parms = {} no_protection = kwargs . pop ( \"no_protection\" , False ) for key , val in [ item for item in kwargs . items () if str ( item [ 1 ]). strip ()] : parms [ key . replace ( \"_\" , \"-\" ). title ()] = val parms . setdefault ( \"Key-Type\" , \"RSA\" ) if \"key_curve\" not in kwargs : parms . setdefault ( \"Key-Length\" , 2048 ) parms . setdefault ( \"Name-Real\" , \"Autogenerated Key\" ) logname = os . environ . get ( \"LOGNAME\" ) or os . environ . get ( \"USERNAME\" ) or \"unspecified\" hostname = socket . gethostname () parms . setdefault ( \"Name-Email\" , \"{}@{}\" . format ( logname . replace ( \" \" , \"_\" ), hostname )) out = \"Key-Type: {} \\n \" . format ( parms . pop ( \"Key-Type\" )) for key , val in list ( parms . items ()) : out += f \"{key}: {val} \\n \" if no_protection : # pragma : no cover out += \"%no-protection \\n \" out += \"%commit \\n \" return out \"\"\" Key - Type : RSA Key - Length : 1024 Name - Real : ISdlink Server on %s Name - Comment : Created by %s Name - Email : isdlink @ %s Expire - Date : 0 %commit Key - Type : DSA Key - Length : 1024 Subkey - Type : ELG - E Subkey - Length : 1024 Name - Real : Joe Tester Name - Comment : with stupid passphrase Name - Email : joe @ foo . bar Expire - Date : 0 Passphrase : abc %pubring foo . pub %secring foo . sec %commit \"\"\" return None def add_subkey ( self , master_key : str , master_passphrase : str | None = None , algorithm : str = \"rsa\" , usage : str = \"encrypt\" , expire : int = \"-\" , ) -> AddSubkeyHandler : \"\"\" Add subkeys to a master key , Args : master_key ( str ) : The master key . master_passphrase ( str ) : The passphrase for the master key . algorithm ( str ) : The key algorithm to use . usage ( str ) : The desired uses for the subkey . expire ( str ) : The expiration date of the subkey . \"\"\" if self . version [ 0 ] < 2 : # noqa : PLR2004 msg = \"Not available in GnuPG 1.x\" raise NotImplementedError ( msg ) if not master_key : # pragma : no cover msg = \"No master key fingerprint specified\" raise ValueError ( msg ) if master_passphrase and not self . is_valid_passphrase ( master_passphrase ) : # pragma : no cover msg = \"Invalid passphrase\" raise ValueError ( msg ) args = [ \"--quick-add-key\" , master_key , algorithm , usage , str ( expire )] result = self . result_map [ \"addSubkey\" ]( self ) f = _make_binary_stream ( \"\" , self . encoding ) self . _handle_io ( args , f , result , passphrase = master_passphrase , binary = True ) return result # # ENCRYPTION # def encrypt_file ( # noqa : PLR0913 self , fileobj_or_path : BytesIO | str , recipients : str | list [ str ] | tuple [ str , str ] | None , * , sign : str | None = None , always_trust : bool = False , passphrase : str | None = None , armor : bool = True , output : str | None = None , symmetric : bool | str = False , extra_args : list [ str ] | None = None , ) -> CryptHandler : \"\"\" Encrypt data in a file or file - like object . Args : fileobj_or_path ( str | file ) : A path to a file or a file - like object containing the data to be encrypted . recipients ( str | list ) : A key id of a recipient of the encrypted data , or a list of such key ids . sign ( str ) : If specified , the key id of a signer to sign the encrypted data . always_trust ( bool ) : Whether to always trust keys . passphrase ( str ) : The passphrase to use for a signature . armor ( bool ) : Whether to ASCII - armor the output . output ( str ) : A path to write the encrypted output to . symmetric ( bool ) : Whether to use symmetric encryption , extra_args ( list [ str ]) : A list of additional arguments to pass to ` gpg ` . \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ) : msg = \"Invalid passphrase\" raise ValueError ( msg ) args = [ \"--encrypt\" ] if symmetric : # can't be False or None - could be True or a cipher algo value # such as AES256 args = [ \"--symmetric\" ] if symmetric is not True : args . extend ([ \"--cipher-algo\" , symmetric ]) # else use the default, currently CAST5 else : if not recipients : msg = \"No recipients specified with asymmetric encryption\" raise ValueError ( msg ) if not _is_sequence ( recipients ) : recipients = ( recipients ,) for recipient in recipients : args . extend ([ \"--recipient\" , recipient ]) if armor : # create ascii - armored output - False for binary output args . append ( \"--armor\" ) if output : # pragma : no cover # write the output to a file with the specified name self . set_output_without_confirmation ( args , output ) if sign is True : # pragma : no cover args . append ( \"--sign\" ) elif sign : # pragma : no cover args . extend ([ \"--sign\" , \"--default-key\" , sign ]) if always_trust : # pragma : no cover args . extend ([ \"--trust-model\" , \"always\" ]) if extra_args : # pragma : no cover args . extend ( extra_args ) result = self . result_map [ \"crypt\" ]( self ) self . _handle_io ( args , fileobj_or_path , result , passphrase = passphrase , binary = True ) logger . debug ( \"encrypt result[:100]: %r\" , result . data [ : 100 ]) return result def encrypt ( self , data : str | bytes , recipients : str | list [ str ] | tuple [ str , str ] | None , ** kwargs : str | bool | list [ str ], ) -> CryptHandler : \"\"\" Encrypt the message contained in the string * data * for * recipients * . This method delegates most of the work to ` encrypt_file () ` . Args : data ( str | bytes ) : The data to encrypt . recipients ( str | list [ str ]) : A key id of a recipient of the encrypted data , or a list of such key ids . kwargs ( dict ) : Keyword arguments , which are passed to ` encrypt_file () ` : * sign ( str ) : If specified , the key id of a signer to sign the encrypted data . * always_trust ( bool ) : Whether to always trust keys . * passphrase ( str ) : The passphrase to use for a signature . * armor ( bool ) : Whether to ASCII - armor the output . * output ( str ) : A path to write the encrypted output to . * symmetric ( bool ) : Whether to use symmetric encryption , * extra_args ( list [ str ]) : A list of additional arguments to pass to ` gpg ` . \"\"\" data = _make_binary_stream ( data , self . encoding ) result = self . encrypt_file ( data , recipients , ** kwargs ) data . close () return result def decrypt ( self , message : str , ** kwargs : str | list [ str ]) -> CryptHandler : \"\"\" Decrypt the data in * message * . This method delegates most of the work to ` decrypt_file () ` . Args : message ( str | bytes ) : The data to decrypt . A default key will be used for decryption . kwargs ( dict ) : Keyword arguments , which are passed to ` decrypt_file () ` : * always_trust : Whether to always trust keys . * passphrase ( str ) : The passphrase to use . * output ( str ) : If specified , the path to write the decrypted data to . * extra_args ( list [ str ]) : A list of extra arguments to pass to ` gpg ` . \"\"\" data = _make_binary_stream ( message , self . encoding ) result = self . decrypt_file ( data , ** kwargs ) data . close () return result def decrypt_file ( self , fileobj_or_path : str | bytes | BufferedReader | TextIOWrapper | BytesIO , * , always_trust : bool = False , passphrase : str | None = None , output : str | None = None , extra_args : None = None , ) -> CryptHandler : \"\"\" Decrypt data in a file or file - like object . Args : fileobj_or_path ( str | file ) : A path to a file or a file - like object containing the data to be decrypted . always_trust : Whether to always trust keys . passphrase ( str ) : The passphrase to use . output ( str ) : If specified , the path to write the decrypted data to . extra_args ( list [ str ]) : A list of extra arguments to pass to ` gpg ` . \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ) : msg = \"Invalid passphrase\" raise ValueError ( msg ) args = [ \"--decrypt\" ] if output : # pragma : no cover # write the output to a file with the specified name self . set_output_without_confirmation ( args , output ) if always_trust : # pragma : no cover args . extend ([ \"--trust-model\" , \"always\" ]) if extra_args : # pragma : no cover args . extend ( extra_args ) result = self . result_map [ \"crypt\" ]( self ) self . _handle_io ( args , fileobj_or_path , result , passphrase = passphrase , binary = True ) logger . debug ( \"decrypt result[:100]: %r\" , result . data [ : 100 ]) return result def get_recipients ( self , message : str , ** kwargs : list [ str ]) -> list [ str ] : \"\"\"Get the list of recipients for an encrypted message. This method delegates most of the work to ` get_recipients_file () ` . Args : message ( str | bytes ) : The encrypted message . kwargs ( dict ) : Keyword arguments , which are passed to ` get_recipients_file () ` : * extra_args ( list [ str ]) : A list of extra arguments to pass to ` gpg ` . \"\"\" data = _make_binary_stream ( message , self . encoding ) result = self . get_recipients_file ( data , ** kwargs ) data . close () return result def get_recipients_file ( self , fileobj_or_path : BytesIO | str , extra_args : list [ str ] | None = None ) -> list [ str ] : \"\"\" Get the list of recipients for an encrypted message in a file or file - like object . Args : fileobj_or_path ( str | file ) : A path to a file or file - like object containing the encrypted data . extra_args ( list [ str ]) : A list of extra arguments to pass to ` gpg ` . \"\"\" args = [ \"--decrypt\" , \"--list-only\" , \"-v\" ] if extra_args : # pragma : no cover args . extend ( extra_args ) result = self . result_map [ \"crypt\" ]( self ) self . _handle_io ( args , fileobj_or_path , result , binary = True ) return [ m . group ( 1 ) for m in PUBLIC_KEY_RE . finditer ( result . stderr )] def trust_keys ( self , fingerprints : str | list [ str ], trustlevel : str ) -> StatusHandler : \"\"\" Set the trust level for one or more keys . Args : fingerprints ( str | list [ str ]) : A key id for which to set the trust level , or a list of such key ids . trustlevel ( str ) : The trust level . This is one of the following . * ``' TRUST_EXPIRED '`` * ``' TRUST_UNDEFINED '`` * ``' TRUST_NEVER '`` * ``' TRUST_MARGINAL '`` * ``' TRUST_FULLY '`` * ``' TRUST_ULTIMATE '`` \"\"\" levels = VerifyHandler . TRUST_LEVELS if trustlevel not in levels : poss = \", \" . join ( sorted ( levels )) msg = f ' Invalid trust level : \"{trustlevel}\" ( must be one of { poss }) ' raise ValueError ( msg ) trustlevel = levels [ trustlevel ] + 1 import tempfile try : fd , fn = tempfile . mkstemp ( prefix = \"pygpg-\" ) if isinstance ( fingerprints , str ) : fingerprints = [ fingerprints ] lines = [ f \"{f}:{trustlevel}:\" for f in fingerprints ] # The trailing newline is required! s = os . linesep . join ( lines ) + os . linesep logger . debug ( \"writing ownertrust info: %s\" , s ) os . write ( fd , s . encode ( self . encoding )) os . close ( fd ) result = self . result_map [ \"trust\" ]( self ) p = self . _open_subprocess ([ \"--import-ownertrust\" , fn ]) self . _collect_output ( p , result , stdin = p . stdin ) if p . returncode != 0 : raise ValueError ( \"gpg returned an error - return code %d\" % p . returncode ) finally : Path ( fn ). unlink () return result","title":"GPG"},{"location":"reference/gnupg/gnupg/#class-variables","text":"buffer_size decode_errors error_map result_map A map of GPG operations to result object types.","title":"Class variables"},{"location":"reference/gnupg/gnupg/#methods","text":"","title":"Methods"},{"location":"reference/gnupg/gnupg/#add_subkey","text":"def add_subkey ( self , master_key : 'str' , master_passphrase : 'str | None' = None , algorithm : 'str' = 'rsa' , usage : 'str' = 'encrypt' , expire : 'int' = '-' ) -> 'AddSubkeyHandler' Add subkeys to a master key, Parameters: Name Type Description Default master_key str The master key. None master_passphrase str The passphrase for the master key. None algorithm str The key algorithm to use. None usage str The desired uses for the subkey. None expire str The expiration date of the subkey. None View Source def add_subkey ( self , master_key : str , master_passphrase : str | None = None , algorithm : str = \"rsa\" , usage : str = \"encrypt\" , expire : int = \"-\" , ) -> AddSubkeyHandler : \"\"\" Add subkeys to a master key, Args: master_key (str): The master key. master_passphrase (str): The passphrase for the master key. algorithm (str): The key algorithm to use. usage (str): The desired uses for the subkey. expire (str): The expiration date of the subkey. \"\"\" if self . version [ 0 ] < 2 : # noqa : PLR2004 msg = \"Not available in GnuPG 1.x\" raise NotImplementedError ( msg ) if not master_key : # pragma : no cover msg = \"No master key fingerprint specified\" raise ValueError ( msg ) if master_passphrase and not self . is_valid_passphrase ( master_passphrase ) : # pragma : no cover msg = \"Invalid passphrase\" raise ValueError ( msg ) args = [ \"--quick-add-key\" , master_key , algorithm , usage , str ( expire )] result = self . result_map [ \"addSubkey\" ]( self ) f = _make_binary_stream ( \"\" , self . encoding ) self . _handle_io ( args , f , result , passphrase = master_passphrase , binary = True ) return result","title":"add_subkey"},{"location":"reference/gnupg/gnupg/#auto_locate_key","text":"def auto_locate_key ( self , email : 'str' , mechanisms : 'list[str] | None' = None , ** kwargs : 'list[str]' ) -> 'StatusHandler' Auto locate a public key by email . Parameters: Name Type Description Default email str The email address to search for. None mechanisms list[str] A list of mechanisms to use. Valid mechanisms can be found None here https None //www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration-Options.html None under \"--auto-key-locate\". Default None ['wkd', 'ntds', 'ldap', 'cert', 'dane', 'local'] None View Source def auto_locate_key ( self , email : str , mechanisms : list [ str ] | None = None , ** kwargs : list [ str ] ) -> StatusHandler : \"\"\" Auto locate a public key by `email`. Args: email (str): The email address to search for. mechanisms (list[str]): A list of mechanisms to use. Valid mechanisms can be found here https://www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration-Options.html under \" -- auto - key - locate \". Default: ['wkd', 'ntds', 'ldap', 'cert', 'dane', 'local'] \"\"\" mechanisms = mechanisms or [ \"wkd\", \"ntds\", \"ldap\", \"cert\", \"dane\", \"local\" ] args = [ \"--auto-key-locate\", \",\".join(mechanisms), \"--locate-keys\", email ] result = self . result_map [ \"auto-locate-key\" ] ( self ) if \"extra_args\" in kwargs : args . extend ( kwargs [ \"extra_args\" ] ) process = self . _open_subprocess ( args ) self . _collect_output ( process , result , stdin = process . stdin ) self . _decode_result ( result ) return result","title":"auto_locate_key"},{"location":"reference/gnupg/gnupg/#decrypt","text":"def decrypt ( self , message : 'str' , ** kwargs : 'str | list[str]' ) -> 'CryptHandler' Decrypt the data in message . This method delegates most of the work to decrypt_file() . Parameters: Name Type Description Default message str bytes The data to decrypt. A default key will be used for decryption. kwargs dict Keyword arguments, which are passed to decrypt_file() : always_trust: Whether to always trust keys. passphrase (str): The passphrase to use. output (str): If specified, the path to write the decrypted data to. extra_args (list[str]): A list of extra arguments to pass to gpg . None View Source def decrypt ( self , message : str , ** kwargs : str | list [ str ] ) -> CryptHandler : \"\"\" Decrypt the data in *message*. This method delegates most of the work to `decrypt_file()`. Args: message (str|bytes): The data to decrypt. A default key will be used for decryption. kwargs (dict): Keyword arguments, which are passed to `decrypt_file()`: * always_trust: Whether to always trust keys. * passphrase (str): The passphrase to use. * output (str): If specified, the path to write the decrypted data to. * extra_args (list[str]): A list of extra arguments to pass to `gpg`. \"\"\" data = _make_binary_stream ( message , self . encoding ) result = self . decrypt_file ( data , ** kwargs ) data . close () return result","title":"decrypt"},{"location":"reference/gnupg/gnupg/#decrypt_file","text":"def decrypt_file ( self , fileobj_or_path : 'str | bytes | BufferedReader | TextIOWrapper | BytesIO' , * , always_trust : 'bool' = False , passphrase : 'str | None' = None , output : 'str | None' = None , extra_args : 'None' = None ) -> 'CryptHandler' Decrypt data in a file or file-like object. Parameters: Name Type Description Default fileobj_or_path str file A path to a file or a file-like object containing the data to be decrypted. always_trust None Whether to always trust keys. None passphrase str The passphrase to use. None output str If specified, the path to write the decrypted data to. None extra_args list[str] A list of extra arguments to pass to gpg . None View Source def decrypt_file ( self , fileobj_or_path : str | bytes | BufferedReader | TextIOWrapper | BytesIO , * , always_trust : bool = False , passphrase : str | None = None , output : str | None = None , extra_args : None = None , ) -> CryptHandler : \" \"\" Decrypt data in a file or file-like object. Args: fileobj_or_path (str|file): A path to a file or a file-like object containing the data to be decrypted. always_trust: Whether to always trust keys. passphrase (str): The passphrase to use. output (str): If specified, the path to write the decrypted data to. extra_args (list[str]): A list of extra arguments to pass to `gpg`. \"\" \" if passphrase and not self . is_valid_passphrase ( passphrase ) : msg = \"Invalid passphrase\" raise ValueError ( msg ) args = [ \"--decrypt\" ] if output : # pragma: no cover # write the output to a file with the specified name self . set _output_without_confirmation ( args , output ) if always_trust : # pragma: no cover args . extend ( [ \"--trust-model\" , \"always\" ] ) if extra_args : # pragma: no cover args . extend ( extra_args ) result = self . result_map [ \"crypt\" ] ( self ) self . _handle_io ( args , fileobj_or_path , result , passphrase = passphrase , binary = True ) logger . debug ( \"decrypt result[:100]: %r\" , result . data [ : 100 ] ) return result","title":"decrypt_file"},{"location":"reference/gnupg/gnupg/#delete_keys","text":"def delete_keys ( self , fingerprints : 'str' , * , secret : 'bool' = False , passphrase : 'str | None' = None , expect_passphrase : 'bool' = True , exclamation_mode : 'bool' = False ) -> 'DeleteResultHandler' Delete the indicated keys. Parameters: Name Type Description Default fingerprints str list[str] The keys to delete. secret bool Whether to delete secret keys. None passphrase str The passphrase to use. None expect_passphrase bool Whether a passphrase is expected. None exclamation_mode bool If specified, a '!' is appended to each fingerprint. This deletes only a subkey or an entire key, depending on what the fingerprint refers to. None View Source def delete_keys ( self , fingerprints : str , * , secret : bool = False , passphrase : str | None = None , expect_passphrase : bool = True , exclamation_mode : bool = False , ) -> DeleteResultHandler : \"\"\" Delete the indicated keys. Args: fingerprints (str|list[str]): The keys to delete. secret (bool): Whether to delete secret keys. passphrase (str): The passphrase to use. expect_passphrase (bool): Whether a passphrase is expected. exclamation_mode (bool): If specified, a `'!'` is appended to each fingerprint. This deletes only a subkey or an entire key, depending on what the fingerprint refers to. .. note:: Passphrases Since GnuPG 2.1, you can't delete secret keys without providing a passphrase. However, if you're expecting the passphrase to go to `gpg` via pinentry, you should specify expect_passphrase=False. (It's only checked for GnuPG >= 2.1). \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ) : # pragma : no cover msg = \"Invalid passphrase\" raise ValueError ( msg ) which = \"key\" if secret : # pragma : no cover if self . version >= ( 2 , 1 ) and passphrase is None and expect_passphrase : msg = \"For GnuPG >= 2.1, deleting secret keys needs a passphrase to be provided\" raise ValueError ( msg ) which = \"secret-key\" fingerprints = list ( fingerprints ) if _is_sequence ( fingerprints ) else [ fingerprints ] if exclamation_mode : fingerprints = [ f + \"!\" for f in fingerprints ] args = [ f\"--delete-{which}\" ] if secret and self . version >= ( 2 , 1 ) : args . insert ( 0 , \"--yes\" ) args . extend ( fingerprints ) result = self . result_map [ \"delete\" ] ( self ) if not secret or self . version < ( 2 , 1 ) : p = self . _open_subprocess ( args ) self . _collect_output ( p , result , stdin = p . stdin ) else : # Need to send in a passphrase . f = _make_binary_stream ( \"\" , self . encoding ) try : self . _handle_io ( args , f , result , passphrase = passphrase , binary = True ) finally : f . close () return result","title":"delete_keys"},{"location":"reference/gnupg/gnupg/#encrypt","text":"def encrypt ( self , data : 'str | bytes' , recipients : 'str | list[str] | tuple[str, str] | None' , ** kwargs : 'str | bool | list[str]' ) -> 'CryptHandler' Encrypt the message contained in the string data for recipients . This method delegates most of the work to encrypt_file() . Parameters: Name Type Description Default data str bytes The data to encrypt. recipients str list[str] A key id of a recipient of the encrypted data, or a list of such key ids. kwargs dict Keyword arguments, which are passed to encrypt_file() : sign (str): If specified, the key id of a signer to sign the encrypted data. always_trust (bool): Whether to always trust keys. passphrase (str): The passphrase to use for a signature. armor (bool): Whether to ASCII-armor the output. output (str): A path to write the encrypted output to. symmetric (bool): Whether to use symmetric encryption, * extra_args (list[str]): A list of additional arguments to pass to gpg . None View Source def encrypt ( self , data : str | bytes , recipients : str | list [ str ] | tuple [ str, str ] | None , ** kwargs : str | bool | list [ str ] , ) -> CryptHandler : \"\"\" Encrypt the message contained in the string *data* for *recipients*. This method delegates most of the work to `encrypt_file()`. Args: data (str|bytes): The data to encrypt. recipients (str|list[str]): A key id of a recipient of the encrypted data, or a list of such key ids. kwargs (dict): Keyword arguments, which are passed to `encrypt_file()`: * sign (str): If specified, the key id of a signer to sign the encrypted data. * always_trust (bool): Whether to always trust keys. * passphrase (str): The passphrase to use for a signature. * armor (bool): Whether to ASCII-armor the output. * output (str): A path to write the encrypted output to. * symmetric (bool): Whether to use symmetric encryption, * extra_args (list[str]): A list of additional arguments to pass to `gpg`. \"\"\" data = _make_binary_stream ( data , self . encoding ) result = self . encrypt_file ( data , recipients , ** kwargs ) data . close () return result","title":"encrypt"},{"location":"reference/gnupg/gnupg/#encrypt_file","text":"def encrypt_file ( self , fileobj_or_path : 'BytesIO | str' , recipients : 'str | list[str] | tuple[str, str] | None' , * , sign : 'str | None' = None , always_trust : 'bool' = False , passphrase : 'str | None' = None , armor : 'bool' = True , output : 'str | None' = None , symmetric : 'bool | str' = False , extra_args : 'list[str] | None' = None ) -> 'CryptHandler' Encrypt data in a file or file-like object. Parameters: Name Type Description Default fileobj_or_path str file A path to a file or a file-like object containing the data to be encrypted. recipients str list A key id of a recipient of the encrypted data, or a list of such key ids. sign str If specified, the key id of a signer to sign the encrypted data. None always_trust bool Whether to always trust keys. None passphrase str The passphrase to use for a signature. None armor bool Whether to ASCII-armor the output. None output str A path to write the encrypted output to. None symmetric bool Whether to use symmetric encryption, None extra_args list[str] A list of additional arguments to pass to gpg . None View Source def encrypt_file ( # noqa : PLR0913 self , fileobj_or_path : BytesIO | str , recipients : str | list [ str ] | tuple [ str, str ] | None , * , sign : str | None = None , always_trust : bool = False , passphrase : str | None = None , armor : bool = True , output : str | None = None , symmetric : bool | str = False , extra_args : list [ str ] | None = None , ) -> CryptHandler : \"\"\" Encrypt data in a file or file-like object. Args: fileobj_or_path (str|file): A path to a file or a file-like object containing the data to be encrypted. recipients (str|list): A key id of a recipient of the encrypted data, or a list of such key ids. sign (str): If specified, the key id of a signer to sign the encrypted data. always_trust (bool): Whether to always trust keys. passphrase (str): The passphrase to use for a signature. armor (bool): Whether to ASCII-armor the output. output (str): A path to write the encrypted output to. symmetric (bool): Whether to use symmetric encryption, extra_args (list[str]): A list of additional arguments to pass to `gpg`. \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ) : msg = \"Invalid passphrase\" raise ValueError ( msg ) args = [ \"--encrypt\" ] if symmetric : # can ' t be False or None - could be True or a cipher algo value # such as AES256 args = [ \"--symmetric\" ] if symmetric is not True : args . extend ( [ \"--cipher-algo\", symmetric ] ) # else use the default , currently CAST5 else : if not recipients : msg = \"No recipients specified with asymmetric encryption\" raise ValueError ( msg ) if not _is_sequence ( recipients ) : recipients = ( recipients ,) for recipient in recipients : args . extend ( [ \"--recipient\", recipient ] ) if armor : # create ascii - armored output - False for binary output args . append ( \"--armor\" ) if output : # pragma : no cover # write the output to a file with the specified name self . set_output_without_confirmation ( args , output ) if sign is True : # pragma : no cover args . append ( \"--sign\" ) elif sign : # pragma : no cover args . extend ( [ \"--sign\", \"--default-key\", sign ] ) if always_trust : # pragma : no cover args . extend ( [ \"--trust-model\", \"always\" ] ) if extra_args : # pragma : no cover args . extend ( extra_args ) result = self . result_map [ \"crypt\" ] ( self ) self . _handle_io ( args , fileobj_or_path , result , passphrase = passphrase , binary = True ) logger . debug ( \"encrypt result[:100]: %r\" , result . data [ :100 ] ) return result","title":"encrypt_file"},{"location":"reference/gnupg/gnupg/#export_keys","text":"def export_keys ( self , keyids : 'str | list[str]' , * , secret : 'bool' = False , armor : 'bool' = True , minimal : 'bool' = False , passphrase : 'str | None' = None , expect_passphrase : 'bool' = True , output : 'None' = None ) -> 'str | bytes' Export the indicated keys. A 'keyid' is anything gpg accepts. Parameters: Name Type Description Default keyids str list[str] A single keyid or a list of them. secret bool Whether to export secret keys. None armor bool Whether to ASCII-armor the output. None minimal bool Whether to pass --export-options export-minimal to gpg . None passphrase str The passphrase to use. None expect_passphrase bool Whether a passphrase is expected. None output str If specified, the path to write the exported key(s) to. None View Source def export_keys ( # noqa: PLR0913 self , keyids : str | list [ str ], * , secret : bool = False , armor : bool = True , minimal : bool = False , passphrase : str | None = None , expect_passphrase : bool = True , output : None = None , ) -> str | bytes : \"\"\" Export the indicated keys. A 'keyid' is anything `gpg` accepts. Args: keyids (str|list[str]): A single keyid or a list of them. secret (bool): Whether to export secret keys. armor (bool): Whether to ASCII-armor the output. minimal (bool): Whether to pass `--export-options export-minimal` to `gpg`. passphrase (str): The passphrase to use. expect_passphrase (bool): Whether a passphrase is expected. output (str): If specified, the path to write the exported key(s) to. .. note:: Passphrases Since GnuPG 2.1, you can't export secret keys without providing a passphrase. However, if you're expecting the passphrase to go to `gpg` via pinentry, you should specify expect_passphrase=False. (It's only checked for GnuPG >= 2.1). \"\"\" if passphrase and not self . is_valid_passphrase ( passphrase ): # pragma: no cover msg = \"Invalid passphrase\" raise ValueError ( msg ) which = \"\" if secret : which = \"-secret-key\" if self . version >= ( 2 , 1 ) and passphrase is None and expect_passphrase : # pragma: no cover msg = \"For GnuPG >= 2.1, exporting secret keys needs a passphrase to be provided\" raise ValueError ( msg ) keyids = list ( keyids ) if _is_sequence ( keyids ) else [ keyids ] args = [ f \"--export{which}\" ] if armor : args . append ( \"--armor\" ) if minimal : # pragma: no cover args . extend ([ \"--export-options\" , \"export-minimal\" ]) if output : # pragma: no cover # write the output to a file with the specified name self . set_output_without_confirmation ( args , output ) args . extend ( keyids ) # gpg --export produces no status-fd output; stdout will be # empty in case of failure result = self . result_map [ \"export\" ]( self ) if not secret or self . version < ( 2 , 1 ): p = self . _open_subprocess ( args ) self . _collect_output ( p , result , stdin = p . stdin ) else : # Need to send in a passphrase. f = _make_binary_stream ( \"\" , self . encoding ) try : self . _handle_io ( args , f , result , passphrase = passphrase , binary = True ) finally : f . close () logger . debug ( \"export_keys result[:100]: %r \" , result . data [: 100 ]) # Issue #49: Return bytes if armor not specified, else text result = result . data if armor : result = result . decode ( self . encoding , self . decode_errors ) return result","title":"export_keys"},{"location":"reference/gnupg/gnupg/#gen_key","text":"def gen_key ( self , key_input : 'str' ) -> 'GenKeyHandler' Generate a key; you might use gen_key_input() to create the input. Parameters: Name Type Description Default key_input str The input to the key creation operation. None View Source def gen_key ( self , key_input : str ) - > GenKeyHandler : \"\"\" Generate a key; you might use `gen_key_input()` to create the input. Args: key_input (str): The input to the key creation operation. \"\"\" args = [ \"--gen-key\" ] result = self . result_map [ \"generate\" ] ( self ) f = _make_binary_stream ( key_input , self . encoding ) self . _handle_io ( args , f , result , binary = True ) f . close () return result","title":"gen_key"},{"location":"reference/gnupg/gnupg/#gen_key_input","text":"def gen_key_input ( self , ** kwargs : 'bool | str | int' ) -> 'str' Generate --gen-key input (see gpg documentation in DETAILS). Parameters: Name Type Description Default kwargs dict A list of keyword arguments. None Returns: Type Description str A string suitable for passing to the gen_key() method. View Source def gen_key_input ( self , ** kwargs : bool | str | int ) -> str : \"\"\" Generate ` -- gen - key ` input ( see ` gpg ` documentation in DETAILS ). Args : kwargs ( dict ) : A list of keyword arguments . Returns : str : A string suitable for passing to the ` gen_key () ` method . \"\"\" parms = {} no_protection = kwargs . pop ( \"no_protection\" , False ) for key , val in [ item for item in kwargs . items () if str ( item [ 1 ]). strip ()] : parms [ key . replace ( \"_\" , \"-\" ). title ()] = val parms . setdefault ( \"Key-Type\" , \"RSA\" ) if \"key_curve\" not in kwargs : parms . setdefault ( \"Key-Length\" , 2048 ) parms . setdefault ( \"Name-Real\" , \"Autogenerated Key\" ) logname = os . environ . get ( \"LOGNAME\" ) or os . environ . get ( \"USERNAME\" ) or \"unspecified\" hostname = socket . gethostname () parms . setdefault ( \"Name-Email\" , \"{}@{}\" . format ( logname . replace ( \" \" , \"_\" ), hostname )) out = \"Key-Type: {} \\n \" . format ( parms . pop ( \"Key-Type\" )) for key , val in list ( parms . items ()) : out += f \"{key}: {val} \\n \" if no_protection : # pragma : no cover out += \"%no-protection \\n \" out += \"%commit \\n \" return out \"\"\" Key - Type : RSA Key - Length : 1024 Name - Real : ISdlink Server on %s Name - Comment : Created by %s Name - Email : isdlink @ %s Expire - Date : 0 %commit Key - Type : DSA Key - Length : 1024 Subkey - Type : ELG - E Subkey - Length : 1024 Name - Real : Joe Tester Name - Comment : with stupid passphrase Name - Email : joe @ foo . bar Expire - Date : 0 Passphrase : abc %pubring foo . pub %secring foo . sec %commit \"\"\" return None","title":"gen_key_input"},{"location":"reference/gnupg/gnupg/#get_recipients","text":"def get_recipients ( self , message : 'str' , ** kwargs : 'list[str]' ) -> 'list[str]' Get the list of recipients for an encrypted message. This method delegates most of the work to get_recipients_file() . Parameters: Name Type Description Default message str bytes The encrypted message. kwargs dict Keyword arguments, which are passed to get_recipients_file() : * extra_args (list[str]): A list of extra arguments to pass to gpg . None View Source def get_recipients ( self , message : str , ** kwargs : list [ str ] ) -> list [ str ] : \"\"\"Get the list of recipients for an encrypted message. This method delegates most of the work to `get_recipients_file()`. Args: message (str|bytes): The encrypted message. kwargs (dict): Keyword arguments, which are passed to `get_recipients_file()`: * extra_args (list[str]): A list of extra arguments to pass to `gpg`. \"\"\" data = _make_binary_stream ( message , self . encoding ) result = self . get_recipients_file ( data , ** kwargs ) data . close () return result","title":"get_recipients"},{"location":"reference/gnupg/gnupg/#get_recipients_file","text":"def get_recipients_file ( self , fileobj_or_path : 'BytesIO | str' , extra_args : 'list[str] | None' = None ) -> 'list[str]' Get the list of recipients for an encrypted message in a file or file-like object. Parameters: Name Type Description Default fileobj_or_path str file A path to a file or file-like object containing the encrypted data. extra_args list[str] A list of extra arguments to pass to gpg . None View Source def get_recipients_file ( self , fileobj_or_path : BytesIO | str , extra_args : list [ str ] | None = None ) -> list [ str ] : \"\"\" Get the list of recipients for an encrypted message in a file or file-like object. Args: fileobj_or_path (str|file): A path to a file or file-like object containing the encrypted data. extra_args (list[str]): A list of extra arguments to pass to `gpg`. \"\"\" args = [ \"--decrypt\", \"--list-only\", \"-v\" ] if extra_args : # pragma : no cover args . extend ( extra_args ) result = self . result_map [ \"crypt\" ] ( self ) self . _handle_io ( args , fileobj_or_path , result , binary = True ) return [ m.group(1) for m in PUBLIC_KEY_RE.finditer(result.stderr) ]","title":"get_recipients_file"},{"location":"reference/gnupg/gnupg/#import_keys","text":"def import_keys ( self , key_data : 'str | bytes' , extra_args : 'None' = None , passphrase : 'None' = None ) -> 'ImportResultHandler' Import the key_data into our keyring. Parameters: Name Type Description Default key_data str bytes The key data to import. passphrase str The passphrase to use. None extra_args list[str] Additional arguments to pass to gpg . None View Source def import_keys ( self , key_data : str | bytes , extra_args : None = None , passphrase : None = None , ) -> ImportResultHandler : \" \"\" Import the key_data into our keyring. Args: key_data (str|bytes): The key data to import. passphrase (str): The passphrase to use. extra_args (list[str]): Additional arguments to pass to `gpg`. \"\" \" result = self . result_map [ \"import\" ] ( self ) logger . debug ( \"import_keys: %r\" , key_data [ : 256 ] ) data = _make_binary_stream ( key_data , self . encoding ) args = [ \"--import\" ] if extra_args : # pragma: no cover args . extend ( extra_args ) self . _handle_io ( args , data , result , passphrase = passphrase , binary = True ) logger . debug ( \"import_keys result: %r\" , result . __dict__ ) data . close () return result","title":"import_keys"},{"location":"reference/gnupg/gnupg/#import_keys_file","text":"def import_keys_file ( self , key_path : 'str' , ** kwargs : 'str | list[str]' ) -> 'ImportResultHandler' Import the key data in key_path into our keyring. Parameters: Name Type Description Default key_path str A path to the key data to be imported. None View Source def import_keys_file ( self , key_path : str , ** kwargs : str | list [ str ] ) -> ImportResultHandler : \"\"\" Import the key data in key_path into our keyring. Args: key_path (str): A path to the key data to be imported. \"\"\" with Path ( key_path ). open ( \"rb\" ) as f : return self . import_keys ( f . read (), ** kwargs )","title":"import_keys_file"},{"location":"reference/gnupg/gnupg/#is_valid_file","text":"def is_valid_file ( self , fileobj : 'str | bytes | BufferedReader | TextIOWrapper | BytesIO' ) -> 'bool' A simplistic check for a file-like object. Parameters: Name Type Description Default fileobj object The object to test. None Returns: Type Description bool True if it's a file-like object, else False . View Source def is_valid_file ( self , fileobj : str | bytes | BufferedReader | TextIOWrapper | BytesIO ) -> bool : \" \"\" A simplistic check for a file-like object. Args: fileobj (object): The object to test. Returns: bool: ``True`` if it's a file-like object, else ``False``. \"\" \" return hasattr ( fileobj , \"read\" )","title":"is_valid_file"},{"location":"reference/gnupg/gnupg/#is_valid_passphrase","text":"def is_valid_passphrase ( self , passphrase : 'str' ) -> 'bool' Confirm that the passphrase doesn't contain newline-type characters - it is passed in a pipe to gpg , and so not checking could lead to spoofing attacks by passing arbitrary text after passphrase and newline. Parameters: Name Type Description Default passphrase str The passphrase to test. None Returns: Type Description bool True if it's a valid passphrase, else False . View Source def is_valid_passphrase ( self , passphrase : str ) -> bool : \" \"\" Confirm that the passphrase doesn't contain newline-type characters - it is passed in a pipe to `gpg`, and so not checking could lead to spoofing attacks by passing arbitrary text after passphrase and newline. Args: passphrase (str): The passphrase to test. Returns: bool: ``True`` if it's a valid passphrase, else ``False``. \"\" \" return \" \\n \" not in passphrase and \" \\r \" not in passphrase and \" \\ x00\" not in passphrase","title":"is_valid_passphrase"},{"location":"reference/gnupg/gnupg/#list_keys","text":"def list_keys ( self , * , secret : 'bool' = False , keys : 'str | list[str] | None' = None , sigs : 'bool' = False ) -> 'ListKeysHandler' List the keys currently in the keyring. Parameters: Name Type Description Default secret bool Whether to list secret keys. None keys str list[str] A list of key ids to match. sigs bool Whether to include signature information. None Returns: Type Description list[dict] A list of dictionaries with key information. View Source def list_keys ( self , * , secret : bool = False , keys : str | list [ str ] | None = None , sigs : bool = False , ) -> ListKeysHandler : \"\"\" List the keys currently in the keyring. Args: secret (bool): Whether to list secret keys. keys (str|list[str]): A list of key ids to match. sigs (bool): Whether to include signature information. Returns: list[dict]: A list of dictionaries with key information. \"\"\" which = \"secret-keys\" if secret else \"sigs\" if sigs else \"keys\" args = [ f\"--list-{which}\", \"--fingerprint\", \"--fingerprint\" ] # get subkey FPs , too if self . version >= ( 2 , 1 ) : args . append ( \"--with-keygrip\" ) if keys : if isinstance ( keys , str ) : keys = [ keys ] args . extend ( keys ) p = self . _open_subprocess ( args ) return self . _get_list_output ( p , \"list\" )","title":"list_keys"},{"location":"reference/gnupg/gnupg/#make_args","text":"def make_args ( self , args : 'list[str]' , * , passphrase : 'bool | None' = False ) -> 'list[str]' Make a list of command line elements for GPG. The value of args will be appended. The passphrase argument needs to be True if a passphrase will be sent to gpg , else False. Parameters: Name Type Description Default args list[str] A list of arguments. None passphrase str The passphrase to use. None View Source def make_args ( self , args : list [ str ] , * , passphrase : bool | None = False ) -> list [ str ] : \" \"\" Make a list of command line elements for GPG. The value of ``args`` will be appended. The ``passphrase`` argument needs to be True if a passphrase will be sent to `gpg`, else False. Args: args (list[str]): A list of arguments. passphrase (str): The passphrase to use. \"\" \" cmd = [ self . gpgbinary , \"--status-fd\" , \"2\" , \"--no-tty\" , \"--no-verbose\" ] if \"DEBUG_IPC\" in os . environ : # pragma: no cover cmd . extend ( [ \"--debug\" , \"ipc\" ] ) if passphrase and hasattr ( self , \"version\" ) and self . version >= ( 2 , 1 ) : cmd [ 1 : 1 ] = [ \"--pinentry-mode\" , \"loopback\" ] cmd . extend ( [ \"--fixed-list-mode\" , \"--batch\" , \"--with-colons\" ] ) if self . gnupghome : cmd . extend ( [ \"--homedir\" , str ( self . gnupghome ) ] ) if self . keyring : cmd . append ( \"--no-default-keyring\" ) for fn in self . keyring : cmd . extend ( [ \"--keyring\" , fn ] ) if self . secret_keyring : # pragma: no cover for fn in self . secret_keyring : cmd . extend ( [ \"--secret-keyring\" , fn ] ) if passphrase : cmd . extend ( [ \"--passphrase-fd\" , \"0\" ] ) if self . use_agent : # pragma: no cover cmd . append ( \"--use-agent\" ) if self . options : cmd . extend ( self . options ) cmd . extend ( args ) return cmd","title":"make_args"},{"location":"reference/gnupg/gnupg/#recv_keys","text":"def recv_keys ( self , keyserver : 'str' , * keyids : 'str' , ** kwargs : 'list[str]' ) -> 'ImportResultHandler' Import one or more keys from a keyserver. Parameters: Name Type Description Default keyserver str The key server hostname. None keyids str A list of key ids to receive. None View Source def recv_keys ( self , keyserver : str , * keyids : str , ** kwargs : list [ str ] ) -> ImportResultHandler : \"\"\" Import one or more keys from a keyserver. Args: keyserver (str): The key server hostname. keyids (str): A list of key ids to receive. \"\"\" result = self . result_map [ \"import\" ] ( self ) logger . debug ( \"recv_keys: %r\" , keyids ) data = _make_binary_stream ( \"\" , self . encoding ) args = [ \"--keyserver\", keyserver ] if \"extra_args\" in kwargs : # pragma : no cover args . extend ( kwargs [ \"extra_args\" ] ) args . append ( \"--recv-keys\" ) args . extend ( list ( keyids )) self . _handle_io ( args , data , result , binary = True ) logger . debug ( \"recv_keys result: %r\" , result . __dict__ ) data . close () return result","title":"recv_keys"},{"location":"reference/gnupg/gnupg/#scan_keys","text":"def scan_keys ( self , filename : 'str' ) -> 'ScanKeysHandler' List details of an ascii armored or binary key file without first importing it to the local keyring. Parameters: Name Type Description Default filename str The path to the file containing the key(s). None View Source def scan_keys ( self , filename : str ) -> ScanKeysHandler : \"\"\" List details of an ascii armored or binary key file without first importing it to the local keyring. Args: filename (str): The path to the file containing the key(s). .. warning:: Warning: Care is needed. The function works on modern GnuPG by running: $ gpg --dry-run --import-options import-show --import filename On older versions, it does the *much* riskier: $ gpg --with-fingerprint --with-colons filename \"\"\" if self . version >= ( 2 , 1 ): args = [ \"--dry-run\" , \"--import-options\" , \"import-show\" , \"--import\" ] else : logger . warning ( \"Trying to list packets, but if the file is not a keyring, might accidentally decrypt\" ) args = [ \"--with-fingerprint\" , \"--with-colons\" , \"--fixed-list-mode\" ] args . append ( filename ) p = self . _open_subprocess ( args ) return self . _get_list_output ( p , \"scan\" )","title":"scan_keys"},{"location":"reference/gnupg/gnupg/#scan_keys_mem","text":"def scan_keys_mem ( self , key_data : 'str' ) -> 'ScanKeysHandler' List details of an ascii armored or binary key without first importing it to the local keyring. Parameters: Name Type Description Default key_data str bytes The key data to import. View Source def scan_keys_mem ( self , key_data : str ) -> ScanKeysHandler : \"\"\" List details of an ascii armored or binary key without first importing it to the local keyring. Args: key_data (str|bytes): The key data to import. .. warning:: Warning: Care is needed. The function works on modern GnuPG by running: $ gpg --dry-run --import-options import-show --import filename On older versions, it does the *much* riskier: $ gpg --with-fingerprint --with-colons filename \"\"\" result = self . result_map [ \"scan\" ]( self ) logger . debug ( \"scan_keys: %r \" , key_data [: 256 ]) data = _make_binary_stream ( key_data , self . encoding ) if self . version >= ( 2 , 1 ): args = [ \"--dry-run\" , \"--import-options\" , \"import-show\" , \"--import\" ] else : logger . warning ( \"Trying to list packets, but if the file is not a keyring, might accidentally decrypt\" ) args = [ \"--with-fingerprint\" , \"--with-colons\" , \"--fixed-list-mode\" ] self . _handle_io ( args , data , result , binary = True ) logger . debug ( \"scan_keys result: %r \" , result . __dict__ ) data . close () return self . _decode_result ( result )","title":"scan_keys_mem"},{"location":"reference/gnupg/gnupg/#search_keys","text":"def search_keys ( self , query : 'str' , keyserver : 'str' = 'pgp.mit.edu' , extra_args : 'list[str] | None' = None ) -> 'StatusHandler' search a keyserver by query (using the --search-keys option). Parameters: Name Type Description Default query str The query to use. None keyserver str The key server hostname. None extra_args list[str] Additional arguments to pass to gpg . None View Source def search_keys ( self , query : str , keyserver : str = \"pgp.mit.edu\" , extra_args : list [ str ] | None = None , ) -> StatusHandler : \"\"\" search a keyserver by query (using the `--search-keys` option). Args: query(str): The query to use. keyserver (str): The key server hostname. extra_args (list[str]): Additional arguments to pass to `gpg`. \"\"\" query = query . strip () if HEX_DIGITS_RE . match ( query ) : query = \"0x\" + query args = [ \"--fingerprint\", \"--keyserver\", keyserver ] if extra_args : # pragma : no cover args . extend ( extra_args ) args . extend ( [ \"--search-keys\", query ] ) p = self . _open_subprocess ( args ) # Get the response information result = self . result_map [ \"search\" ] ( self ) self . _collect_output ( p , result , stdin = p . stdin ) lines = result . data . decode ( self . encoding , self . decode_errors ). splitlines () valid_keywords = [ \"pub\", \"uid\" ] for line in lines : if self . verbose : # pragma : no cover pass logger . debug ( \"line: %r\" , line . rstrip ()) if not line : # sometimes get blank lines on Windows continue fields = line . strip (). split ( \":\" ) if not fields : # pragma : no cover continue keyword = fields [ 0 ] if keyword in valid_keywords : getattr ( result , keyword )( fields ) return result","title":"search_keys"},{"location":"reference/gnupg/gnupg/#send_keys","text":"def send_keys ( self , keyserver : 'str' , * keyids : 'str' , ** kwargs : 'list[str]' ) -> 'StatusHandler' Send one or more keys to a keyserver. Parameters: Name Type Description Default keyserver str The key server hostname. None keyids list[str] A list of key ids to send. None View Source def send_keys ( self , keyserver : str , * keyids : str , ** kwargs : list [ str ] ) -> StatusHandler : # pragma : no cover \"\"\" Send one or more keys to a keyserver. Args: keyserver (str): The key server hostname. keyids (list[str]): A list of key ids to send. \"\"\" # Note : it ' s not practical to test this function without sending # arbitrary data to live keyservers . result = self . result_map [ \"send\" ] ( self ) logger . debug ( \"send_keys: %r\" , keyids ) data = _make_binary_stream ( \"\" , self . encoding ) args = [ \"--keyserver\", keyserver ] if \"extra_args\" in kwargs : args . extend ( kwargs [ \"extra_args\" ] ) args . append ( \"--send-keys\" ) args . extend ( list ( keyids )) self . _handle_io ( args , data , result , binary = True ) logger . debug ( \"send_keys result: %r\" , result . __dict__ ) data . close () return result","title":"send_keys"},{"location":"reference/gnupg/gnupg/#set_output_without_confirmation","text":"def set_output_without_confirmation ( self , args : 'list[str]' , output : 'str' ) -> 'None' If writing to a file which exists, avoid a confirmation message by updating the args value in place to set the output path and avoid any cpmfirmation prompt. Parameters: Name Type Description Default args list[str] A list of arguments. None output str The path to the outpur file. None View Source def set_output_without_confirmation ( self , args : list [ str ] , output : str ) -> None : \"\"\" If writing to a file which exists, avoid a confirmation message by updating the *args* value in place to set the output path and avoid any cpmfirmation prompt. Args: args (list[str]): A list of arguments. output (str): The path to the outpur file. \"\"\" if Path ( output ). exists () : # We need to avoid an overwrite confirmation message args . extend ( [ \"--yes\" ] ) args . extend ( [ \"--output\", output ] )","title":"set_output_without_confirmation"},{"location":"reference/gnupg/gnupg/#sign","text":"def sign ( self , message : 'bytes' , ** kwargs : 'str | bool | list[str]' ) -> 'SignHandler' Sign a message. This method delegates most of the work to the sign_file() method. Parameters: Name Type Description Default message str bytes The data to sign. kwargs dict Keyword arguments, which are passed to sign_file() : keyid (str): The key id of the signer. passphrase (str): The passphrase for the key. clearsign (bool): Whether to use clear signing. detach (bool): Whether to produce a detached signature. binary (bool): Whether to produce a binary signature. output (str): The path to write a detached signature to. * extra_args (list[str]): Additional arguments to pass to gpg . None View Source def sign ( self , message : bytes , ** kwargs : str | bool | list [ str ] ) -> SignHandler : \"\"\" Sign a message. This method delegates most of the work to the `sign_file()` method. Args: message (str|bytes): The data to sign. kwargs (dict): Keyword arguments, which are passed to `sign_file()`: * keyid (str): The key id of the signer. * passphrase (str): The passphrase for the key. * clearsign (bool): Whether to use clear signing. * detach (bool): Whether to produce a detached signature. * binary (bool): Whether to produce a binary signature. * output (str): The path to write a detached signature to. * extra_args (list[str]): Additional arguments to pass to `gpg`. \"\"\" f = _make_binary_stream ( message , self . encoding ) result = self . sign_file ( f , ** kwargs ) f . close () return result","title":"sign"},{"location":"reference/gnupg/gnupg/#sign_file","text":"def sign_file ( self , fileobj_or_path : 'BufferedReader | BytesIO | str' , * , keyid : 'str | None' = None , passphrase : 'str | None' = None , clearsign : 'bool' = True , detach : 'bool' = False , binary : 'bool' = False , output : 'str | None' = None , extra_args : 'None' = None ) -> 'SignHandler' Sign data in a file or file-like object. Parameters: Name Type Description Default fileobj_or_path str file The file or file-like object to sign. keyid str The key id of the signer. None passphrase str The passphrase for the key. None clearsign bool Whether to use clear signing. None detach bool Whether to produce a detached signature. None binary bool Whether to produce a binary signature. None output str The path to write a detached signature to. None extra_args list[str] Additional arguments to pass to gpg . None View Source def sign_file ( # noqa: PLR0913 self , fileobj_or_path : BufferedReader | BytesIO | str , * , keyid : str | None = None , passphrase : str | None = None , clearsign : bool = True , detach : bool = False , binary : bool = False , output : str | None = None , extra_args : None = None , ) -> SignHandler : \" \"\" Sign data in a file or file-like object. Args: fileobj_or_path (str|file): The file or file-like object to sign. keyid (str): The key id of the signer. passphrase (str): The passphrase for the key. clearsign (bool): Whether to use clear signing. detach (bool): Whether to produce a detached signature. binary (bool): Whether to produce a binary signature. output (str): The path to write a detached signature to. extra_args (list[str]): Additional arguments to pass to `gpg`. \"\" \" if passphrase and not self . is_valid_passphrase ( passphrase ) : msg = \"Invalid passphrase\" raise ValueError ( msg ) logger . debug ( \"sign_file: %s\" , fileobj_or_path ) args = [ \"-s\" ] if binary else [ \"-sa\" ] # You can't specify detach-sign and clearsign together: gpg ignores # the detach-sign in that case. if detach : args . append ( \"--detach-sign\" ) elif clearsign : args . append ( \"--clearsign\" ) if keyid : args . extend ( [ \"--default-key\" , keyid ] ) if output : # pragma: no cover # write the output to a file with the specified name self . set _output_without_confirmation ( args , output ) if extra_args : # pragma: no cover args . extend ( extra_args ) result = self . result_map [ \"sign\" ] ( self ) # We could use _handle_io here except for the fact that if the # passphrase is bad, gpg bails and you can't write the message. fileobj = self . _get_fileobj ( fileobj_or_path ) p = self . _open_subprocess ( args , passphrase = passphrase is not None ) try : stdin = p . stdin if passphrase : _write_passphrase ( stdin , passphrase , self . encoding ) writer = _threaded_copy_data ( fileobj , stdin , self . buffer_size ) except OSError : # pragma: no cover logging . exception ( \"error writing message\" ) writer = None finally : if writer : writer . join ( 0.01 ) if fileobj is not fileobj_or_path : fileobj . close () self . _collect_output ( p , result , writer , stdin ) return result","title":"sign_file"},{"location":"reference/gnupg/gnupg/#trust_keys","text":"def trust_keys ( self , fingerprints : 'str | list[str]' , trustlevel : 'str' ) -> 'StatusHandler' Set the trust level for one or more keys. Parameters: Name Type Description Default fingerprints str list[str] A key id for which to set the trust level, or a list of such key ids. trustlevel str The trust level. This is one of the following. 'TRUST_EXPIRED' 'TRUST_UNDEFINED' 'TRUST_NEVER' 'TRUST_MARGINAL' 'TRUST_FULLY' 'TRUST_ULTIMATE' None View Source def trust_keys ( self , fingerprints : str | list [ str ] , trustlevel : str ) -> StatusHandler : \"\"\" Set the trust level for one or more keys. Args: fingerprints (str|list[str]): A key id for which to set the trust level, or a list of such key ids. trustlevel (str): The trust level. This is one of the following. * ``'TRUST_EXPIRED'`` * ``'TRUST_UNDEFINED'`` * ``'TRUST_NEVER'`` * ``'TRUST_MARGINAL'`` * ``'TRUST_FULLY'`` * ``'TRUST_ULTIMATE'`` \"\"\" levels = VerifyHandler . TRUST_LEVELS if trustlevel not in levels : poss = \", \" . join ( sorted ( levels )) msg = f 'Invalid trust level: \"{trustlevel}\" (must be one of {poss})' raise ValueError ( msg ) trustlevel = levels [ trustlevel ] + 1 import tempfile try : fd , fn = tempfile . mkstemp ( prefix = \"pygpg-\" ) if isinstance ( fingerprints , str ) : fingerprints = [ fingerprints ] lines = [ f\"{f}:{trustlevel}:\" for f in fingerprints ] # The trailing newline is required ! s = os . linesep . join ( lines ) + os . linesep logger . debug ( \"writing ownertrust info: %s\" , s ) os . write ( fd , s . encode ( self . encoding )) os . close ( fd ) result = self . result_map [ \"trust\" ] ( self ) p = self . _open_subprocess ( [ \"--import-ownertrust\", fn ] ) self . _collect_output ( p , result , stdin = p . stdin ) if p . returncode != 0 : raise ValueError ( \"gpg returned an error - return code %d\" % p . returncode ) finally : Path ( fn ). unlink () return result","title":"trust_keys"},{"location":"reference/gnupg/gnupg/#verify","text":"def verify ( self , data : 'bytes' , ** kwargs : 'str | bool | list[str] | IO' ) -> 'VerifyHandler' Verify the signature on the contents of the string data . This method delegates most of the work to verify_file() . Parameters: Name Type Description Default data str bytes The data to verify. kwargs dict Keyword arguments, which are passed to verify_file() : * fileobj_or_path (str file): A path to a signature, or a file-like object containing one. data_filename (str): If the signature is a detached one, the path to the data that was signed. close_file (bool): If a file-like object is passed in, whether to close it. * extra_args (list[str]): Additional arguments to pass to gpg . View Source def verify ( self , data : bytes , ** kwargs : str | bool | list [ str ] | IO ) -> VerifyHandler : \"\"\" Verify the signature on the contents of the string *data*. This method delegates most of the work to `verify_file()`. Args: data (str|bytes): The data to verify. kwargs (dict): Keyword arguments, which are passed to `verify_file()`: * fileobj_or_path (str|file): A path to a signature, or a file-like object containing one. * data_filename (str): If the signature is a detached one, the path to the data that was signed. * close_file (bool): If a file-like object is passed in, whether to close it. * extra_args (list[str]): Additional arguments to pass to `gpg`. \"\"\" f = _make_binary_stream ( data , self . encoding ) result = self . verify_file ( f , ** kwargs ) f . close () return result","title":"verify"},{"location":"reference/gnupg/gnupg/#verify_data","text":"def verify_data ( self , sig_filename : 'str' , data : 'bytes' , extra_args : 'None' = None ) -> 'VerifyHandler' Verify the signature in sig_filename against data in memory Parameters: Name Type Description Default sig_filename str The path to a signature. None data str bytes The data to be verified. extra_args list[str] Additional arguments to pass to gpg . None View Source def verify_data ( self , sig_filename : str , data : bytes , extra_args : None = None ) -> VerifyHandler : \" \"\" Verify the signature in sig_filename against data in memory Args: sig_filename (str): The path to a signature. data (str|bytes): The data to be verified. extra_args (list[str]): Additional arguments to pass to `gpg`. \"\" \" logger . debug ( \"verify_data: %r, %r ...\" , sig_filename , data [ : 16 ] ) result = self . result_map [ \"verify\" ] ( self ) args = [ \"--verify\" ] if extra_args : # pragma: no cover args . extend ( extra_args ) args . extend ( [ sig_filename , \"-\" ] ) stream = BytesIO ( data ) self . _handle_io ( args , stream , result , binary = True ) return result","title":"verify_data"},{"location":"reference/gnupg/gnupg/#verify_file","text":"def verify_file ( self , fileobj_or_path : 'BytesIO | str' , * , data_filename : 'str | None' = None , close_file : 'bool' = True , extra_args : 'None' = None ) -> 'VerifyHandler' Verify a signature. Parameters: Name Type Description Default fileobj_or_path str file A path to a signature, or a file-like object containing one. data_filename str If the signature is a detached one, the path to the data that was signed. None close_file bool If a file-like object is passed in, whether to close it. None extra_args list[str] Additional arguments to pass to gpg . None View Source def verify_file ( self , fileobj_or_path : BytesIO | str , * , data_filename : str | None = None , close_file : bool = True , extra_args : None = None , ) -> VerifyHandler : \" \"\" Verify a signature. Args: fileobj_or_path (str|file): A path to a signature, or a file-like object containing one. data_filename (str): If the signature is a detached one, the path to the data that was signed. close_file (bool): If a file-like object is passed in, whether to close it. extra_args (list[str]): Additional arguments to pass to `gpg`. \"\" \" logger . debug ( \"verify_file: %r, %r\" , fileobj_or_path , data_filename ) result = self . result_map [ \"verify\" ] ( self ) args = [ \"--verify\" ] if extra_args : # pragma: no cover args . extend ( extra_args ) if data_filename is None : self . _handle_io ( args , fileobj_or_path , result , binary = True ) else : logger . debug ( \"Handling detached verification\" ) import tempfile fd , fn = tempfile . mkstemp ( prefix = \"pygpg-\" ) s = fileobj_or_path . read () if close_file : fileobj_or_path . close () logger . debug ( \"Wrote to temp file: %r\" , s ) os . write ( fd , s ) os . close ( fd ) args . append ( fn ) args . append ( data_filename ) try : p = self . _open_subprocess ( args ) self . _collect_output ( p , result , stdin = p . stdin ) finally : Path ( fn ). unlink () return result","title":"verify_file"},{"location":"reference/gnupg/helper/","text":"Module gnupg.helper View Source from __future__ import annotations import logging import sys import threading from io import BufferedReader , BufferedWriter , BytesIO , TextIOWrapper def _get_logger ( name : str ) -> logging . Logger : logger = logging . getLogger ( name ) if not logger . handlers : logger . addHandler ( logging . NullHandler ()) return logger logger = _get_logger ( __name__ ) def _make_binary_stream ( s : str | bytes , encoding : str ) -> BytesIO : if isinstance ( s , str ): s = s . encode ( encoding ) return BytesIO ( s ) def _is_sequence ( instance : tuple [ str , str ] | list [ str ] | str ) -> bool : return isinstance ( instance , ( list , tuple , set , frozenset )) def _write_passphrase ( stream : BufferedWriter , passphrase : str , encoding : str ) -> None : passphrase = f \" { passphrase } \\n \" passphrase = passphrase . encode ( encoding ) stream . write ( passphrase ) logger . debug ( \"Wrote passphrase\" ) def _threaded_copy_data ( instream : BufferedReader | BytesIO | TextIOWrapper , outstream : BufferedWriter , buffer_size : int , ) -> threading . Thread : def copy_data ( instream : BufferedReader | BytesIO | TextIOWrapper , outstream : BufferedWriter , buffer_size : int , ) -> None : # Copy one stream to another assert buffer_size > 0 # noqa: S101 sent = 0 enc = sys . stdin . encoding if hasattr ( sys . stdin , \"encoding\" ) else \"ascii\" while True : # See issue #39: read can fail when e.g. a text stream is provided # for what is actually a binary file try : data = instream . read ( buffer_size ) except ( UnicodeError , Exception ): # pragma: no cover logger . warning ( \"Exception occurred while reading\" , exc_info = 1 ) break if not data : break sent += len ( data ) logger . debug ( \"sending chunk ( %d ): %r \" , sent , data [: 256 ]) try : outstream . write ( data ) except UnicodeError : # pragma: no cover outstream . write ( data . encode ( enc )) except ( BrokenPipeError , Exception ): # pragma: no cover # Can sometimes get 'broken pipe' errors even when the data has all # been sent logger . exception ( \"Error sending data\" ) break try : outstream . close () except OSError : # pragma: no cover logger . warning ( \"Exception occurred while closing: ignored\" , exc_info = 1 ) logger . debug ( \"closed output, %d bytes sent\" , sent ) assert buffer_size > 0 # noqa: S101 wr = threading . Thread ( target = copy_data , args = ( instream , outstream , buffer_size )) wr . daemon = True logger . debug ( \"data copier: %r , %r , %r \" , wr , instream , outstream ) wr . start () return wr Variables logger","title":"Helper"},{"location":"reference/gnupg/helper/#module-gnupghelper","text":"View Source from __future__ import annotations import logging import sys import threading from io import BufferedReader , BufferedWriter , BytesIO , TextIOWrapper def _get_logger ( name : str ) -> logging . Logger : logger = logging . getLogger ( name ) if not logger . handlers : logger . addHandler ( logging . NullHandler ()) return logger logger = _get_logger ( __name__ ) def _make_binary_stream ( s : str | bytes , encoding : str ) -> BytesIO : if isinstance ( s , str ): s = s . encode ( encoding ) return BytesIO ( s ) def _is_sequence ( instance : tuple [ str , str ] | list [ str ] | str ) -> bool : return isinstance ( instance , ( list , tuple , set , frozenset )) def _write_passphrase ( stream : BufferedWriter , passphrase : str , encoding : str ) -> None : passphrase = f \" { passphrase } \\n \" passphrase = passphrase . encode ( encoding ) stream . write ( passphrase ) logger . debug ( \"Wrote passphrase\" ) def _threaded_copy_data ( instream : BufferedReader | BytesIO | TextIOWrapper , outstream : BufferedWriter , buffer_size : int , ) -> threading . Thread : def copy_data ( instream : BufferedReader | BytesIO | TextIOWrapper , outstream : BufferedWriter , buffer_size : int , ) -> None : # Copy one stream to another assert buffer_size > 0 # noqa: S101 sent = 0 enc = sys . stdin . encoding if hasattr ( sys . stdin , \"encoding\" ) else \"ascii\" while True : # See issue #39: read can fail when e.g. a text stream is provided # for what is actually a binary file try : data = instream . read ( buffer_size ) except ( UnicodeError , Exception ): # pragma: no cover logger . warning ( \"Exception occurred while reading\" , exc_info = 1 ) break if not data : break sent += len ( data ) logger . debug ( \"sending chunk ( %d ): %r \" , sent , data [: 256 ]) try : outstream . write ( data ) except UnicodeError : # pragma: no cover outstream . write ( data . encode ( enc )) except ( BrokenPipeError , Exception ): # pragma: no cover # Can sometimes get 'broken pipe' errors even when the data has all # been sent logger . exception ( \"Error sending data\" ) break try : outstream . close () except OSError : # pragma: no cover logger . warning ( \"Exception occurred while closing: ignored\" , exc_info = 1 ) logger . debug ( \"closed output, %d bytes sent\" , sent ) assert buffer_size > 0 # noqa: S101 wr = threading . Thread ( target = copy_data , args = ( instream , outstream , buffer_size )) wr . daemon = True logger . debug ( \"data copier: %r , %r , %r \" , wr , instream , outstream ) wr . start () return wr","title":"Module gnupg.helper"},{"location":"reference/gnupg/helper/#variables","text":"logger","title":"Variables"},{"location":"reference/gnupg/handlers/","text":"Module gnupg.handlers View Source from __future__ import annotations from .add_subkey_handler import AddSubkeyHandler from .auto_locate_key_handler import AutoLocateKeyHandler from .crypt_handler import CryptHandler from .delete_result_handler import DeleteResultHandler from .export_result_handler import ExportResultHandler from .gen_key_handler import GenKeyHandler from .import_result_handler import ImportResultHandler from .list_keys_handler import ListKeysHandler from .scan_keys_handler import ScanKeysHandler from .search_keys_handler import SearchKeysHandler from .send_result_handler import SendResultHandler from .sign_handler import SignHandler from .status_handler import StatusHandler from .trust_result_handler import TrustResultHandler from .verify_handler import VerifyHandler __all__ = ( \"AddSubkeyHandler\" , \"AutoLocateKeyHandler\" , \"CryptHandler\" , \"DeleteResultHandler\" , \"ExportResultHandler\" , \"GenKeyHandler\" , \"ImportResultHandler\" , \"ListKeysHandler\" , \"ScanKeysHandler\" , \"SearchKeysHandler\" , \"SendResultHandler\" , \"SignHandler\" , \"StatusHandler\" , \"TrustResultHandler\" , \"VerifyHandler\" , ) Sub-modules gnupg.handlers.add_subkey_handler gnupg.handlers.auto_locate_key_handler gnupg.handlers.crypt_handler gnupg.handlers.delete_result_handler gnupg.handlers.export_result_handler gnupg.handlers.gen_key_handler gnupg.handlers.helper gnupg.handlers.import_result_handler gnupg.handlers.list_keys_handler gnupg.handlers.scan_keys_handler gnupg.handlers.search_keys_handler gnupg.handlers.send_result_handler gnupg.handlers.sign_handler gnupg.handlers.status_handler gnupg.handlers.text_handler gnupg.handlers.trust_result_handler gnupg.handlers.verify_handler Classes AddSubkeyHandler class AddSubkeyHandler ( gpg : 'GPG' ) This class handles status messages during subkey addition. View Source class AddSubkeyHandler ( StatusHandler ): \"\"\" This class handles status messages during subkey addition. \"\"\" returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . type = None self . fingerprint = \"\" self . status = None def __nonzero__ ( self ) -> bool : # pragma : no cover return bool ( self . fingerprint ) __bool__ = __nonzero__ def __str__ ( self ) -> str : return self . fingerprint def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ): # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key == \"KEY_CREATED\" : ( self . type , self . fingerprint ) = value . split () self . status = \"ok\" else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value ) Ancestors (in MRO) gnupg.handlers.StatusHandler Class variables returncode Methods handle_status def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ): # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key == \"KEY_CREATED\" : ( self . type , self . fingerprint ) = value . split () self . status = \"ok\" else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value ) AutoLocateKeyHandler class AutoLocateKeyHandler ( gpg : 'GPG' ) This class handles status messages during key auto-locating. fingerprint: str key_length: int created_at: date email: str email_real_name: str View Source class AutoLocateKeyHandler ( StatusHandler ) : \"\"\" This class handles status messages during key auto-locating. fingerprint: str key_length: int created_at: date email: str email_real_name: str \"\"\" def __ init__ ( self , gpg : GPG ) -> None : StatusHandler . __ init__ ( self , gpg ) self . fingerprint = None self . type = None self . created_at = None self . email = None self . email_real_name = None def handle_status ( self , key : str , val ue : str ) -> None : if key == \"IMPORTED\" : _ , email , display_name = val ue . split () self . email = email self . email_real_name = display_name [ 1 :- 1 ] elif key == \"KEY_CONSIDERED\" : self . fingerprint = val ue . strip (). split ()[ 0 ] def pub ( self , args : list [ str ]) -> None : \"\"\" Internal method to handle the 'pub' status message. `pub` message contains the fingerprint of the public key, its type and its creation date. \"\"\" def uid ( self , args : list [ str ]) -> None : local_tz = datetime . now (). astimezone (). tzinfo self . created_at = datetime . fromtimestamp ( int ( args [ 5 ]), tz = local_tz ) raw_email_content = args [ 9 ] email , real_name = parseaddr ( raw_email_content ) self . email = email self . email_real_name = real_name def sub ( self , args : list [ str ]) -> None : self . key_length = int ( args [ 2 ]) def fpr ( self , args : list [ str ]) -> None : # Only store the first fingerprint self . fingerprint = self . fingerprint or args [ 9 ] Ancestors (in MRO) gnupg.handlers.StatusHandler Methods fpr def fpr ( self , args : 'list[str]' ) -> 'None' View Source def fpr ( self , args : list [ str ] ) -> None : # Only store the first fingerprint self . fingerprint = self . fingerprint or args [ 9 ] handle_status def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , val ue : str ) -> None : if key == \"IMPORTED\" : _ , email , display_name = val ue . split () self . email = email self . email_real_name = display_name [ 1 :- 1 ] elif key == \"KEY_CONSIDERED\" : self . fingerprint = val ue . strip (). split ()[ 0 ] pub def pub ( self , args : 'list[str]' ) -> 'None' Internal method to handle the 'pub' status message. pub message contains the fingerprint of the public key, its type and its creation date. View Source def pub ( self , args : list [ str ]) -> None : \"\"\" Internal method to handle the 'pub' status message. `pub` message contains the fingerprint of the public key, its type and its creation date. \"\"\" sub def sub ( self , args : 'list[str]' ) -> 'None' View Source def sub ( self , args : list [ str ] ) -> None : self . key_length = int ( args [ 2 ] ) uid def uid ( self , args : 'list[str]' ) -> 'None' View Source def uid ( self , args : list [ str ] ) -> None : local_tz = datetime . now (). astimezone (). tzinfo self . created_at = datetime . fromtimestamp ( int ( args [ 5 ] ), tz = local_tz ) raw_email_content = args [ 9 ] email , real_name = parseaddr ( raw_email_content ) self . email = email self . email_real_name = real_name CryptHandler class CryptHandler ( gpg : 'GPG' ) This class handles status messages during encryption and decryption. View Source class CryptHandler ( VerifyHandler , TextHandler ): \"\"\" This class handles status messages during encryption and decryption. \"\"\" def __init__ ( self , gpg : GPG ) -> None : VerifyHandler . __init__ ( self , gpg ) self . data = \"\" self . ok = False self . status = \"\" self . status_detail = \"\" self . key_id = None def __nonzero__ ( self ) -> bool : return bool ( self . ok ) __bool__ = __nonzero__ def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ): logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key == \"NODATA\" : if self . status not in ( \"decryption failed\" ,): self . status = \"no data was provided\" elif key in ( \"NEED_PASSPHRASE\" , \"BAD_PASSPHRASE\" , \"GOOD_PASSPHRASE\" , \"MISSING_PASSPHRASE\" , \"KEY_NOT_CREATED\" , \"NEED_PASSPHRASE_PIN\" , ): # pragma : no cover self . status = key . replace ( \"_\" , \" \" ). lower () elif key == \"DECRYPTION_FAILED\" : # pragma : no cover if self . status != \"no secret key\" : # don ' t overwrite more useful message self . status = \"decryption failed\" elif key == \"NEED_PASSPHRASE_SYM\" : self . status = \"need symmetric passphrase\" elif key == \"BEGIN_DECRYPTION\" : if self . status != \"no secret key\" : # don ' t overwrite more useful message self . status = \"decryption incomplete\" elif key == \"BEGIN_ENCRYPTION\" : self . status = \"encryption incomplete\" elif key == \"DECRYPTION_OKAY\" : self . status = \"decryption ok\" self . ok = True elif key == \"END_ENCRYPTION\" : self . status = \"encryption ok\" self . ok = True elif key == \"INV_RECP\" : # pragma : no cover if not self . status : self . status = \"invalid recipient\" else : self . status = f \"invalid recipient: {self.status}\" self . status_detail = _determine_invalid_recipient_or_signer ( value ) elif key == \"KEYEXPIRED\" : # pragma : no cover self . status = \"key expired\" elif key == \"SIG_CREATED\" : # pragma : no cover self . status = \"sig created\" elif key == \"SIGEXPIRED\" : # pragma : no cover self . status = \"sig expired\" elif key == \"ENC_TO\" : # pragma : no cover # ENC_TO < long_keyid > < keytype > < keylength > self . key_id = value . split ( \" \" , 1 )[ 0 ] elif key in ( \"USERID_HINT\" , \"GOODMDC\" , \"END_DECRYPTION\" , \"CARDCTRL\" , \"BADMDC\" , \"SC_OP_FAILURE\" , \"SC_OP_SUCCESS\" , \"PINENTRY_LAUNCHED\" , ): pass else : VerifyHandler . handle_status ( self , key , value ) Ancestors (in MRO) gnupg.handlers.VerifyHandler gnupg.handlers.StatusHandler gnupg.handlers.text_handler.TextHandler Class variables GPG_ERROR_CODES GPG_SYSTEM_ERROR_CODES TRUST_EXPIRED TRUST_FULLY TRUST_LEVELS TRUST_MARGINAL TRUST_NEVER TRUST_ULTIMATE TRUST_UNDEFINED returncode Methods handle_status def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ): logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key == \"NODATA\" : if self . status not in ( \"decryption failed\" ,): self . status = \"no data was provided\" elif key in ( \"NEED_PASSPHRASE\" , \"BAD_PASSPHRASE\" , \"GOOD_PASSPHRASE\" , \"MISSING_PASSPHRASE\" , \"KEY_NOT_CREATED\" , \"NEED_PASSPHRASE_PIN\" , ): # pragma : no cover self . status = key . replace ( \"_\" , \" \" ). lower () elif key == \"DECRYPTION_FAILED\" : # pragma : no cover if self . status != \"no secret key\" : # don ' t overwrite more useful message self . status = \"decryption failed\" elif key == \"NEED_PASSPHRASE_SYM\" : self . status = \"need symmetric passphrase\" elif key == \"BEGIN_DECRYPTION\" : if self . status != \"no secret key\" : # don ' t overwrite more useful message self . status = \"decryption incomplete\" elif key == \"BEGIN_ENCRYPTION\" : self . status = \"encryption incomplete\" elif key == \"DECRYPTION_OKAY\" : self . status = \"decryption ok\" self . ok = True elif key == \"END_ENCRYPTION\" : self . status = \"encryption ok\" self . ok = True elif key == \"INV_RECP\" : # pragma : no cover if not self . status : self . status = \"invalid recipient\" else : self . status = f \"invalid recipient: {self.status}\" self . status_detail = _determine_invalid_recipient_or_signer ( value ) elif key == \"KEYEXPIRED\" : # pragma : no cover self . status = \"key expired\" elif key == \"SIG_CREATED\" : # pragma : no cover self . status = \"sig created\" elif key == \"SIGEXPIRED\" : # pragma : no cover self . status = \"sig expired\" elif key == \"ENC_TO\" : # pragma : no cover # ENC_TO < long_keyid > < keytype > < keylength > self . key_id = value . split ( \" \" , 1 )[ 0 ] elif key in ( \"USERID_HINT\" , \"GOODMDC\" , \"END_DECRYPTION\" , \"CARDCTRL\" , \"BADMDC\" , \"SC_OP_FAILURE\" , \"SC_OP_SUCCESS\" , \"PINENTRY_LAUNCHED\" , ): pass else : VerifyHandler . handle_status ( self , key , value ) DeleteResultHandler class DeleteResultHandler ( gpg : 'GPG' ) This class handles status messages during key deletion. View Source class DeleteResultHandler ( StatusHandler ): \"\"\" This class handles status messages during key deletion. \"\"\" returncode = None def __init__ ( self , gpg: GPG ) -> None: StatusHandler . __init__ ( self , gpg ) self . status = \"ok\" def __str__ ( self ) -> str: return self . status problem_reason = MappingProxyType ( { \"1\" : \"No such key\" , \"2\" : \"Must delete secret key first\" , \"3\" : \"Ambiguous specification\" , }, ) def handle_status ( self , key: str , value: str ) -> None: if key == \"DELETE_PROBLEM\" : # pragma: no cover self . status = self . problem_reason . get ( value , f \"Unknown error: {value!r}\" ) else: # pragma: no cover logger . debug ( \"message ignored: %s, %s\" , key , value ) def __nonzero__ ( self ) -> bool: # pragma: no cover return self . status == \"ok\" __bool__ = __nonzero__ Ancestors (in MRO) gnupg.handlers.StatusHandler Descendants gnupg.handlers.TrustResultHandler Class variables problem_reason returncode Methods handle_status def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : if key == \"DELETE_PROBLEM\" : # pragma : no cover self . status = self . problem_reason . get ( value , f \"Unknown error: {value!r}\" ) else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value ) ExportResultHandler class ExportResultHandler ( gpg : 'GPG' ) This class handles status messages during key export. View Source class ExportResultHandler ( GenKeyHandler ): \"\"\" This class handles status messages during key export. \"\"\" # For now, just use an existing class to base it on - if needed, we # can override handle_status for more specific message handling. def handle_status ( self , key : str , value : str ) -> None : if key in ( \"EXPORTED\" , \"EXPORT_RES\" ): pass else : super () . handle_status ( key , value ) Ancestors (in MRO) gnupg.handlers.GenKeyHandler gnupg.handlers.StatusHandler Class variables returncode Methods handle_status def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : if key in ( \"EXPORTED\" , \"EXPORT_RES\" ) : pass else : super (). handle_status ( key , value ) GenKeyHandler class GenKeyHandler ( gpg : 'GPG' ) This class handles status messages during key generation. View Source class GenKeyHandler ( StatusHandler ): \"\"\" This class handles status messages during key generation. \"\"\" returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . type = None self . fingerprint = \"\" self . status = None def __nonzero__ ( self ) -> bool : # pragma : no cover return bool ( self . fingerprint ) __bool__ = __nonzero__ def __str__ ( self ) -> str : # pragma : no cover return self . fingerprint def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ): # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key == \"KEY_CREATED\" : parts = value . split () ( self . type , self . fingerprint ) = parts [: 2 ] self . status = \"ok\" elif key == \"KEY_NOT_CREATED\" : self . status = key . replace ( \"_\" , \" \" ). lower () elif key in ( \"PROGRESS\" , \"GOOD_PASSPHRASE\" ): # pragma : no cover pass else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value ) Ancestors (in MRO) gnupg.handlers.StatusHandler Descendants gnupg.handlers.ExportResultHandler Class variables returncode Methods handle_status def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ): # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key == \"KEY_CREATED\" : parts = value . split () ( self . type , self . fingerprint ) = parts [: 2 ] self . status = \"ok\" elif key == \"KEY_NOT_CREATED\" : self . status = key . replace ( \"_\" , \" \" ). lower () elif key in ( \"PROGRESS\" , \"GOOD_PASSPHRASE\" ): # pragma : no cover pass else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value ) ImportResultHandler class ImportResultHandler ( gpg : 'GPG' ) This class handles status messages during key import. View Source class ImportResultHandler ( StatusHandler ) : \"\"\" This class handles status messages during key import. \"\"\" counts = \"\"\"count no_user_id imported imported_rsa unchanged n_uids n_subk n_sigs n_revoc sec_read sec_imported sec_dups not_imported\"\"\" . split () returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . results = [] self . fingerprints = [] for result in self . counts : setattr ( self , result , 0 ) def __nonzero__ ( self ) -> bool : return bool ( not self . not_imported and self . fingerprints ) __bool__ = __nonzero__ ok_reason = MappingProxyType ( { \"0\" : \"Not actually changed\" , \"1\" : \"Entirely new key\" , \"2\" : \"New user IDs\" , \"4\" : \"New signatures\" , \"8\" : \"New subkeys\" , \"16\" : \"Contains private key\" , } , ) problem_reason = MappingProxyType ( { \"0\" : \"No specific reason given\" , \"1\" : \"Invalid Certificate\" , \"2\" : \"Issuer Certificate missing\" , \"3\" : \"Certificate Chain too long\" , \"4\" : \"Error storing certificate\" , } , ) def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ) : # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key in ( \"IMPORTED\" , \"KEY_CONSIDERED\" ) : # this duplicates info we already see in import_ok & import_problem pass elif key == \"NODATA\" : # pragma : no cover self . results . append ( { \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"No valid data found\" } ) elif key == \"IMPORT_OK\" : reason , fingerprint = value . split () reasons = [] for code , text in list ( self . ok_reason . items ()) : if int ( reason ) | int ( code ) == int ( reason ) : reasons . append ( text ) reasontext = \"\\n\" . join ( reasons ) + \"\\n\" self . results . append ( { \"fingerprint\" : fingerprint , \"ok\" : reason , \"text\" : reasontext } ) self . fingerprints . append ( fingerprint ) elif key == \"IMPORT_PROBLEM\" : # pragma : no cover try : reason , fingerprint = value . split () except ( AttributeError , Exception ) : reason = value fingerprint = \"<unknown>\" self . results . append ( { \"fingerprint\" : fingerprint , \"problem\" : reason , \"text\" : self . problem_reason [ reason ] } ) elif key == \"IMPORT_RES\" : import_res = value . split () for i , count in enumerate ( self . counts ) : setattr ( self , count , int ( import_res [ i ] )) elif key == \"KEYEXPIRED\" : # pragma : no cover self . results . append ( { \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"Key expired\" } ) elif key == \"SIGEXPIRED\" : # pragma : no cover self . results . append ( { \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"Signature expired\" } ) elif key == \"FAILURE\" : # pragma : no cover self . results . append ( { \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"Other failure\" } ) else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value ) def summary ( self ) -> str : \"\"\" Return a summary indicating how many keys were imported and how many were not imported. \"\"\" result = [] result . append ( \"%d imported\" % self . imported ) if self . not_imported : # pragma : no cover result . append ( \"%d not imported\" % self . not_imported ) return \", \" . join ( result ) Ancestors (in MRO) gnupg.handlers.StatusHandler Class variables counts ok_reason problem_reason returncode Methods handle_status def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ) : # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key in ( \"IMPORTED\" , \"KEY_CONSIDERED\" ) : # this duplicates info we already see in import_ok & import_problem pass elif key == \"NODATA\" : # pragma : no cover self . results . append ( { \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"No valid data found\" } ) elif key == \"IMPORT_OK\" : reason , fingerprint = value . split () reasons = [] for code , text in list ( self . ok_reason . items ()) : if int ( reason ) | int ( code ) == int ( reason ) : reasons . append ( text ) reasontext = \"\\n\" . join ( reasons ) + \"\\n\" self . results . append ( { \"fingerprint\" : fingerprint , \"ok\" : reason , \"text\" : reasontext } ) self . fingerprints . append ( fingerprint ) elif key == \"IMPORT_PROBLEM\" : # pragma : no cover try : reason , fingerprint = value . split () except ( AttributeError , Exception ) : reason = value fingerprint = \"<unknown>\" self . results . append ( { \"fingerprint\" : fingerprint , \"problem\" : reason , \"text\" : self . problem_reason [ reason ] } ) elif key == \"IMPORT_RES\" : import_res = value . split () for i , count in enumerate ( self . counts ) : setattr ( self , count , int ( import_res [ i ] )) elif key == \"KEYEXPIRED\" : # pragma : no cover self . results . append ( { \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"Key expired\" } ) elif key == \"SIGEXPIRED\" : # pragma : no cover self . results . append ( { \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"Signature expired\" } ) elif key == \"FAILURE\" : # pragma : no cover self . results . append ( { \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"Other failure\" } ) else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value ) summary def summary ( self ) -> 'str' Return a summary indicating how many keys were imported and how many were not imported. View Source def summary ( self ) -> str : \"\"\" Return a summary indicating how many keys were imported and how many were not imported. \"\"\" result = [] result . append ( \"%d imported\" % self . imported ) if self . not_imported : # pragma : no cover result . append ( \"%d not imported\" % self . not_imported ) return \", \" . join ( result ) ListKeysHandler class ListKeysHandler ( gpg : 'GPG' ) This class handles status messages during listing keys and signatures. Handle pub and uid (relating the latter to the former). We don't care about (info from GnuPG DETAILS file): crt = X.509 certificate crs = X.509 certificate and private key available uat = user attribute (same as user id except for field 10). sig = signature rev = revocation signature pkd = public key data (special field format, see below) grp = reserved for gpgsm rvk = revocation key View Source class ListKeysHandler ( SearchKeysHandler ) : \"\"\" This class handles status messages during listing keys and signatures. Handle pub and uid (relating the latter to the former). We don't care about (info from GnuPG DETAILS file): crt = X.509 certificate crs = X.509 certificate and private key available uat = user attribute (same as user id except for field 10). sig = signature rev = revocation signature pkd = public key data (special field format, see below) grp = reserved for gpgsm rvk = revocation key \"\"\" UID_INDEX = 9 FIELDS = ( \"type trust length algo keyid date expires dummy ownertrust uid sig\" \" cap issuer flag token hash curve compliance updated origin keygrip\" ). split () def __init__ ( self , gpg : GPG ) -> None : super (). __init__ ( gpg ) self . in_subkey = False self . key_map = {} def key ( self , args : list [ str ] ) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" self . curkey = curkey = self . get_fields ( args ) if curkey [ \"uid\" ] : # pragma : no cover curkey [ \"uids\" ] . append ( curkey [ \"uid\" ] ) del curkey [ \"uid\" ] curkey [ \"subkeys\" ] = [] self . append ( curkey ) self . in_subkey = False pub = sec = key def fpr ( self , args : list [ str ] ) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" fp = args [ 9 ] if fp in self . key_map and self . gpg . check_fingerprint_collisions : # pragma : no cover msg = f \"Unexpected fingerprint collision: {fp}\" raise ValueError ( msg ) if not self . in_subkey : self . curkey [ \"fingerprint\" ] = fp self . fingerprints . append ( fp ) self . key_map [ fp ] = self . curkey else : self . curkey [ \"subkeys\" ][ -1 ][ 2 ] = fp self . key_map [ fp ] = self . curkey def grp ( self , args : list [ str ] ) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" grp = args [ 9 ] if not self . in_subkey : self . curkey [ \"keygrip\" ] = grp else : self . curkey [ \"subkeys\" ][ -1 ][ 3 ] = grp def _collect_subkey_info ( self , curkey : dict [ str, str | list[str ] | list [ list[str | None ] ] | dict [ str, dict[str, str ] ] | list [ tuple[str, str, str ] ] , ] , args : list [ str ] , ) -> None : info_map = curkey . setdefault ( \"subkey_info\" , {} ) info = {} _set_fields ( info , self . FIELDS , args ) info_map [ args[4 ] ] = info def sub ( self , args : list [ str ] ) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" # See issue #81 . We create a dict with more information about # subkeys , but for backward compatibility reason , have to add it in # as a separate entry 'subkey_info' subkey = [ args[4 ] , args [ 11 ] , None , None ] # keyid , type , fp , grp self . curkey [ \"subkeys\" ] . append ( subkey ) self . _collect_subkey_info ( self . curkey , args ) self . in_subkey = True def ssb ( self , args : list [ str ] ) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" subkey = [ args[4 ] , None , None , None ] # keyid , type , fp , grp self . curkey [ \"subkeys\" ] . append ( subkey ) self . _collect_subkey_info ( self . curkey , args ) self . in_subkey = True def sig ( self , args : list [ str ] ) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" # keyid , uid , sigclass self . curkey [ \"sigs\" ] . append (( args [ 4 ] , args [ 9 ] , args [ 10 ] )) Ancestors (in MRO) gnupg.handlers.SearchKeysHandler gnupg.handlers.StatusHandler builtins.list Descendants gnupg.handlers.ScanKeysHandler Class variables FIELDS UID_INDEX returncode Methods append def append ( self , object , / ) Append object to the end of the list. clear def clear ( self , / ) Remove all items from list. copy def copy ( self , / ) Return a shallow copy of the list. count def count ( self , value , / ) Return number of occurrences of value. extend def extend ( self , iterable , / ) Extend list by appending elements from the iterable. fpr def fpr ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def fpr ( self , args : list [ str ] ) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" fp = args [ 9 ] if fp in self . key_map and self . gpg . check_fingerprint_collisions : # pragma : no cover msg = f \"Unexpected fingerprint collision: {fp}\" raise ValueError ( msg ) if not self . in_subkey : self . curkey [ \"fingerprint\" ] = fp self . fingerprints . append ( fp ) self . key_map [ fp ] = self . curkey else : self . curkey [ \"subkeys\" ][ -1 ][ 2 ] = fp self . key_map [ fp ] = self . curkey get_fields def get_fields ( self , args : 'list[str]' ) -> 'dict[str, str]' Internal method used to update the instance from a gpg status message. View Source def get_fields ( self , args : list [ str ] ) -> dict [ str , str ] : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" result = {} _set_fields ( result , self . FIELDS , args ) result [ \"uids\" ] = [] result [ \"sigs\" ] = [] return result grp def grp ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def grp ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" grp = args [ 9 ] if not self . in_subkey : self . curkey [ \"keygrip\" ] = grp else : self . curkey [ \"subkeys\" ][ - 1 ][ 3 ] = grp handle_status def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : # pragma : no cover pass index def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present. insert def insert ( self , index , object , / ) Insert object before index. key def key ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def key ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" self . curkey = curkey = self . get_fields ( args ) if curkey [ \"uid\" ] : # pragma: no cover curkey [ \"uids\" ] . append ( curkey [ \"uid\" ] ) del curkey [ \"uid\" ] curkey [ \"subkeys\" ] = [] self . append ( curkey ) self . in_subkey = False pop def pop ( self , index =- 1 , / ) Remove and return item at index (default last). Raises IndexError if list is empty or index is out of range. pub def pub ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def key ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" self . curkey = curkey = self . get_fields ( args ) if curkey [ \"uid\" ] : # pragma: no cover curkey [ \"uids\" ] . append ( curkey [ \"uid\" ] ) del curkey [ \"uid\" ] curkey [ \"subkeys\" ] = [] self . append ( curkey ) self . in_subkey = False remove def remove ( self , value , / ) Remove first occurrence of value. Raises ValueError if the value is not present. reverse def reverse ( self , / ) Reverse IN PLACE . sec def sec ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def key ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" self . curkey = curkey = self . get_fields ( args ) if curkey [ \"uid\" ] : # pragma: no cover curkey [ \"uids\" ] . append ( curkey [ \"uid\" ] ) del curkey [ \"uid\" ] curkey [ \"subkeys\" ] = [] self . append ( curkey ) self . in_subkey = False sig def sig ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def sig ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" # keyid, uid, sigclass self . curkey [ \"sigs\" ] . append (( args [ 4 ] , args [ 9 ] , args [ 10 ] )) sort def sort ( self , / , * , key = None , reverse = False ) Sort the list in ascending order and return None. The sort is in-place (i.e. the list itself is modified) and stable (i.e. the order of two equal elements is maintained). If a key function is given, apply it once to each list item and sort them, ascending or descending, according to their function values. The reverse flag can be set to sort in descending order. ssb def ssb ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def ssb ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" subkey = [ args [ 4 ], None , None , None ] # keyid , type , fp , grp self . curkey [ \"subkeys\" ]. append ( subkey ) self . _collect_subkey_info ( self . curkey , args ) self . in_subkey = True sub def sub ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def sub ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" # See issue # 81 . We create a dict with more information about # subkeys , but for backward compatibility reason , have to add it in # as a separate entry ' subkey_info ' subkey = [ args [ 4 ], args [ 11 ], None , None ] # keyid , type , fp , grp self . curkey [ \"subkeys\" ]. append ( subkey ) self . _collect_subkey_info ( self . curkey , args ) self . in_subkey = True uid def uid ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def uid ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" uid = args [ self . UID_INDEX ] uid = ESCAPE_PATTERN . sub ( lambda m : chr ( int ( m . group ( 1 ), 16 )), uid ) for k , v in BASIC_ESCAPES . items () : uid = uid . replace ( k , v ) self . curkey [ \"uids\" ] . append ( uid ) self . uids . append ( uid ) ScanKeysHandler class ScanKeysHandler ( gpg : 'GPG' ) This class handles status messages during scanning keys. View Source class ScanKeysHandler ( ListKeysHandler ) : \" \"\" This class handles status messages during scanning keys. \"\" \" def sub ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" # --with-fingerprint --with-colons somehow outputs fewer colons, # use the last value args[-1] instead of args[11] subkey = [ args [ 4 ] , args [ - 1 ] , None , None ] self . curkey [ \"subkeys\" ] . append ( subkey ) self . _collect_subkey_info ( self . curkey , args ) self . in_subkey = True Ancestors (in MRO) gnupg.handlers.ListKeysHandler gnupg.handlers.SearchKeysHandler gnupg.handlers.StatusHandler builtins.list Class variables FIELDS UID_INDEX returncode Methods append def append ( self , object , / ) Append object to the end of the list. clear def clear ( self , / ) Remove all items from list. copy def copy ( self , / ) Return a shallow copy of the list. count def count ( self , value , / ) Return number of occurrences of value. extend def extend ( self , iterable , / ) Extend list by appending elements from the iterable. fpr def fpr ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def fpr ( self , args : list [ str ] ) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" fp = args [ 9 ] if fp in self . key_map and self . gpg . check_fingerprint_collisions : # pragma : no cover msg = f \"Unexpected fingerprint collision: {fp}\" raise ValueError ( msg ) if not self . in_subkey : self . curkey [ \"fingerprint\" ] = fp self . fingerprints . append ( fp ) self . key_map [ fp ] = self . curkey else : self . curkey [ \"subkeys\" ][ -1 ][ 2 ] = fp self . key_map [ fp ] = self . curkey get_fields def get_fields ( self , args : 'list[str]' ) -> 'dict[str, str]' Internal method used to update the instance from a gpg status message. View Source def get_fields ( self , args : list [ str ] ) -> dict [ str , str ] : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" result = {} _set_fields ( result , self . FIELDS , args ) result [ \"uids\" ] = [] result [ \"sigs\" ] = [] return result grp def grp ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def grp ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" grp = args [ 9 ] if not self . in_subkey : self . curkey [ \"keygrip\" ] = grp else : self . curkey [ \"subkeys\" ][ - 1 ][ 3 ] = grp handle_status def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : # pragma : no cover pass index def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present. insert def insert ( self , index , object , / ) Insert object before index. key def key ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def key ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" self . curkey = curkey = self . get_fields ( args ) if curkey [ \"uid\" ] : # pragma: no cover curkey [ \"uids\" ] . append ( curkey [ \"uid\" ] ) del curkey [ \"uid\" ] curkey [ \"subkeys\" ] = [] self . append ( curkey ) self . in_subkey = False pop def pop ( self , index =- 1 , / ) Remove and return item at index (default last). Raises IndexError if list is empty or index is out of range. pub def pub ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def key ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" self . curkey = curkey = self . get_fields ( args ) if curkey [ \"uid\" ] : # pragma: no cover curkey [ \"uids\" ] . append ( curkey [ \"uid\" ] ) del curkey [ \"uid\" ] curkey [ \"subkeys\" ] = [] self . append ( curkey ) self . in_subkey = False remove def remove ( self , value , / ) Remove first occurrence of value. Raises ValueError if the value is not present. reverse def reverse ( self , / ) Reverse IN PLACE . sec def sec ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def key ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" self . curkey = curkey = self . get_fields ( args ) if curkey [ \"uid\" ] : # pragma: no cover curkey [ \"uids\" ] . append ( curkey [ \"uid\" ] ) del curkey [ \"uid\" ] curkey [ \"subkeys\" ] = [] self . append ( curkey ) self . in_subkey = False sig def sig ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def sig ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" # keyid, uid, sigclass self . curkey [ \"sigs\" ] . append (( args [ 4 ] , args [ 9 ] , args [ 10 ] )) sort def sort ( self , / , * , key = None , reverse = False ) Sort the list in ascending order and return None. The sort is in-place (i.e. the list itself is modified) and stable (i.e. the order of two equal elements is maintained). If a key function is given, apply it once to each list item and sort them, ascending or descending, according to their function values. The reverse flag can be set to sort in descending order. ssb def ssb ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def ssb ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" subkey = [ args [ 4 ], None , None , None ] # keyid , type , fp , grp self . curkey [ \"subkeys\" ]. append ( subkey ) self . _collect_subkey_info ( self . curkey , args ) self . in_subkey = True sub def sub ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def sub ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" # --with-fingerprint --with-colons somehow outputs fewer colons, # use the last value args[-1] instead of args[11] subkey = [ args [ 4 ] , args [ - 1 ] , None , None ] self . curkey [ \"subkeys\" ] . append ( subkey ) self . _collect_subkey_info ( self . curkey , args ) self . in_subkey = True uid def uid ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def uid ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" uid = args [ self . UID_INDEX ] uid = ESCAPE_PATTERN . sub ( lambda m : chr ( int ( m . group ( 1 ), 16 )), uid ) for k , v in BASIC_ESCAPES . items () : uid = uid . replace ( k , v ) self . curkey [ \"uids\" ] . append ( uid ) self . uids . append ( uid ) SearchKeysHandler class SearchKeysHandler ( gpg : 'GPG' ) This class handles status messages during key search. View Source class SearchKeysHandler ( StatusHandler , list ): \"\"\" This class handles status messages during key search. \"\"\" # Handle pub and uid ( relating the latter to the former ). # Don ' t care about the rest UID_INDEX = 1 FIELDS = \"type keyid algo length date expires\" . split () returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . curkey = None self . fingerprints = [] self . uids = [] def get_fields ( self , args : list [ str ]) -> dict [ str , str ]: \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" result = {} _set_fields ( result , self . FIELDS , args ) result [ \"uids\" ] = [] result [ \"sigs\" ] = [] return result def pub ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" self . curkey = curkey = self . get_fields ( args ) self . append ( curkey ) def uid ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" uid = args [ self . UID_INDEX ] uid = ESCAPE_PATTERN . sub ( lambda m : chr ( int ( m . group ( 1 ), 16 )), uid ) for k , v in BASIC_ESCAPES . items (): uid = uid . replace ( k , v ) self . curkey [ \"uids\" ]. append ( uid ) self . uids . append ( uid ) def handle_status ( self , key : str , value : str ) -> None : # pragma : no cover pass Ancestors (in MRO) gnupg.handlers.StatusHandler builtins.list Descendants gnupg.handlers.ListKeysHandler Class variables FIELDS UID_INDEX returncode Methods append def append ( self , object , / ) Append object to the end of the list. clear def clear ( self , / ) Remove all items from list. copy def copy ( self , / ) Return a shallow copy of the list. count def count ( self , value , / ) Return number of occurrences of value. extend def extend ( self , iterable , / ) Extend list by appending elements from the iterable. get_fields def get_fields ( self , args : 'list[str]' ) -> 'dict[str, str]' Internal method used to update the instance from a gpg status message. View Source def get_fields ( self , args : list [ str ] ) -> dict [ str , str ] : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" result = {} _set_fields ( result , self . FIELDS , args ) result [ \"uids\" ] = [] result [ \"sigs\" ] = [] return result handle_status def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : # pragma : no cover pass index def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present. insert def insert ( self , index , object , / ) Insert object before index. pop def pop ( self , index =- 1 , / ) Remove and return item at index (default last). Raises IndexError if list is empty or index is out of range. pub def pub ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def pub ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" self . curkey = curkey = self . get_fields ( args ) self . append ( curkey ) remove def remove ( self , value , / ) Remove first occurrence of value. Raises ValueError if the value is not present. reverse def reverse ( self , / ) Reverse IN PLACE . sort def sort ( self , / , * , key = None , reverse = False ) Sort the list in ascending order and return None. The sort is in-place (i.e. the list itself is modified) and stable (i.e. the order of two equal elements is maintained). If a key function is given, apply it once to each list item and sort them, ascending or descending, according to their function values. The reverse flag can be set to sort in descending order. uid def uid ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def uid ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" uid = args [ self . UID_INDEX ] uid = ESCAPE_PATTERN . sub ( lambda m : chr ( int ( m . group ( 1 ), 16 )), uid ) for k , v in BASIC_ESCAPES . items () : uid = uid . replace ( k , v ) self . curkey [ \"uids\" ] . append ( uid ) self . uids . append ( uid ) SendResultHandler class SendResultHandler ( gpg : 'GPG' ) This class handles status messages during key sending. View Source class SendResultHandler ( StatusHandler ): \"\"\" This class handles status messages during key sending. \"\"\" returncode = None def handle_status ( self , key: str , value: str ) -> None: logger . debug ( \"SendResult: %s: %s\" , key , value ) Ancestors (in MRO) gnupg.handlers.StatusHandler Class variables returncode Methods handle_status def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : logger . debug ( \"SendResult: %s: %s\" , key , value ) SignHandler class SignHandler ( gpg : 'GPG' ) This class handles status messages during signing. View Source class SignHandler ( StatusHandler , TextHandler ): \"\"\" This class handles status messages during signing. \"\"\" returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . type = None self . hash_algo = None self . fingerprint = None self . status = None self . status_detail = None self . key_id = None self . username = None def __nonzero__ ( self ) -> bool : return self . fingerprint is not None __bool__ = __nonzero__ def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" , \"FAILURE\" ): # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key in ( \"KEYEXPIRED\" , \"SIGEXPIRED\" ): # pragma : no cover self . status = \"key expired\" elif key == \"KEYREVOKED\" : # pragma : no cover self . status = \"key revoked\" elif key == \"SIG_CREATED\" : ( self . type , algo , self . hash_algo , cls , self . timestamp , self . fingerprint ) = value . split () self . status = \"signature created\" elif key == \"USERID_HINT\" : # pragma : no cover self . key_id , self . username = value . split ( \" \" , 1 ) elif key == \"BAD_PASSPHRASE\" : # pragma : no cover self . status = \"bad passphrase\" elif key in ( \"INV_SGNR\" , \"INV_RECP\" ): # pragma : no cover # INV_RECP is returned in older versions if not self . status : self . status = \"invalid signer\" else : self . status = f \"invalid signer: {self.status}\" self . status_detail = _determine_invalid_recipient_or_signer ( value ) elif key in ( \"NEED_PASSPHRASE\" , \"GOOD_PASSPHRASE\" , \"BEGIN_SIGNING\" ): pass else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value ) Ancestors (in MRO) gnupg.handlers.StatusHandler gnupg.handlers.text_handler.TextHandler Class variables returncode Methods handle_status def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" , \"FAILURE\" ): # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key in ( \"KEYEXPIRED\" , \"SIGEXPIRED\" ): # pragma : no cover self . status = \"key expired\" elif key == \"KEYREVOKED\" : # pragma : no cover self . status = \"key revoked\" elif key == \"SIG_CREATED\" : ( self . type , algo , self . hash_algo , cls , self . timestamp , self . fingerprint ) = value . split () self . status = \"signature created\" elif key == \"USERID_HINT\" : # pragma : no cover self . key_id , self . username = value . split ( \" \" , 1 ) elif key == \"BAD_PASSPHRASE\" : # pragma : no cover self . status = \"bad passphrase\" elif key in ( \"INV_SGNR\" , \"INV_RECP\" ): # pragma : no cover # INV_RECP is returned in older versions if not self . status : self . status = \"invalid signer\" else : self . status = f \"invalid signer: {self.status}\" self . status_detail = _determine_invalid_recipient_or_signer ( value ) elif key in ( \"NEED_PASSPHRASE\" , \"GOOD_PASSPHRASE\" , \"BEGIN_SIGNING\" ): pass else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value ) StatusHandler class StatusHandler ( gpg : 'GPG' ) The base class for handling status messages from gpg . View Source class StatusHandler : \" \"\" The base class for handling status messages from `gpg`. \"\" \" def __init__ ( self , gpg : GPG ) -> None : \" \"\" Initialize an instance. Args: gpg (GPG): The :class:`GPG` instance in use. \"\" \" self . gpg = gpg self . data : str | None = None def handle_status ( self , key : str , value : str ) -> NoReturn : \" \"\" Handle status messages from the `gpg` child process. These are lines of the format [GNUPG:] <key> <value> Args: key (str): Identifies what the status message is. value (str): Identifies additional data, which differs depending on the key. \"\" \" raise NotImplementedError Descendants gnupg.handlers.AddSubkeyHandler gnupg.handlers.AutoLocateKeyHandler gnupg.handlers.VerifyHandler gnupg.handlers.DeleteResultHandler gnupg.handlers.GenKeyHandler gnupg.handlers.ImportResultHandler gnupg.handlers.SearchKeysHandler gnupg.handlers.SendResultHandler gnupg.handlers.SignHandler Methods handle_status def handle_status ( self , key : 'str' , value : 'str' ) -> 'NoReturn' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> NoReturn : \" \"\" Handle status messages from the `gpg` child process. These are lines of the format [GNUPG:] <key> <value> Args: key (str): Identifies what the status message is. value (str): Identifies additional data, which differs depending on the key. \"\" \" raise NotImplementedError TrustResultHandler class TrustResultHandler ( gpg : 'GPG' ) This class handles status messages during key trust setting. View Source class TrustResultHandler ( DeleteResultHandler ): \"\"\" This class handles status messages during key trust setting. \"\"\" Ancestors (in MRO) gnupg.handlers.DeleteResultHandler gnupg.handlers.StatusHandler Class variables problem_reason returncode Methods handle_status def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : if key == \"DELETE_PROBLEM\" : # pragma : no cover self . status = self . problem_reason . get ( value , f \"Unknown error: {value!r}\" ) else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value ) VerifyHandler class VerifyHandler ( gpg : 'GPG' ) This class handles status messages during signature verificaton. View Source class VerifyHandler ( StatusHandler ) : \"\"\" This class handles status messages during signature verificaton. \"\"\" TRUST_EXPIRED = 0 TRUST_UNDEFINED = 1 TRUST_NEVER = 2 TRUST_MARGINAL = 3 TRUST_FULLY = 4 TRUST_ULTIMATE = 5 TRUST_LEVELS = MappingProxyType ( { \"TRUST_EXPIRED\" : TRUST_EXPIRED , \"TRUST_UNDEFINED\" : TRUST_UNDEFINED , \"TRUST_NEVER\" : TRUST_NEVER , \"TRUST_MARGINAL\" : TRUST_MARGINAL , \"TRUST_FULLY\" : TRUST_FULLY , \"TRUST_ULTIMATE\" : TRUST_ULTIMATE , } , ) # for now , just the most common error codes . This can be expanded as and # when reports come in of other errors . GPG_SYSTEM_ERROR_CODES = MappingProxyType ( { 1 : \"permission denied\" , 35 : \"file exists\" , 81 : \"file not found\" , 97 : \"not a directory\" , } , ) GPG_ERROR_CODES = MappingProxyType ( { 11 : \"incorrect passphrase\" , } , ) returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . valid = False self . fingerprint = self . creation_date = self . timestamp = None self . signature_id = self . key_id = None self . username = None self . key_id = None self . key_status = None self . status = None self . pubkey_fingerprint = None self . expire_timestamp = None self . sig_timestamp = None self . trust_text = None self . trust_level = None self . sig_info = {} self . problems = [] def __nonzero__ ( self ) -> bool : # pragma : no cover return self . valid __bool__ = __nonzero__ def handle_status ( self , key : str , value : str ) -> None : def update_sig_info ( ** kwargs : object ) -> None : sig_id = self . signature_id if sig_id : info = self . sig_info [ sig_id ] info . update ( kwargs ) else : logger . debug ( \"Ignored due to missing sig iD: %s\" , kwargs ) if key in self . TRUST_LEVELS : self . trust_text = key self . trust_level = self . TRUST_LEVELS [ key ] update_sig_info ( trust_level = self . trust_level , trust_text = self . trust_text ) # See Issue #214 . Once we see this , we 're done with the signature just seen. # Zap the signature ID, because we don' t see a SIG_ID unless we have a new # good signature . self . signature_id = None elif key in ( \"WARNING\" , \"ERROR\" ) : # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key == \"BADSIG\" : # pragma : no cover self . valid = False self . status = \"signature bad\" self . key_id , self . username = value . split ( None , 1 ) self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id , \"user\" : self . username } ) update_sig_info ( keyid = self . key_id , username = self . username , status = self . status ) elif key == \"ERRSIG\" : # pragma : no cover self . valid = False parts = value . split () ( self . key_id , algo , hash_algo , cls , self . timestamp ) = parts [ :5 ] # Since GnuPG 2.2.7 , a fingerprint is tacked on if len ( parts ) >= 7 : # noqa : PLR2004 self . fingerprint = parts [ 6 ] self . status = \"signature error\" update_sig_info ( keyid = self . key_id , timestamp = self . timestamp , fingerprint = self . fingerprint , status = self . status , ) self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id , \"timestamp\" : self . timestamp , \"fingerprint\" : self . fingerprint , } , ) elif key == \"EXPSIG\" : # pragma : no cover self . valid = False self . status = \"signature expired\" self . key_id , self . username = value . split ( None , 1 ) update_sig_info ( keyid = self . key_id , username = self . username , status = self . status ) self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id , \"user\" : self . username } ) elif key == \"GOODSIG\" : self . valid = True self . status = \"signature good\" self . key_id , self . username = value . split ( None , 1 ) update_sig_info ( keyid = self . key_id , username = self . username , status = self . status ) elif key == \"VALIDSIG\" : parts = value . split () fingerprint , creation_date , sig_ts , expire_ts = parts [ :4 ] ( self . fingerprint , self . creation_date , self . sig_timestamp , self . expire_timestamp ) = ( fingerprint , creation_date , sig_ts , expire_ts , ) # may be different if signature is made with a subkey if len ( parts ) >= 10 : # noqa : PLR2004 self . pubkey_fingerprint = parts [ 9 ] self . status = \"signature valid\" update_sig_info ( fingerprint = fingerprint , creation_date = creation_date , timestamp = sig_ts , expiry = expire_ts , pubkey_fingerprint = self . pubkey_fingerprint , status = self . status , ) elif key == \"SIG_ID\" : sig_id , creation_date , timestamp = value . split () self . sig_info [ sig_id ] = { \"creation_date\" : creation_date , \"timestamp\" : timestamp } ( self . signature_id , self . creation_date , self . timestamp ) = ( sig_id , creation_date , timestamp ) elif key == \"NO_PUBKEY\" : # pragma : no cover self . valid = False self . key_id = value self . status = \"no public key\" self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id } ) elif key == \"NO_SECKEY\" : # pragma : no cover self . valid = False self . key_id = value self . status = \"no secret key\" self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id } ) elif key in ( \"EXPKEYSIG\" , \"REVKEYSIG\" ) : # pragma : no cover # signed with expired or revoked key self . valid = False self . key_id = value . split () [ 0 ] if key == \"EXPKEYSIG\" : self . key_status = \"signing key has expired\" else : self . key_status = \"signing key was revoked\" self . status = self . key_status update_sig_info ( status = self . status , keyid = self . key_id ) self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id } ) elif key in ( \"UNEXPECTED\" , \"FAILURE\" ) : # pragma : no cover self . valid = False if key == \"UNEXPECTED\" : self . status = \"unexpected data\" else : # N . B . there might be other reasons . For example , if an output # file can ' t be created - / dev / null / foo will lead to a # \"not a directory\" error , but which is not sent as a status # message with the [ GNUPG: ] prefix . Similarly if you try to # write to \"/etc/foo\" as a non - root user , a \"permission denied\" # error will be sent as a non - status message . message = f \"error - {value}\" operation , code = value . rsplit ( \" \" , 1 ) if code . isdigit () : code = int ( code ) & 0xFFFFFF # lose the error source if self . gpg . error_map and code in self . gpg . error_map : message = f \"{operation}: {self.gpg.error_map[code]}\" else : system_error = bool ( code & 0x8000 ) code = code & 0x7FFF mapping = self . GPG_SYSTEM_ERROR_CODES if system_error else self . GPG_ERROR_CODES if code in mapping : message = f \"{operation}: {mapping[code]}\" if not self . status : self . status = message elif key == \"NODATA\" : # pragma : no cover # See issue GH - 191 self . valid = False self . status = \"signature expected but not found\" elif key in ( \"DECRYPTION_INFO\" , \"PLAINTEXT\" , \"PLAINTEXT_LENGTH\" , \"BEGIN_SIGNING\" , \"KEY_CONSIDERED\" ) : pass elif key in ( \"NEWSIG\" ,) : # Only sent in gpg2 . Clear any signature ID , to be set by a following SIG_ID self . signature_id = None else : # pragma : no cover logger . debug ( \"message ignored: %r, %r\" , key , value ) Ancestors (in MRO) gnupg.handlers.StatusHandler Descendants gnupg.handlers.CryptHandler Class variables GPG_ERROR_CODES GPG_SYSTEM_ERROR_CODES TRUST_EXPIRED TRUST_FULLY TRUST_LEVELS TRUST_MARGINAL TRUST_NEVER TRUST_ULTIMATE TRUST_UNDEFINED returncode Methods handle_status def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : def update_sig_info ( ** kwargs : object ) -> None : sig_id = self . signature_id if sig_id : info = self . sig_info [ sig_id ] info . update ( kwargs ) else : logger . debug ( \"Ignored due to missing sig iD: %s\" , kwargs ) if key in self . TRUST_LEVELS : self . trust_text = key self . trust_level = self . TRUST_LEVELS [ key ] update_sig_info ( trust_level = self . trust_level , trust_text = self . trust_text ) # See Issue #214 . Once we see this , we 're done with the signature just seen. # Zap the signature ID, because we don' t see a SIG_ID unless we have a new # good signature . self . signature_id = None elif key in ( \"WARNING\" , \"ERROR\" ) : # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key == \"BADSIG\" : # pragma : no cover self . valid = False self . status = \"signature bad\" self . key_id , self . username = value . split ( None , 1 ) self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id , \"user\" : self . username } ) update_sig_info ( keyid = self . key_id , username = self . username , status = self . status ) elif key == \"ERRSIG\" : # pragma : no cover self . valid = False parts = value . split () ( self . key_id , algo , hash_algo , cls , self . timestamp ) = parts [ :5 ] # Since GnuPG 2.2.7 , a fingerprint is tacked on if len ( parts ) >= 7 : # noqa : PLR2004 self . fingerprint = parts [ 6 ] self . status = \"signature error\" update_sig_info ( keyid = self . key_id , timestamp = self . timestamp , fingerprint = self . fingerprint , status = self . status , ) self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id , \"timestamp\" : self . timestamp , \"fingerprint\" : self . fingerprint , } , ) elif key == \"EXPSIG\" : # pragma : no cover self . valid = False self . status = \"signature expired\" self . key_id , self . username = value . split ( None , 1 ) update_sig_info ( keyid = self . key_id , username = self . username , status = self . status ) self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id , \"user\" : self . username } ) elif key == \"GOODSIG\" : self . valid = True self . status = \"signature good\" self . key_id , self . username = value . split ( None , 1 ) update_sig_info ( keyid = self . key_id , username = self . username , status = self . status ) elif key == \"VALIDSIG\" : parts = value . split () fingerprint , creation_date , sig_ts , expire_ts = parts [ :4 ] ( self . fingerprint , self . creation_date , self . sig_timestamp , self . expire_timestamp ) = ( fingerprint , creation_date , sig_ts , expire_ts , ) # may be different if signature is made with a subkey if len ( parts ) >= 10 : # noqa : PLR2004 self . pubkey_fingerprint = parts [ 9 ] self . status = \"signature valid\" update_sig_info ( fingerprint = fingerprint , creation_date = creation_date , timestamp = sig_ts , expiry = expire_ts , pubkey_fingerprint = self . pubkey_fingerprint , status = self . status , ) elif key == \"SIG_ID\" : sig_id , creation_date , timestamp = value . split () self . sig_info [ sig_id ] = { \"creation_date\" : creation_date , \"timestamp\" : timestamp } ( self . signature_id , self . creation_date , self . timestamp ) = ( sig_id , creation_date , timestamp ) elif key == \"NO_PUBKEY\" : # pragma : no cover self . valid = False self . key_id = value self . status = \"no public key\" self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id } ) elif key == \"NO_SECKEY\" : # pragma : no cover self . valid = False self . key_id = value self . status = \"no secret key\" self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id } ) elif key in ( \"EXPKEYSIG\" , \"REVKEYSIG\" ) : # pragma : no cover # signed with expired or revoked key self . valid = False self . key_id = value . split () [ 0 ] if key == \"EXPKEYSIG\" : self . key_status = \"signing key has expired\" else : self . key_status = \"signing key was revoked\" self . status = self . key_status update_sig_info ( status = self . status , keyid = self . key_id ) self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id } ) elif key in ( \"UNEXPECTED\" , \"FAILURE\" ) : # pragma : no cover self . valid = False if key == \"UNEXPECTED\" : self . status = \"unexpected data\" else : # N . B . there might be other reasons . For example , if an output # file can ' t be created - / dev / null / foo will lead to a # \"not a directory\" error , but which is not sent as a status # message with the [ GNUPG: ] prefix . Similarly if you try to # write to \"/etc/foo\" as a non - root user , a \"permission denied\" # error will be sent as a non - status message . message = f \"error - {value}\" operation , code = value . rsplit ( \" \" , 1 ) if code . isdigit () : code = int ( code ) & 0xFFFFFF # lose the error source if self . gpg . error_map and code in self . gpg . error_map : message = f \"{operation}: {self.gpg.error_map[code]}\" else : system_error = bool ( code & 0x8000 ) code = code & 0x7FFF mapping = self . GPG_SYSTEM_ERROR_CODES if system_error else self . GPG_ERROR_CODES if code in mapping : message = f \"{operation}: {mapping[code]}\" if not self . status : self . status = message elif key == \"NODATA\" : # pragma : no cover # See issue GH - 191 self . valid = False self . status = \"signature expected but not found\" elif key in ( \"DECRYPTION_INFO\" , \"PLAINTEXT\" , \"PLAINTEXT_LENGTH\" , \"BEGIN_SIGNING\" , \"KEY_CONSIDERED\" ) : pass elif key in ( \"NEWSIG\" ,) : # Only sent in gpg2 . Clear any signature ID , to be set by a following SIG_ID self . signature_id = None else : # pragma : no cover logger . debug ( \"message ignored: %r, %r\" , key , value )","title":"Index"},{"location":"reference/gnupg/handlers/#module-gnupghandlers","text":"View Source from __future__ import annotations from .add_subkey_handler import AddSubkeyHandler from .auto_locate_key_handler import AutoLocateKeyHandler from .crypt_handler import CryptHandler from .delete_result_handler import DeleteResultHandler from .export_result_handler import ExportResultHandler from .gen_key_handler import GenKeyHandler from .import_result_handler import ImportResultHandler from .list_keys_handler import ListKeysHandler from .scan_keys_handler import ScanKeysHandler from .search_keys_handler import SearchKeysHandler from .send_result_handler import SendResultHandler from .sign_handler import SignHandler from .status_handler import StatusHandler from .trust_result_handler import TrustResultHandler from .verify_handler import VerifyHandler __all__ = ( \"AddSubkeyHandler\" , \"AutoLocateKeyHandler\" , \"CryptHandler\" , \"DeleteResultHandler\" , \"ExportResultHandler\" , \"GenKeyHandler\" , \"ImportResultHandler\" , \"ListKeysHandler\" , \"ScanKeysHandler\" , \"SearchKeysHandler\" , \"SendResultHandler\" , \"SignHandler\" , \"StatusHandler\" , \"TrustResultHandler\" , \"VerifyHandler\" , )","title":"Module gnupg.handlers"},{"location":"reference/gnupg/handlers/#sub-modules","text":"gnupg.handlers.add_subkey_handler gnupg.handlers.auto_locate_key_handler gnupg.handlers.crypt_handler gnupg.handlers.delete_result_handler gnupg.handlers.export_result_handler gnupg.handlers.gen_key_handler gnupg.handlers.helper gnupg.handlers.import_result_handler gnupg.handlers.list_keys_handler gnupg.handlers.scan_keys_handler gnupg.handlers.search_keys_handler gnupg.handlers.send_result_handler gnupg.handlers.sign_handler gnupg.handlers.status_handler gnupg.handlers.text_handler gnupg.handlers.trust_result_handler gnupg.handlers.verify_handler","title":"Sub-modules"},{"location":"reference/gnupg/handlers/#classes","text":"","title":"Classes"},{"location":"reference/gnupg/handlers/#addsubkeyhandler","text":"class AddSubkeyHandler ( gpg : 'GPG' ) This class handles status messages during subkey addition. View Source class AddSubkeyHandler ( StatusHandler ): \"\"\" This class handles status messages during subkey addition. \"\"\" returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . type = None self . fingerprint = \"\" self . status = None def __nonzero__ ( self ) -> bool : # pragma : no cover return bool ( self . fingerprint ) __bool__ = __nonzero__ def __str__ ( self ) -> str : return self . fingerprint def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ): # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key == \"KEY_CREATED\" : ( self . type , self . fingerprint ) = value . split () self . status = \"ok\" else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value )","title":"AddSubkeyHandler"},{"location":"reference/gnupg/handlers/#ancestors-in-mro","text":"gnupg.handlers.StatusHandler","title":"Ancestors (in MRO)"},{"location":"reference/gnupg/handlers/#class-variables","text":"returncode","title":"Class variables"},{"location":"reference/gnupg/handlers/#methods","text":"","title":"Methods"},{"location":"reference/gnupg/handlers/#handle_status","text":"def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ): # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key == \"KEY_CREATED\" : ( self . type , self . fingerprint ) = value . split () self . status = \"ok\" else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value )","title":"handle_status"},{"location":"reference/gnupg/handlers/#autolocatekeyhandler","text":"class AutoLocateKeyHandler ( gpg : 'GPG' ) This class handles status messages during key auto-locating. fingerprint: str key_length: int created_at: date email: str email_real_name: str View Source class AutoLocateKeyHandler ( StatusHandler ) : \"\"\" This class handles status messages during key auto-locating. fingerprint: str key_length: int created_at: date email: str email_real_name: str \"\"\" def __ init__ ( self , gpg : GPG ) -> None : StatusHandler . __ init__ ( self , gpg ) self . fingerprint = None self . type = None self . created_at = None self . email = None self . email_real_name = None def handle_status ( self , key : str , val ue : str ) -> None : if key == \"IMPORTED\" : _ , email , display_name = val ue . split () self . email = email self . email_real_name = display_name [ 1 :- 1 ] elif key == \"KEY_CONSIDERED\" : self . fingerprint = val ue . strip (). split ()[ 0 ] def pub ( self , args : list [ str ]) -> None : \"\"\" Internal method to handle the 'pub' status message. `pub` message contains the fingerprint of the public key, its type and its creation date. \"\"\" def uid ( self , args : list [ str ]) -> None : local_tz = datetime . now (). astimezone (). tzinfo self . created_at = datetime . fromtimestamp ( int ( args [ 5 ]), tz = local_tz ) raw_email_content = args [ 9 ] email , real_name = parseaddr ( raw_email_content ) self . email = email self . email_real_name = real_name def sub ( self , args : list [ str ]) -> None : self . key_length = int ( args [ 2 ]) def fpr ( self , args : list [ str ]) -> None : # Only store the first fingerprint self . fingerprint = self . fingerprint or args [ 9 ]","title":"AutoLocateKeyHandler"},{"location":"reference/gnupg/handlers/#ancestors-in-mro_1","text":"gnupg.handlers.StatusHandler","title":"Ancestors (in MRO)"},{"location":"reference/gnupg/handlers/#methods_1","text":"","title":"Methods"},{"location":"reference/gnupg/handlers/#fpr","text":"def fpr ( self , args : 'list[str]' ) -> 'None' View Source def fpr ( self , args : list [ str ] ) -> None : # Only store the first fingerprint self . fingerprint = self . fingerprint or args [ 9 ]","title":"fpr"},{"location":"reference/gnupg/handlers/#handle_status_1","text":"def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , val ue : str ) -> None : if key == \"IMPORTED\" : _ , email , display_name = val ue . split () self . email = email self . email_real_name = display_name [ 1 :- 1 ] elif key == \"KEY_CONSIDERED\" : self . fingerprint = val ue . strip (). split ()[ 0 ]","title":"handle_status"},{"location":"reference/gnupg/handlers/#pub","text":"def pub ( self , args : 'list[str]' ) -> 'None' Internal method to handle the 'pub' status message. pub message contains the fingerprint of the public key, its type and its creation date. View Source def pub ( self , args : list [ str ]) -> None : \"\"\" Internal method to handle the 'pub' status message. `pub` message contains the fingerprint of the public key, its type and its creation date. \"\"\"","title":"pub"},{"location":"reference/gnupg/handlers/#sub","text":"def sub ( self , args : 'list[str]' ) -> 'None' View Source def sub ( self , args : list [ str ] ) -> None : self . key_length = int ( args [ 2 ] )","title":"sub"},{"location":"reference/gnupg/handlers/#uid","text":"def uid ( self , args : 'list[str]' ) -> 'None' View Source def uid ( self , args : list [ str ] ) -> None : local_tz = datetime . now (). astimezone (). tzinfo self . created_at = datetime . fromtimestamp ( int ( args [ 5 ] ), tz = local_tz ) raw_email_content = args [ 9 ] email , real_name = parseaddr ( raw_email_content ) self . email = email self . email_real_name = real_name","title":"uid"},{"location":"reference/gnupg/handlers/#crypthandler","text":"class CryptHandler ( gpg : 'GPG' ) This class handles status messages during encryption and decryption. View Source class CryptHandler ( VerifyHandler , TextHandler ): \"\"\" This class handles status messages during encryption and decryption. \"\"\" def __init__ ( self , gpg : GPG ) -> None : VerifyHandler . __init__ ( self , gpg ) self . data = \"\" self . ok = False self . status = \"\" self . status_detail = \"\" self . key_id = None def __nonzero__ ( self ) -> bool : return bool ( self . ok ) __bool__ = __nonzero__ def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ): logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key == \"NODATA\" : if self . status not in ( \"decryption failed\" ,): self . status = \"no data was provided\" elif key in ( \"NEED_PASSPHRASE\" , \"BAD_PASSPHRASE\" , \"GOOD_PASSPHRASE\" , \"MISSING_PASSPHRASE\" , \"KEY_NOT_CREATED\" , \"NEED_PASSPHRASE_PIN\" , ): # pragma : no cover self . status = key . replace ( \"_\" , \" \" ). lower () elif key == \"DECRYPTION_FAILED\" : # pragma : no cover if self . status != \"no secret key\" : # don ' t overwrite more useful message self . status = \"decryption failed\" elif key == \"NEED_PASSPHRASE_SYM\" : self . status = \"need symmetric passphrase\" elif key == \"BEGIN_DECRYPTION\" : if self . status != \"no secret key\" : # don ' t overwrite more useful message self . status = \"decryption incomplete\" elif key == \"BEGIN_ENCRYPTION\" : self . status = \"encryption incomplete\" elif key == \"DECRYPTION_OKAY\" : self . status = \"decryption ok\" self . ok = True elif key == \"END_ENCRYPTION\" : self . status = \"encryption ok\" self . ok = True elif key == \"INV_RECP\" : # pragma : no cover if not self . status : self . status = \"invalid recipient\" else : self . status = f \"invalid recipient: {self.status}\" self . status_detail = _determine_invalid_recipient_or_signer ( value ) elif key == \"KEYEXPIRED\" : # pragma : no cover self . status = \"key expired\" elif key == \"SIG_CREATED\" : # pragma : no cover self . status = \"sig created\" elif key == \"SIGEXPIRED\" : # pragma : no cover self . status = \"sig expired\" elif key == \"ENC_TO\" : # pragma : no cover # ENC_TO < long_keyid > < keytype > < keylength > self . key_id = value . split ( \" \" , 1 )[ 0 ] elif key in ( \"USERID_HINT\" , \"GOODMDC\" , \"END_DECRYPTION\" , \"CARDCTRL\" , \"BADMDC\" , \"SC_OP_FAILURE\" , \"SC_OP_SUCCESS\" , \"PINENTRY_LAUNCHED\" , ): pass else : VerifyHandler . handle_status ( self , key , value )","title":"CryptHandler"},{"location":"reference/gnupg/handlers/#ancestors-in-mro_2","text":"gnupg.handlers.VerifyHandler gnupg.handlers.StatusHandler gnupg.handlers.text_handler.TextHandler","title":"Ancestors (in MRO)"},{"location":"reference/gnupg/handlers/#class-variables_1","text":"GPG_ERROR_CODES GPG_SYSTEM_ERROR_CODES TRUST_EXPIRED TRUST_FULLY TRUST_LEVELS TRUST_MARGINAL TRUST_NEVER TRUST_ULTIMATE TRUST_UNDEFINED returncode","title":"Class variables"},{"location":"reference/gnupg/handlers/#methods_2","text":"","title":"Methods"},{"location":"reference/gnupg/handlers/#handle_status_2","text":"def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ): logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key == \"NODATA\" : if self . status not in ( \"decryption failed\" ,): self . status = \"no data was provided\" elif key in ( \"NEED_PASSPHRASE\" , \"BAD_PASSPHRASE\" , \"GOOD_PASSPHRASE\" , \"MISSING_PASSPHRASE\" , \"KEY_NOT_CREATED\" , \"NEED_PASSPHRASE_PIN\" , ): # pragma : no cover self . status = key . replace ( \"_\" , \" \" ). lower () elif key == \"DECRYPTION_FAILED\" : # pragma : no cover if self . status != \"no secret key\" : # don ' t overwrite more useful message self . status = \"decryption failed\" elif key == \"NEED_PASSPHRASE_SYM\" : self . status = \"need symmetric passphrase\" elif key == \"BEGIN_DECRYPTION\" : if self . status != \"no secret key\" : # don ' t overwrite more useful message self . status = \"decryption incomplete\" elif key == \"BEGIN_ENCRYPTION\" : self . status = \"encryption incomplete\" elif key == \"DECRYPTION_OKAY\" : self . status = \"decryption ok\" self . ok = True elif key == \"END_ENCRYPTION\" : self . status = \"encryption ok\" self . ok = True elif key == \"INV_RECP\" : # pragma : no cover if not self . status : self . status = \"invalid recipient\" else : self . status = f \"invalid recipient: {self.status}\" self . status_detail = _determine_invalid_recipient_or_signer ( value ) elif key == \"KEYEXPIRED\" : # pragma : no cover self . status = \"key expired\" elif key == \"SIG_CREATED\" : # pragma : no cover self . status = \"sig created\" elif key == \"SIGEXPIRED\" : # pragma : no cover self . status = \"sig expired\" elif key == \"ENC_TO\" : # pragma : no cover # ENC_TO < long_keyid > < keytype > < keylength > self . key_id = value . split ( \" \" , 1 )[ 0 ] elif key in ( \"USERID_HINT\" , \"GOODMDC\" , \"END_DECRYPTION\" , \"CARDCTRL\" , \"BADMDC\" , \"SC_OP_FAILURE\" , \"SC_OP_SUCCESS\" , \"PINENTRY_LAUNCHED\" , ): pass else : VerifyHandler . handle_status ( self , key , value )","title":"handle_status"},{"location":"reference/gnupg/handlers/#deleteresulthandler","text":"class DeleteResultHandler ( gpg : 'GPG' ) This class handles status messages during key deletion. View Source class DeleteResultHandler ( StatusHandler ): \"\"\" This class handles status messages during key deletion. \"\"\" returncode = None def __init__ ( self , gpg: GPG ) -> None: StatusHandler . __init__ ( self , gpg ) self . status = \"ok\" def __str__ ( self ) -> str: return self . status problem_reason = MappingProxyType ( { \"1\" : \"No such key\" , \"2\" : \"Must delete secret key first\" , \"3\" : \"Ambiguous specification\" , }, ) def handle_status ( self , key: str , value: str ) -> None: if key == \"DELETE_PROBLEM\" : # pragma: no cover self . status = self . problem_reason . get ( value , f \"Unknown error: {value!r}\" ) else: # pragma: no cover logger . debug ( \"message ignored: %s, %s\" , key , value ) def __nonzero__ ( self ) -> bool: # pragma: no cover return self . status == \"ok\" __bool__ = __nonzero__","title":"DeleteResultHandler"},{"location":"reference/gnupg/handlers/#ancestors-in-mro_3","text":"gnupg.handlers.StatusHandler","title":"Ancestors (in MRO)"},{"location":"reference/gnupg/handlers/#descendants","text":"gnupg.handlers.TrustResultHandler","title":"Descendants"},{"location":"reference/gnupg/handlers/#class-variables_2","text":"problem_reason returncode","title":"Class variables"},{"location":"reference/gnupg/handlers/#methods_3","text":"","title":"Methods"},{"location":"reference/gnupg/handlers/#handle_status_3","text":"def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : if key == \"DELETE_PROBLEM\" : # pragma : no cover self . status = self . problem_reason . get ( value , f \"Unknown error: {value!r}\" ) else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value )","title":"handle_status"},{"location":"reference/gnupg/handlers/#exportresulthandler","text":"class ExportResultHandler ( gpg : 'GPG' ) This class handles status messages during key export. View Source class ExportResultHandler ( GenKeyHandler ): \"\"\" This class handles status messages during key export. \"\"\" # For now, just use an existing class to base it on - if needed, we # can override handle_status for more specific message handling. def handle_status ( self , key : str , value : str ) -> None : if key in ( \"EXPORTED\" , \"EXPORT_RES\" ): pass else : super () . handle_status ( key , value )","title":"ExportResultHandler"},{"location":"reference/gnupg/handlers/#ancestors-in-mro_4","text":"gnupg.handlers.GenKeyHandler gnupg.handlers.StatusHandler","title":"Ancestors (in MRO)"},{"location":"reference/gnupg/handlers/#class-variables_3","text":"returncode","title":"Class variables"},{"location":"reference/gnupg/handlers/#methods_4","text":"","title":"Methods"},{"location":"reference/gnupg/handlers/#handle_status_4","text":"def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : if key in ( \"EXPORTED\" , \"EXPORT_RES\" ) : pass else : super (). handle_status ( key , value )","title":"handle_status"},{"location":"reference/gnupg/handlers/#genkeyhandler","text":"class GenKeyHandler ( gpg : 'GPG' ) This class handles status messages during key generation. View Source class GenKeyHandler ( StatusHandler ): \"\"\" This class handles status messages during key generation. \"\"\" returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . type = None self . fingerprint = \"\" self . status = None def __nonzero__ ( self ) -> bool : # pragma : no cover return bool ( self . fingerprint ) __bool__ = __nonzero__ def __str__ ( self ) -> str : # pragma : no cover return self . fingerprint def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ): # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key == \"KEY_CREATED\" : parts = value . split () ( self . type , self . fingerprint ) = parts [: 2 ] self . status = \"ok\" elif key == \"KEY_NOT_CREATED\" : self . status = key . replace ( \"_\" , \" \" ). lower () elif key in ( \"PROGRESS\" , \"GOOD_PASSPHRASE\" ): # pragma : no cover pass else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value )","title":"GenKeyHandler"},{"location":"reference/gnupg/handlers/#ancestors-in-mro_5","text":"gnupg.handlers.StatusHandler","title":"Ancestors (in MRO)"},{"location":"reference/gnupg/handlers/#descendants_1","text":"gnupg.handlers.ExportResultHandler","title":"Descendants"},{"location":"reference/gnupg/handlers/#class-variables_4","text":"returncode","title":"Class variables"},{"location":"reference/gnupg/handlers/#methods_5","text":"","title":"Methods"},{"location":"reference/gnupg/handlers/#handle_status_5","text":"def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ): # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key == \"KEY_CREATED\" : parts = value . split () ( self . type , self . fingerprint ) = parts [: 2 ] self . status = \"ok\" elif key == \"KEY_NOT_CREATED\" : self . status = key . replace ( \"_\" , \" \" ). lower () elif key in ( \"PROGRESS\" , \"GOOD_PASSPHRASE\" ): # pragma : no cover pass else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value )","title":"handle_status"},{"location":"reference/gnupg/handlers/#importresulthandler","text":"class ImportResultHandler ( gpg : 'GPG' ) This class handles status messages during key import. View Source class ImportResultHandler ( StatusHandler ) : \"\"\" This class handles status messages during key import. \"\"\" counts = \"\"\"count no_user_id imported imported_rsa unchanged n_uids n_subk n_sigs n_revoc sec_read sec_imported sec_dups not_imported\"\"\" . split () returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . results = [] self . fingerprints = [] for result in self . counts : setattr ( self , result , 0 ) def __nonzero__ ( self ) -> bool : return bool ( not self . not_imported and self . fingerprints ) __bool__ = __nonzero__ ok_reason = MappingProxyType ( { \"0\" : \"Not actually changed\" , \"1\" : \"Entirely new key\" , \"2\" : \"New user IDs\" , \"4\" : \"New signatures\" , \"8\" : \"New subkeys\" , \"16\" : \"Contains private key\" , } , ) problem_reason = MappingProxyType ( { \"0\" : \"No specific reason given\" , \"1\" : \"Invalid Certificate\" , \"2\" : \"Issuer Certificate missing\" , \"3\" : \"Certificate Chain too long\" , \"4\" : \"Error storing certificate\" , } , ) def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ) : # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key in ( \"IMPORTED\" , \"KEY_CONSIDERED\" ) : # this duplicates info we already see in import_ok & import_problem pass elif key == \"NODATA\" : # pragma : no cover self . results . append ( { \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"No valid data found\" } ) elif key == \"IMPORT_OK\" : reason , fingerprint = value . split () reasons = [] for code , text in list ( self . ok_reason . items ()) : if int ( reason ) | int ( code ) == int ( reason ) : reasons . append ( text ) reasontext = \"\\n\" . join ( reasons ) + \"\\n\" self . results . append ( { \"fingerprint\" : fingerprint , \"ok\" : reason , \"text\" : reasontext } ) self . fingerprints . append ( fingerprint ) elif key == \"IMPORT_PROBLEM\" : # pragma : no cover try : reason , fingerprint = value . split () except ( AttributeError , Exception ) : reason = value fingerprint = \"<unknown>\" self . results . append ( { \"fingerprint\" : fingerprint , \"problem\" : reason , \"text\" : self . problem_reason [ reason ] } ) elif key == \"IMPORT_RES\" : import_res = value . split () for i , count in enumerate ( self . counts ) : setattr ( self , count , int ( import_res [ i ] )) elif key == \"KEYEXPIRED\" : # pragma : no cover self . results . append ( { \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"Key expired\" } ) elif key == \"SIGEXPIRED\" : # pragma : no cover self . results . append ( { \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"Signature expired\" } ) elif key == \"FAILURE\" : # pragma : no cover self . results . append ( { \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"Other failure\" } ) else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value ) def summary ( self ) -> str : \"\"\" Return a summary indicating how many keys were imported and how many were not imported. \"\"\" result = [] result . append ( \"%d imported\" % self . imported ) if self . not_imported : # pragma : no cover result . append ( \"%d not imported\" % self . not_imported ) return \", \" . join ( result )","title":"ImportResultHandler"},{"location":"reference/gnupg/handlers/#ancestors-in-mro_6","text":"gnupg.handlers.StatusHandler","title":"Ancestors (in MRO)"},{"location":"reference/gnupg/handlers/#class-variables_5","text":"counts ok_reason problem_reason returncode","title":"Class variables"},{"location":"reference/gnupg/handlers/#methods_6","text":"","title":"Methods"},{"location":"reference/gnupg/handlers/#handle_status_6","text":"def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ) : # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key in ( \"IMPORTED\" , \"KEY_CONSIDERED\" ) : # this duplicates info we already see in import_ok & import_problem pass elif key == \"NODATA\" : # pragma : no cover self . results . append ( { \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"No valid data found\" } ) elif key == \"IMPORT_OK\" : reason , fingerprint = value . split () reasons = [] for code , text in list ( self . ok_reason . items ()) : if int ( reason ) | int ( code ) == int ( reason ) : reasons . append ( text ) reasontext = \"\\n\" . join ( reasons ) + \"\\n\" self . results . append ( { \"fingerprint\" : fingerprint , \"ok\" : reason , \"text\" : reasontext } ) self . fingerprints . append ( fingerprint ) elif key == \"IMPORT_PROBLEM\" : # pragma : no cover try : reason , fingerprint = value . split () except ( AttributeError , Exception ) : reason = value fingerprint = \"<unknown>\" self . results . append ( { \"fingerprint\" : fingerprint , \"problem\" : reason , \"text\" : self . problem_reason [ reason ] } ) elif key == \"IMPORT_RES\" : import_res = value . split () for i , count in enumerate ( self . counts ) : setattr ( self , count , int ( import_res [ i ] )) elif key == \"KEYEXPIRED\" : # pragma : no cover self . results . append ( { \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"Key expired\" } ) elif key == \"SIGEXPIRED\" : # pragma : no cover self . results . append ( { \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"Signature expired\" } ) elif key == \"FAILURE\" : # pragma : no cover self . results . append ( { \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"Other failure\" } ) else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value )","title":"handle_status"},{"location":"reference/gnupg/handlers/#summary","text":"def summary ( self ) -> 'str' Return a summary indicating how many keys were imported and how many were not imported. View Source def summary ( self ) -> str : \"\"\" Return a summary indicating how many keys were imported and how many were not imported. \"\"\" result = [] result . append ( \"%d imported\" % self . imported ) if self . not_imported : # pragma : no cover result . append ( \"%d not imported\" % self . not_imported ) return \", \" . join ( result )","title":"summary"},{"location":"reference/gnupg/handlers/#listkeyshandler","text":"class ListKeysHandler ( gpg : 'GPG' ) This class handles status messages during listing keys and signatures. Handle pub and uid (relating the latter to the former). We don't care about (info from GnuPG DETAILS file): crt = X.509 certificate crs = X.509 certificate and private key available uat = user attribute (same as user id except for field 10). sig = signature rev = revocation signature pkd = public key data (special field format, see below) grp = reserved for gpgsm rvk = revocation key View Source class ListKeysHandler ( SearchKeysHandler ) : \"\"\" This class handles status messages during listing keys and signatures. Handle pub and uid (relating the latter to the former). We don't care about (info from GnuPG DETAILS file): crt = X.509 certificate crs = X.509 certificate and private key available uat = user attribute (same as user id except for field 10). sig = signature rev = revocation signature pkd = public key data (special field format, see below) grp = reserved for gpgsm rvk = revocation key \"\"\" UID_INDEX = 9 FIELDS = ( \"type trust length algo keyid date expires dummy ownertrust uid sig\" \" cap issuer flag token hash curve compliance updated origin keygrip\" ). split () def __init__ ( self , gpg : GPG ) -> None : super (). __init__ ( gpg ) self . in_subkey = False self . key_map = {} def key ( self , args : list [ str ] ) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" self . curkey = curkey = self . get_fields ( args ) if curkey [ \"uid\" ] : # pragma : no cover curkey [ \"uids\" ] . append ( curkey [ \"uid\" ] ) del curkey [ \"uid\" ] curkey [ \"subkeys\" ] = [] self . append ( curkey ) self . in_subkey = False pub = sec = key def fpr ( self , args : list [ str ] ) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" fp = args [ 9 ] if fp in self . key_map and self . gpg . check_fingerprint_collisions : # pragma : no cover msg = f \"Unexpected fingerprint collision: {fp}\" raise ValueError ( msg ) if not self . in_subkey : self . curkey [ \"fingerprint\" ] = fp self . fingerprints . append ( fp ) self . key_map [ fp ] = self . curkey else : self . curkey [ \"subkeys\" ][ -1 ][ 2 ] = fp self . key_map [ fp ] = self . curkey def grp ( self , args : list [ str ] ) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" grp = args [ 9 ] if not self . in_subkey : self . curkey [ \"keygrip\" ] = grp else : self . curkey [ \"subkeys\" ][ -1 ][ 3 ] = grp def _collect_subkey_info ( self , curkey : dict [ str, str | list[str ] | list [ list[str | None ] ] | dict [ str, dict[str, str ] ] | list [ tuple[str, str, str ] ] , ] , args : list [ str ] , ) -> None : info_map = curkey . setdefault ( \"subkey_info\" , {} ) info = {} _set_fields ( info , self . FIELDS , args ) info_map [ args[4 ] ] = info def sub ( self , args : list [ str ] ) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" # See issue #81 . We create a dict with more information about # subkeys , but for backward compatibility reason , have to add it in # as a separate entry 'subkey_info' subkey = [ args[4 ] , args [ 11 ] , None , None ] # keyid , type , fp , grp self . curkey [ \"subkeys\" ] . append ( subkey ) self . _collect_subkey_info ( self . curkey , args ) self . in_subkey = True def ssb ( self , args : list [ str ] ) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" subkey = [ args[4 ] , None , None , None ] # keyid , type , fp , grp self . curkey [ \"subkeys\" ] . append ( subkey ) self . _collect_subkey_info ( self . curkey , args ) self . in_subkey = True def sig ( self , args : list [ str ] ) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" # keyid , uid , sigclass self . curkey [ \"sigs\" ] . append (( args [ 4 ] , args [ 9 ] , args [ 10 ] ))","title":"ListKeysHandler"},{"location":"reference/gnupg/handlers/#ancestors-in-mro_7","text":"gnupg.handlers.SearchKeysHandler gnupg.handlers.StatusHandler builtins.list","title":"Ancestors (in MRO)"},{"location":"reference/gnupg/handlers/#descendants_2","text":"gnupg.handlers.ScanKeysHandler","title":"Descendants"},{"location":"reference/gnupg/handlers/#class-variables_6","text":"FIELDS UID_INDEX returncode","title":"Class variables"},{"location":"reference/gnupg/handlers/#methods_7","text":"","title":"Methods"},{"location":"reference/gnupg/handlers/#append","text":"def append ( self , object , / ) Append object to the end of the list.","title":"append"},{"location":"reference/gnupg/handlers/#clear","text":"def clear ( self , / ) Remove all items from list.","title":"clear"},{"location":"reference/gnupg/handlers/#copy","text":"def copy ( self , / ) Return a shallow copy of the list.","title":"copy"},{"location":"reference/gnupg/handlers/#count","text":"def count ( self , value , / ) Return number of occurrences of value.","title":"count"},{"location":"reference/gnupg/handlers/#extend","text":"def extend ( self , iterable , / ) Extend list by appending elements from the iterable.","title":"extend"},{"location":"reference/gnupg/handlers/#fpr_1","text":"def fpr ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def fpr ( self , args : list [ str ] ) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" fp = args [ 9 ] if fp in self . key_map and self . gpg . check_fingerprint_collisions : # pragma : no cover msg = f \"Unexpected fingerprint collision: {fp}\" raise ValueError ( msg ) if not self . in_subkey : self . curkey [ \"fingerprint\" ] = fp self . fingerprints . append ( fp ) self . key_map [ fp ] = self . curkey else : self . curkey [ \"subkeys\" ][ -1 ][ 2 ] = fp self . key_map [ fp ] = self . curkey","title":"fpr"},{"location":"reference/gnupg/handlers/#get_fields","text":"def get_fields ( self , args : 'list[str]' ) -> 'dict[str, str]' Internal method used to update the instance from a gpg status message. View Source def get_fields ( self , args : list [ str ] ) -> dict [ str , str ] : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" result = {} _set_fields ( result , self . FIELDS , args ) result [ \"uids\" ] = [] result [ \"sigs\" ] = [] return result","title":"get_fields"},{"location":"reference/gnupg/handlers/#grp","text":"def grp ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def grp ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" grp = args [ 9 ] if not self . in_subkey : self . curkey [ \"keygrip\" ] = grp else : self . curkey [ \"subkeys\" ][ - 1 ][ 3 ] = grp","title":"grp"},{"location":"reference/gnupg/handlers/#handle_status_7","text":"def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : # pragma : no cover pass","title":"handle_status"},{"location":"reference/gnupg/handlers/#index","text":"def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present.","title":"index"},{"location":"reference/gnupg/handlers/#insert","text":"def insert ( self , index , object , / ) Insert object before index.","title":"insert"},{"location":"reference/gnupg/handlers/#key","text":"def key ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def key ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" self . curkey = curkey = self . get_fields ( args ) if curkey [ \"uid\" ] : # pragma: no cover curkey [ \"uids\" ] . append ( curkey [ \"uid\" ] ) del curkey [ \"uid\" ] curkey [ \"subkeys\" ] = [] self . append ( curkey ) self . in_subkey = False","title":"key"},{"location":"reference/gnupg/handlers/#pop","text":"def pop ( self , index =- 1 , / ) Remove and return item at index (default last). Raises IndexError if list is empty or index is out of range.","title":"pop"},{"location":"reference/gnupg/handlers/#pub_1","text":"def pub ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def key ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" self . curkey = curkey = self . get_fields ( args ) if curkey [ \"uid\" ] : # pragma: no cover curkey [ \"uids\" ] . append ( curkey [ \"uid\" ] ) del curkey [ \"uid\" ] curkey [ \"subkeys\" ] = [] self . append ( curkey ) self . in_subkey = False","title":"pub"},{"location":"reference/gnupg/handlers/#remove","text":"def remove ( self , value , / ) Remove first occurrence of value. Raises ValueError if the value is not present.","title":"remove"},{"location":"reference/gnupg/handlers/#reverse","text":"def reverse ( self , / ) Reverse IN PLACE .","title":"reverse"},{"location":"reference/gnupg/handlers/#sec","text":"def sec ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def key ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" self . curkey = curkey = self . get_fields ( args ) if curkey [ \"uid\" ] : # pragma: no cover curkey [ \"uids\" ] . append ( curkey [ \"uid\" ] ) del curkey [ \"uid\" ] curkey [ \"subkeys\" ] = [] self . append ( curkey ) self . in_subkey = False","title":"sec"},{"location":"reference/gnupg/handlers/#sig","text":"def sig ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def sig ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" # keyid, uid, sigclass self . curkey [ \"sigs\" ] . append (( args [ 4 ] , args [ 9 ] , args [ 10 ] ))","title":"sig"},{"location":"reference/gnupg/handlers/#sort","text":"def sort ( self , / , * , key = None , reverse = False ) Sort the list in ascending order and return None. The sort is in-place (i.e. the list itself is modified) and stable (i.e. the order of two equal elements is maintained). If a key function is given, apply it once to each list item and sort them, ascending or descending, according to their function values. The reverse flag can be set to sort in descending order.","title":"sort"},{"location":"reference/gnupg/handlers/#ssb","text":"def ssb ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def ssb ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" subkey = [ args [ 4 ], None , None , None ] # keyid , type , fp , grp self . curkey [ \"subkeys\" ]. append ( subkey ) self . _collect_subkey_info ( self . curkey , args ) self . in_subkey = True","title":"ssb"},{"location":"reference/gnupg/handlers/#sub_1","text":"def sub ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def sub ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" # See issue # 81 . We create a dict with more information about # subkeys , but for backward compatibility reason , have to add it in # as a separate entry ' subkey_info ' subkey = [ args [ 4 ], args [ 11 ], None , None ] # keyid , type , fp , grp self . curkey [ \"subkeys\" ]. append ( subkey ) self . _collect_subkey_info ( self . curkey , args ) self . in_subkey = True","title":"sub"},{"location":"reference/gnupg/handlers/#uid_1","text":"def uid ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def uid ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" uid = args [ self . UID_INDEX ] uid = ESCAPE_PATTERN . sub ( lambda m : chr ( int ( m . group ( 1 ), 16 )), uid ) for k , v in BASIC_ESCAPES . items () : uid = uid . replace ( k , v ) self . curkey [ \"uids\" ] . append ( uid ) self . uids . append ( uid )","title":"uid"},{"location":"reference/gnupg/handlers/#scankeyshandler","text":"class ScanKeysHandler ( gpg : 'GPG' ) This class handles status messages during scanning keys. View Source class ScanKeysHandler ( ListKeysHandler ) : \" \"\" This class handles status messages during scanning keys. \"\" \" def sub ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" # --with-fingerprint --with-colons somehow outputs fewer colons, # use the last value args[-1] instead of args[11] subkey = [ args [ 4 ] , args [ - 1 ] , None , None ] self . curkey [ \"subkeys\" ] . append ( subkey ) self . _collect_subkey_info ( self . curkey , args ) self . in_subkey = True","title":"ScanKeysHandler"},{"location":"reference/gnupg/handlers/#ancestors-in-mro_8","text":"gnupg.handlers.ListKeysHandler gnupg.handlers.SearchKeysHandler gnupg.handlers.StatusHandler builtins.list","title":"Ancestors (in MRO)"},{"location":"reference/gnupg/handlers/#class-variables_7","text":"FIELDS UID_INDEX returncode","title":"Class variables"},{"location":"reference/gnupg/handlers/#methods_8","text":"","title":"Methods"},{"location":"reference/gnupg/handlers/#append_1","text":"def append ( self , object , / ) Append object to the end of the list.","title":"append"},{"location":"reference/gnupg/handlers/#clear_1","text":"def clear ( self , / ) Remove all items from list.","title":"clear"},{"location":"reference/gnupg/handlers/#copy_1","text":"def copy ( self , / ) Return a shallow copy of the list.","title":"copy"},{"location":"reference/gnupg/handlers/#count_1","text":"def count ( self , value , / ) Return number of occurrences of value.","title":"count"},{"location":"reference/gnupg/handlers/#extend_1","text":"def extend ( self , iterable , / ) Extend list by appending elements from the iterable.","title":"extend"},{"location":"reference/gnupg/handlers/#fpr_2","text":"def fpr ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def fpr ( self , args : list [ str ] ) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" fp = args [ 9 ] if fp in self . key_map and self . gpg . check_fingerprint_collisions : # pragma : no cover msg = f \"Unexpected fingerprint collision: {fp}\" raise ValueError ( msg ) if not self . in_subkey : self . curkey [ \"fingerprint\" ] = fp self . fingerprints . append ( fp ) self . key_map [ fp ] = self . curkey else : self . curkey [ \"subkeys\" ][ -1 ][ 2 ] = fp self . key_map [ fp ] = self . curkey","title":"fpr"},{"location":"reference/gnupg/handlers/#get_fields_1","text":"def get_fields ( self , args : 'list[str]' ) -> 'dict[str, str]' Internal method used to update the instance from a gpg status message. View Source def get_fields ( self , args : list [ str ] ) -> dict [ str , str ] : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" result = {} _set_fields ( result , self . FIELDS , args ) result [ \"uids\" ] = [] result [ \"sigs\" ] = [] return result","title":"get_fields"},{"location":"reference/gnupg/handlers/#grp_1","text":"def grp ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def grp ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" grp = args [ 9 ] if not self . in_subkey : self . curkey [ \"keygrip\" ] = grp else : self . curkey [ \"subkeys\" ][ - 1 ][ 3 ] = grp","title":"grp"},{"location":"reference/gnupg/handlers/#handle_status_8","text":"def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : # pragma : no cover pass","title":"handle_status"},{"location":"reference/gnupg/handlers/#index_1","text":"def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present.","title":"index"},{"location":"reference/gnupg/handlers/#insert_1","text":"def insert ( self , index , object , / ) Insert object before index.","title":"insert"},{"location":"reference/gnupg/handlers/#key_1","text":"def key ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def key ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" self . curkey = curkey = self . get_fields ( args ) if curkey [ \"uid\" ] : # pragma: no cover curkey [ \"uids\" ] . append ( curkey [ \"uid\" ] ) del curkey [ \"uid\" ] curkey [ \"subkeys\" ] = [] self . append ( curkey ) self . in_subkey = False","title":"key"},{"location":"reference/gnupg/handlers/#pop_1","text":"def pop ( self , index =- 1 , / ) Remove and return item at index (default last). Raises IndexError if list is empty or index is out of range.","title":"pop"},{"location":"reference/gnupg/handlers/#pub_2","text":"def pub ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def key ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" self . curkey = curkey = self . get_fields ( args ) if curkey [ \"uid\" ] : # pragma: no cover curkey [ \"uids\" ] . append ( curkey [ \"uid\" ] ) del curkey [ \"uid\" ] curkey [ \"subkeys\" ] = [] self . append ( curkey ) self . in_subkey = False","title":"pub"},{"location":"reference/gnupg/handlers/#remove_1","text":"def remove ( self , value , / ) Remove first occurrence of value. Raises ValueError if the value is not present.","title":"remove"},{"location":"reference/gnupg/handlers/#reverse_1","text":"def reverse ( self , / ) Reverse IN PLACE .","title":"reverse"},{"location":"reference/gnupg/handlers/#sec_1","text":"def sec ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def key ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" self . curkey = curkey = self . get_fields ( args ) if curkey [ \"uid\" ] : # pragma: no cover curkey [ \"uids\" ] . append ( curkey [ \"uid\" ] ) del curkey [ \"uid\" ] curkey [ \"subkeys\" ] = [] self . append ( curkey ) self . in_subkey = False","title":"sec"},{"location":"reference/gnupg/handlers/#sig_1","text":"def sig ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def sig ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" # keyid, uid, sigclass self . curkey [ \"sigs\" ] . append (( args [ 4 ] , args [ 9 ] , args [ 10 ] ))","title":"sig"},{"location":"reference/gnupg/handlers/#sort_1","text":"def sort ( self , / , * , key = None , reverse = False ) Sort the list in ascending order and return None. The sort is in-place (i.e. the list itself is modified) and stable (i.e. the order of two equal elements is maintained). If a key function is given, apply it once to each list item and sort them, ascending or descending, according to their function values. The reverse flag can be set to sort in descending order.","title":"sort"},{"location":"reference/gnupg/handlers/#ssb_1","text":"def ssb ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def ssb ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" subkey = [ args [ 4 ], None , None , None ] # keyid , type , fp , grp self . curkey [ \"subkeys\" ]. append ( subkey ) self . _collect_subkey_info ( self . curkey , args ) self . in_subkey = True","title":"ssb"},{"location":"reference/gnupg/handlers/#sub_2","text":"def sub ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def sub ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" # --with-fingerprint --with-colons somehow outputs fewer colons, # use the last value args[-1] instead of args[11] subkey = [ args [ 4 ] , args [ - 1 ] , None , None ] self . curkey [ \"subkeys\" ] . append ( subkey ) self . _collect_subkey_info ( self . curkey , args ) self . in_subkey = True","title":"sub"},{"location":"reference/gnupg/handlers/#uid_2","text":"def uid ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def uid ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" uid = args [ self . UID_INDEX ] uid = ESCAPE_PATTERN . sub ( lambda m : chr ( int ( m . group ( 1 ), 16 )), uid ) for k , v in BASIC_ESCAPES . items () : uid = uid . replace ( k , v ) self . curkey [ \"uids\" ] . append ( uid ) self . uids . append ( uid )","title":"uid"},{"location":"reference/gnupg/handlers/#searchkeyshandler","text":"class SearchKeysHandler ( gpg : 'GPG' ) This class handles status messages during key search. View Source class SearchKeysHandler ( StatusHandler , list ): \"\"\" This class handles status messages during key search. \"\"\" # Handle pub and uid ( relating the latter to the former ). # Don ' t care about the rest UID_INDEX = 1 FIELDS = \"type keyid algo length date expires\" . split () returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . curkey = None self . fingerprints = [] self . uids = [] def get_fields ( self , args : list [ str ]) -> dict [ str , str ]: \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" result = {} _set_fields ( result , self . FIELDS , args ) result [ \"uids\" ] = [] result [ \"sigs\" ] = [] return result def pub ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" self . curkey = curkey = self . get_fields ( args ) self . append ( curkey ) def uid ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" uid = args [ self . UID_INDEX ] uid = ESCAPE_PATTERN . sub ( lambda m : chr ( int ( m . group ( 1 ), 16 )), uid ) for k , v in BASIC_ESCAPES . items (): uid = uid . replace ( k , v ) self . curkey [ \"uids\" ]. append ( uid ) self . uids . append ( uid ) def handle_status ( self , key : str , value : str ) -> None : # pragma : no cover pass","title":"SearchKeysHandler"},{"location":"reference/gnupg/handlers/#ancestors-in-mro_9","text":"gnupg.handlers.StatusHandler builtins.list","title":"Ancestors (in MRO)"},{"location":"reference/gnupg/handlers/#descendants_3","text":"gnupg.handlers.ListKeysHandler","title":"Descendants"},{"location":"reference/gnupg/handlers/#class-variables_8","text":"FIELDS UID_INDEX returncode","title":"Class variables"},{"location":"reference/gnupg/handlers/#methods_9","text":"","title":"Methods"},{"location":"reference/gnupg/handlers/#append_2","text":"def append ( self , object , / ) Append object to the end of the list.","title":"append"},{"location":"reference/gnupg/handlers/#clear_2","text":"def clear ( self , / ) Remove all items from list.","title":"clear"},{"location":"reference/gnupg/handlers/#copy_2","text":"def copy ( self , / ) Return a shallow copy of the list.","title":"copy"},{"location":"reference/gnupg/handlers/#count_2","text":"def count ( self , value , / ) Return number of occurrences of value.","title":"count"},{"location":"reference/gnupg/handlers/#extend_2","text":"def extend ( self , iterable , / ) Extend list by appending elements from the iterable.","title":"extend"},{"location":"reference/gnupg/handlers/#get_fields_2","text":"def get_fields ( self , args : 'list[str]' ) -> 'dict[str, str]' Internal method used to update the instance from a gpg status message. View Source def get_fields ( self , args : list [ str ] ) -> dict [ str , str ] : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" result = {} _set_fields ( result , self . FIELDS , args ) result [ \"uids\" ] = [] result [ \"sigs\" ] = [] return result","title":"get_fields"},{"location":"reference/gnupg/handlers/#handle_status_9","text":"def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : # pragma : no cover pass","title":"handle_status"},{"location":"reference/gnupg/handlers/#index_2","text":"def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present.","title":"index"},{"location":"reference/gnupg/handlers/#insert_2","text":"def insert ( self , index , object , / ) Insert object before index.","title":"insert"},{"location":"reference/gnupg/handlers/#pop_2","text":"def pop ( self , index =- 1 , / ) Remove and return item at index (default last). Raises IndexError if list is empty or index is out of range.","title":"pop"},{"location":"reference/gnupg/handlers/#pub_3","text":"def pub ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def pub ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" self . curkey = curkey = self . get_fields ( args ) self . append ( curkey )","title":"pub"},{"location":"reference/gnupg/handlers/#remove_2","text":"def remove ( self , value , / ) Remove first occurrence of value. Raises ValueError if the value is not present.","title":"remove"},{"location":"reference/gnupg/handlers/#reverse_2","text":"def reverse ( self , / ) Reverse IN PLACE .","title":"reverse"},{"location":"reference/gnupg/handlers/#sort_2","text":"def sort ( self , / , * , key = None , reverse = False ) Sort the list in ascending order and return None. The sort is in-place (i.e. the list itself is modified) and stable (i.e. the order of two equal elements is maintained). If a key function is given, apply it once to each list item and sort them, ascending or descending, according to their function values. The reverse flag can be set to sort in descending order.","title":"sort"},{"location":"reference/gnupg/handlers/#uid_3","text":"def uid ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def uid ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" uid = args [ self . UID_INDEX ] uid = ESCAPE_PATTERN . sub ( lambda m : chr ( int ( m . group ( 1 ), 16 )), uid ) for k , v in BASIC_ESCAPES . items () : uid = uid . replace ( k , v ) self . curkey [ \"uids\" ] . append ( uid ) self . uids . append ( uid )","title":"uid"},{"location":"reference/gnupg/handlers/#sendresulthandler","text":"class SendResultHandler ( gpg : 'GPG' ) This class handles status messages during key sending. View Source class SendResultHandler ( StatusHandler ): \"\"\" This class handles status messages during key sending. \"\"\" returncode = None def handle_status ( self , key: str , value: str ) -> None: logger . debug ( \"SendResult: %s: %s\" , key , value )","title":"SendResultHandler"},{"location":"reference/gnupg/handlers/#ancestors-in-mro_10","text":"gnupg.handlers.StatusHandler","title":"Ancestors (in MRO)"},{"location":"reference/gnupg/handlers/#class-variables_9","text":"returncode","title":"Class variables"},{"location":"reference/gnupg/handlers/#methods_10","text":"","title":"Methods"},{"location":"reference/gnupg/handlers/#handle_status_10","text":"def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : logger . debug ( \"SendResult: %s: %s\" , key , value )","title":"handle_status"},{"location":"reference/gnupg/handlers/#signhandler","text":"class SignHandler ( gpg : 'GPG' ) This class handles status messages during signing. View Source class SignHandler ( StatusHandler , TextHandler ): \"\"\" This class handles status messages during signing. \"\"\" returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . type = None self . hash_algo = None self . fingerprint = None self . status = None self . status_detail = None self . key_id = None self . username = None def __nonzero__ ( self ) -> bool : return self . fingerprint is not None __bool__ = __nonzero__ def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" , \"FAILURE\" ): # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key in ( \"KEYEXPIRED\" , \"SIGEXPIRED\" ): # pragma : no cover self . status = \"key expired\" elif key == \"KEYREVOKED\" : # pragma : no cover self . status = \"key revoked\" elif key == \"SIG_CREATED\" : ( self . type , algo , self . hash_algo , cls , self . timestamp , self . fingerprint ) = value . split () self . status = \"signature created\" elif key == \"USERID_HINT\" : # pragma : no cover self . key_id , self . username = value . split ( \" \" , 1 ) elif key == \"BAD_PASSPHRASE\" : # pragma : no cover self . status = \"bad passphrase\" elif key in ( \"INV_SGNR\" , \"INV_RECP\" ): # pragma : no cover # INV_RECP is returned in older versions if not self . status : self . status = \"invalid signer\" else : self . status = f \"invalid signer: {self.status}\" self . status_detail = _determine_invalid_recipient_or_signer ( value ) elif key in ( \"NEED_PASSPHRASE\" , \"GOOD_PASSPHRASE\" , \"BEGIN_SIGNING\" ): pass else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value )","title":"SignHandler"},{"location":"reference/gnupg/handlers/#ancestors-in-mro_11","text":"gnupg.handlers.StatusHandler gnupg.handlers.text_handler.TextHandler","title":"Ancestors (in MRO)"},{"location":"reference/gnupg/handlers/#class-variables_10","text":"returncode","title":"Class variables"},{"location":"reference/gnupg/handlers/#methods_11","text":"","title":"Methods"},{"location":"reference/gnupg/handlers/#handle_status_11","text":"def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" , \"FAILURE\" ): # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key in ( \"KEYEXPIRED\" , \"SIGEXPIRED\" ): # pragma : no cover self . status = \"key expired\" elif key == \"KEYREVOKED\" : # pragma : no cover self . status = \"key revoked\" elif key == \"SIG_CREATED\" : ( self . type , algo , self . hash_algo , cls , self . timestamp , self . fingerprint ) = value . split () self . status = \"signature created\" elif key == \"USERID_HINT\" : # pragma : no cover self . key_id , self . username = value . split ( \" \" , 1 ) elif key == \"BAD_PASSPHRASE\" : # pragma : no cover self . status = \"bad passphrase\" elif key in ( \"INV_SGNR\" , \"INV_RECP\" ): # pragma : no cover # INV_RECP is returned in older versions if not self . status : self . status = \"invalid signer\" else : self . status = f \"invalid signer: {self.status}\" self . status_detail = _determine_invalid_recipient_or_signer ( value ) elif key in ( \"NEED_PASSPHRASE\" , \"GOOD_PASSPHRASE\" , \"BEGIN_SIGNING\" ): pass else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value )","title":"handle_status"},{"location":"reference/gnupg/handlers/#statushandler","text":"class StatusHandler ( gpg : 'GPG' ) The base class for handling status messages from gpg . View Source class StatusHandler : \" \"\" The base class for handling status messages from `gpg`. \"\" \" def __init__ ( self , gpg : GPG ) -> None : \" \"\" Initialize an instance. Args: gpg (GPG): The :class:`GPG` instance in use. \"\" \" self . gpg = gpg self . data : str | None = None def handle_status ( self , key : str , value : str ) -> NoReturn : \" \"\" Handle status messages from the `gpg` child process. These are lines of the format [GNUPG:] <key> <value> Args: key (str): Identifies what the status message is. value (str): Identifies additional data, which differs depending on the key. \"\" \" raise NotImplementedError","title":"StatusHandler"},{"location":"reference/gnupg/handlers/#descendants_4","text":"gnupg.handlers.AddSubkeyHandler gnupg.handlers.AutoLocateKeyHandler gnupg.handlers.VerifyHandler gnupg.handlers.DeleteResultHandler gnupg.handlers.GenKeyHandler gnupg.handlers.ImportResultHandler gnupg.handlers.SearchKeysHandler gnupg.handlers.SendResultHandler gnupg.handlers.SignHandler","title":"Descendants"},{"location":"reference/gnupg/handlers/#methods_12","text":"","title":"Methods"},{"location":"reference/gnupg/handlers/#handle_status_12","text":"def handle_status ( self , key : 'str' , value : 'str' ) -> 'NoReturn' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> NoReturn : \" \"\" Handle status messages from the `gpg` child process. These are lines of the format [GNUPG:] <key> <value> Args: key (str): Identifies what the status message is. value (str): Identifies additional data, which differs depending on the key. \"\" \" raise NotImplementedError","title":"handle_status"},{"location":"reference/gnupg/handlers/#trustresulthandler","text":"class TrustResultHandler ( gpg : 'GPG' ) This class handles status messages during key trust setting. View Source class TrustResultHandler ( DeleteResultHandler ): \"\"\" This class handles status messages during key trust setting. \"\"\"","title":"TrustResultHandler"},{"location":"reference/gnupg/handlers/#ancestors-in-mro_12","text":"gnupg.handlers.DeleteResultHandler gnupg.handlers.StatusHandler","title":"Ancestors (in MRO)"},{"location":"reference/gnupg/handlers/#class-variables_11","text":"problem_reason returncode","title":"Class variables"},{"location":"reference/gnupg/handlers/#methods_13","text":"","title":"Methods"},{"location":"reference/gnupg/handlers/#handle_status_13","text":"def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : if key == \"DELETE_PROBLEM\" : # pragma : no cover self . status = self . problem_reason . get ( value , f \"Unknown error: {value!r}\" ) else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value )","title":"handle_status"},{"location":"reference/gnupg/handlers/#verifyhandler","text":"class VerifyHandler ( gpg : 'GPG' ) This class handles status messages during signature verificaton. View Source class VerifyHandler ( StatusHandler ) : \"\"\" This class handles status messages during signature verificaton. \"\"\" TRUST_EXPIRED = 0 TRUST_UNDEFINED = 1 TRUST_NEVER = 2 TRUST_MARGINAL = 3 TRUST_FULLY = 4 TRUST_ULTIMATE = 5 TRUST_LEVELS = MappingProxyType ( { \"TRUST_EXPIRED\" : TRUST_EXPIRED , \"TRUST_UNDEFINED\" : TRUST_UNDEFINED , \"TRUST_NEVER\" : TRUST_NEVER , \"TRUST_MARGINAL\" : TRUST_MARGINAL , \"TRUST_FULLY\" : TRUST_FULLY , \"TRUST_ULTIMATE\" : TRUST_ULTIMATE , } , ) # for now , just the most common error codes . This can be expanded as and # when reports come in of other errors . GPG_SYSTEM_ERROR_CODES = MappingProxyType ( { 1 : \"permission denied\" , 35 : \"file exists\" , 81 : \"file not found\" , 97 : \"not a directory\" , } , ) GPG_ERROR_CODES = MappingProxyType ( { 11 : \"incorrect passphrase\" , } , ) returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . valid = False self . fingerprint = self . creation_date = self . timestamp = None self . signature_id = self . key_id = None self . username = None self . key_id = None self . key_status = None self . status = None self . pubkey_fingerprint = None self . expire_timestamp = None self . sig_timestamp = None self . trust_text = None self . trust_level = None self . sig_info = {} self . problems = [] def __nonzero__ ( self ) -> bool : # pragma : no cover return self . valid __bool__ = __nonzero__ def handle_status ( self , key : str , value : str ) -> None : def update_sig_info ( ** kwargs : object ) -> None : sig_id = self . signature_id if sig_id : info = self . sig_info [ sig_id ] info . update ( kwargs ) else : logger . debug ( \"Ignored due to missing sig iD: %s\" , kwargs ) if key in self . TRUST_LEVELS : self . trust_text = key self . trust_level = self . TRUST_LEVELS [ key ] update_sig_info ( trust_level = self . trust_level , trust_text = self . trust_text ) # See Issue #214 . Once we see this , we 're done with the signature just seen. # Zap the signature ID, because we don' t see a SIG_ID unless we have a new # good signature . self . signature_id = None elif key in ( \"WARNING\" , \"ERROR\" ) : # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key == \"BADSIG\" : # pragma : no cover self . valid = False self . status = \"signature bad\" self . key_id , self . username = value . split ( None , 1 ) self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id , \"user\" : self . username } ) update_sig_info ( keyid = self . key_id , username = self . username , status = self . status ) elif key == \"ERRSIG\" : # pragma : no cover self . valid = False parts = value . split () ( self . key_id , algo , hash_algo , cls , self . timestamp ) = parts [ :5 ] # Since GnuPG 2.2.7 , a fingerprint is tacked on if len ( parts ) >= 7 : # noqa : PLR2004 self . fingerprint = parts [ 6 ] self . status = \"signature error\" update_sig_info ( keyid = self . key_id , timestamp = self . timestamp , fingerprint = self . fingerprint , status = self . status , ) self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id , \"timestamp\" : self . timestamp , \"fingerprint\" : self . fingerprint , } , ) elif key == \"EXPSIG\" : # pragma : no cover self . valid = False self . status = \"signature expired\" self . key_id , self . username = value . split ( None , 1 ) update_sig_info ( keyid = self . key_id , username = self . username , status = self . status ) self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id , \"user\" : self . username } ) elif key == \"GOODSIG\" : self . valid = True self . status = \"signature good\" self . key_id , self . username = value . split ( None , 1 ) update_sig_info ( keyid = self . key_id , username = self . username , status = self . status ) elif key == \"VALIDSIG\" : parts = value . split () fingerprint , creation_date , sig_ts , expire_ts = parts [ :4 ] ( self . fingerprint , self . creation_date , self . sig_timestamp , self . expire_timestamp ) = ( fingerprint , creation_date , sig_ts , expire_ts , ) # may be different if signature is made with a subkey if len ( parts ) >= 10 : # noqa : PLR2004 self . pubkey_fingerprint = parts [ 9 ] self . status = \"signature valid\" update_sig_info ( fingerprint = fingerprint , creation_date = creation_date , timestamp = sig_ts , expiry = expire_ts , pubkey_fingerprint = self . pubkey_fingerprint , status = self . status , ) elif key == \"SIG_ID\" : sig_id , creation_date , timestamp = value . split () self . sig_info [ sig_id ] = { \"creation_date\" : creation_date , \"timestamp\" : timestamp } ( self . signature_id , self . creation_date , self . timestamp ) = ( sig_id , creation_date , timestamp ) elif key == \"NO_PUBKEY\" : # pragma : no cover self . valid = False self . key_id = value self . status = \"no public key\" self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id } ) elif key == \"NO_SECKEY\" : # pragma : no cover self . valid = False self . key_id = value self . status = \"no secret key\" self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id } ) elif key in ( \"EXPKEYSIG\" , \"REVKEYSIG\" ) : # pragma : no cover # signed with expired or revoked key self . valid = False self . key_id = value . split () [ 0 ] if key == \"EXPKEYSIG\" : self . key_status = \"signing key has expired\" else : self . key_status = \"signing key was revoked\" self . status = self . key_status update_sig_info ( status = self . status , keyid = self . key_id ) self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id } ) elif key in ( \"UNEXPECTED\" , \"FAILURE\" ) : # pragma : no cover self . valid = False if key == \"UNEXPECTED\" : self . status = \"unexpected data\" else : # N . B . there might be other reasons . For example , if an output # file can ' t be created - / dev / null / foo will lead to a # \"not a directory\" error , but which is not sent as a status # message with the [ GNUPG: ] prefix . Similarly if you try to # write to \"/etc/foo\" as a non - root user , a \"permission denied\" # error will be sent as a non - status message . message = f \"error - {value}\" operation , code = value . rsplit ( \" \" , 1 ) if code . isdigit () : code = int ( code ) & 0xFFFFFF # lose the error source if self . gpg . error_map and code in self . gpg . error_map : message = f \"{operation}: {self.gpg.error_map[code]}\" else : system_error = bool ( code & 0x8000 ) code = code & 0x7FFF mapping = self . GPG_SYSTEM_ERROR_CODES if system_error else self . GPG_ERROR_CODES if code in mapping : message = f \"{operation}: {mapping[code]}\" if not self . status : self . status = message elif key == \"NODATA\" : # pragma : no cover # See issue GH - 191 self . valid = False self . status = \"signature expected but not found\" elif key in ( \"DECRYPTION_INFO\" , \"PLAINTEXT\" , \"PLAINTEXT_LENGTH\" , \"BEGIN_SIGNING\" , \"KEY_CONSIDERED\" ) : pass elif key in ( \"NEWSIG\" ,) : # Only sent in gpg2 . Clear any signature ID , to be set by a following SIG_ID self . signature_id = None else : # pragma : no cover logger . debug ( \"message ignored: %r, %r\" , key , value )","title":"VerifyHandler"},{"location":"reference/gnupg/handlers/#ancestors-in-mro_13","text":"gnupg.handlers.StatusHandler","title":"Ancestors (in MRO)"},{"location":"reference/gnupg/handlers/#descendants_5","text":"gnupg.handlers.CryptHandler","title":"Descendants"},{"location":"reference/gnupg/handlers/#class-variables_12","text":"GPG_ERROR_CODES GPG_SYSTEM_ERROR_CODES TRUST_EXPIRED TRUST_FULLY TRUST_LEVELS TRUST_MARGINAL TRUST_NEVER TRUST_ULTIMATE TRUST_UNDEFINED returncode","title":"Class variables"},{"location":"reference/gnupg/handlers/#methods_14","text":"","title":"Methods"},{"location":"reference/gnupg/handlers/#handle_status_14","text":"def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : def update_sig_info ( ** kwargs : object ) -> None : sig_id = self . signature_id if sig_id : info = self . sig_info [ sig_id ] info . update ( kwargs ) else : logger . debug ( \"Ignored due to missing sig iD: %s\" , kwargs ) if key in self . TRUST_LEVELS : self . trust_text = key self . trust_level = self . TRUST_LEVELS [ key ] update_sig_info ( trust_level = self . trust_level , trust_text = self . trust_text ) # See Issue #214 . Once we see this , we 're done with the signature just seen. # Zap the signature ID, because we don' t see a SIG_ID unless we have a new # good signature . self . signature_id = None elif key in ( \"WARNING\" , \"ERROR\" ) : # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key == \"BADSIG\" : # pragma : no cover self . valid = False self . status = \"signature bad\" self . key_id , self . username = value . split ( None , 1 ) self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id , \"user\" : self . username } ) update_sig_info ( keyid = self . key_id , username = self . username , status = self . status ) elif key == \"ERRSIG\" : # pragma : no cover self . valid = False parts = value . split () ( self . key_id , algo , hash_algo , cls , self . timestamp ) = parts [ :5 ] # Since GnuPG 2.2.7 , a fingerprint is tacked on if len ( parts ) >= 7 : # noqa : PLR2004 self . fingerprint = parts [ 6 ] self . status = \"signature error\" update_sig_info ( keyid = self . key_id , timestamp = self . timestamp , fingerprint = self . fingerprint , status = self . status , ) self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id , \"timestamp\" : self . timestamp , \"fingerprint\" : self . fingerprint , } , ) elif key == \"EXPSIG\" : # pragma : no cover self . valid = False self . status = \"signature expired\" self . key_id , self . username = value . split ( None , 1 ) update_sig_info ( keyid = self . key_id , username = self . username , status = self . status ) self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id , \"user\" : self . username } ) elif key == \"GOODSIG\" : self . valid = True self . status = \"signature good\" self . key_id , self . username = value . split ( None , 1 ) update_sig_info ( keyid = self . key_id , username = self . username , status = self . status ) elif key == \"VALIDSIG\" : parts = value . split () fingerprint , creation_date , sig_ts , expire_ts = parts [ :4 ] ( self . fingerprint , self . creation_date , self . sig_timestamp , self . expire_timestamp ) = ( fingerprint , creation_date , sig_ts , expire_ts , ) # may be different if signature is made with a subkey if len ( parts ) >= 10 : # noqa : PLR2004 self . pubkey_fingerprint = parts [ 9 ] self . status = \"signature valid\" update_sig_info ( fingerprint = fingerprint , creation_date = creation_date , timestamp = sig_ts , expiry = expire_ts , pubkey_fingerprint = self . pubkey_fingerprint , status = self . status , ) elif key == \"SIG_ID\" : sig_id , creation_date , timestamp = value . split () self . sig_info [ sig_id ] = { \"creation_date\" : creation_date , \"timestamp\" : timestamp } ( self . signature_id , self . creation_date , self . timestamp ) = ( sig_id , creation_date , timestamp ) elif key == \"NO_PUBKEY\" : # pragma : no cover self . valid = False self . key_id = value self . status = \"no public key\" self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id } ) elif key == \"NO_SECKEY\" : # pragma : no cover self . valid = False self . key_id = value self . status = \"no secret key\" self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id } ) elif key in ( \"EXPKEYSIG\" , \"REVKEYSIG\" ) : # pragma : no cover # signed with expired or revoked key self . valid = False self . key_id = value . split () [ 0 ] if key == \"EXPKEYSIG\" : self . key_status = \"signing key has expired\" else : self . key_status = \"signing key was revoked\" self . status = self . key_status update_sig_info ( status = self . status , keyid = self . key_id ) self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id } ) elif key in ( \"UNEXPECTED\" , \"FAILURE\" ) : # pragma : no cover self . valid = False if key == \"UNEXPECTED\" : self . status = \"unexpected data\" else : # N . B . there might be other reasons . For example , if an output # file can ' t be created - / dev / null / foo will lead to a # \"not a directory\" error , but which is not sent as a status # message with the [ GNUPG: ] prefix . Similarly if you try to # write to \"/etc/foo\" as a non - root user , a \"permission denied\" # error will be sent as a non - status message . message = f \"error - {value}\" operation , code = value . rsplit ( \" \" , 1 ) if code . isdigit () : code = int ( code ) & 0xFFFFFF # lose the error source if self . gpg . error_map and code in self . gpg . error_map : message = f \"{operation}: {self.gpg.error_map[code]}\" else : system_error = bool ( code & 0x8000 ) code = code & 0x7FFF mapping = self . GPG_SYSTEM_ERROR_CODES if system_error else self . GPG_ERROR_CODES if code in mapping : message = f \"{operation}: {mapping[code]}\" if not self . status : self . status = message elif key == \"NODATA\" : # pragma : no cover # See issue GH - 191 self . valid = False self . status = \"signature expected but not found\" elif key in ( \"DECRYPTION_INFO\" , \"PLAINTEXT\" , \"PLAINTEXT_LENGTH\" , \"BEGIN_SIGNING\" , \"KEY_CONSIDERED\" ) : pass elif key in ( \"NEWSIG\" ,) : # Only sent in gpg2 . Clear any signature ID , to be set by a following SIG_ID self . signature_id = None else : # pragma : no cover logger . debug ( \"message ignored: %r, %r\" , key , value )","title":"handle_status"},{"location":"reference/gnupg/handlers/add_subkey_handler/","text":"Module gnupg.handlers.add_subkey_handler View Source from __future__ import annotations from typing import TYPE_CHECKING from gnupg.helper import _get_logger from .status_handler import StatusHandler if TYPE_CHECKING : from gnupg.gnupg import GPG logger = _get_logger ( __name__ ) class AddSubkeyHandler ( StatusHandler ): \"\"\" This class handles status messages during subkey addition. \"\"\" returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . type = None self . fingerprint = \"\" self . status = None def __nonzero__ ( self ) -> bool : # pragma: no cover return bool ( self . fingerprint ) __bool__ = __nonzero__ def __str__ ( self ) -> str : return self . fingerprint def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ): # pragma: no cover logger . warning ( \"potential problem: %s : %s \" , key , value ) elif key == \"KEY_CREATED\" : ( self . type , self . fingerprint ) = value . split () self . status = \"ok\" else : # pragma: no cover logger . debug ( \"message ignored: %s , %s \" , key , value ) Variables TYPE_CHECKING logger Classes AddSubkeyHandler class AddSubkeyHandler ( gpg : 'GPG' ) This class handles status messages during subkey addition. View Source class AddSubkeyHandler ( StatusHandler ): \"\"\" This class handles status messages during subkey addition. \"\"\" returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . type = None self . fingerprint = \"\" self . status = None def __nonzero__ ( self ) -> bool : # pragma : no cover return bool ( self . fingerprint ) __bool__ = __nonzero__ def __str__ ( self ) -> str : return self . fingerprint def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ): # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key == \"KEY_CREATED\" : ( self . type , self . fingerprint ) = value . split () self . status = \"ok\" else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value ) Ancestors (in MRO) gnupg.handlers.status_handler.StatusHandler Class variables returncode Methods handle_status def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ): # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key == \"KEY_CREATED\" : ( self . type , self . fingerprint ) = value . split () self . status = \"ok\" else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value )","title":"Add Subkey Handler"},{"location":"reference/gnupg/handlers/add_subkey_handler/#module-gnupghandlersadd_subkey_handler","text":"View Source from __future__ import annotations from typing import TYPE_CHECKING from gnupg.helper import _get_logger from .status_handler import StatusHandler if TYPE_CHECKING : from gnupg.gnupg import GPG logger = _get_logger ( __name__ ) class AddSubkeyHandler ( StatusHandler ): \"\"\" This class handles status messages during subkey addition. \"\"\" returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . type = None self . fingerprint = \"\" self . status = None def __nonzero__ ( self ) -> bool : # pragma: no cover return bool ( self . fingerprint ) __bool__ = __nonzero__ def __str__ ( self ) -> str : return self . fingerprint def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ): # pragma: no cover logger . warning ( \"potential problem: %s : %s \" , key , value ) elif key == \"KEY_CREATED\" : ( self . type , self . fingerprint ) = value . split () self . status = \"ok\" else : # pragma: no cover logger . debug ( \"message ignored: %s , %s \" , key , value )","title":"Module gnupg.handlers.add_subkey_handler"},{"location":"reference/gnupg/handlers/add_subkey_handler/#variables","text":"TYPE_CHECKING logger","title":"Variables"},{"location":"reference/gnupg/handlers/add_subkey_handler/#classes","text":"","title":"Classes"},{"location":"reference/gnupg/handlers/add_subkey_handler/#addsubkeyhandler","text":"class AddSubkeyHandler ( gpg : 'GPG' ) This class handles status messages during subkey addition. View Source class AddSubkeyHandler ( StatusHandler ): \"\"\" This class handles status messages during subkey addition. \"\"\" returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . type = None self . fingerprint = \"\" self . status = None def __nonzero__ ( self ) -> bool : # pragma : no cover return bool ( self . fingerprint ) __bool__ = __nonzero__ def __str__ ( self ) -> str : return self . fingerprint def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ): # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key == \"KEY_CREATED\" : ( self . type , self . fingerprint ) = value . split () self . status = \"ok\" else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value )","title":"AddSubkeyHandler"},{"location":"reference/gnupg/handlers/add_subkey_handler/#ancestors-in-mro","text":"gnupg.handlers.status_handler.StatusHandler","title":"Ancestors (in MRO)"},{"location":"reference/gnupg/handlers/add_subkey_handler/#class-variables","text":"returncode","title":"Class variables"},{"location":"reference/gnupg/handlers/add_subkey_handler/#methods","text":"","title":"Methods"},{"location":"reference/gnupg/handlers/add_subkey_handler/#handle_status","text":"def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ): # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key == \"KEY_CREATED\" : ( self . type , self . fingerprint ) = value . split () self . status = \"ok\" else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value )","title":"handle_status"},{"location":"reference/gnupg/handlers/auto_locate_key_handler/","text":"Module gnupg.handlers.auto_locate_key_handler View Source from __future__ import annotations from datetime import datetime from email.utils import parseaddr from typing import TYPE_CHECKING from .status_handler import StatusHandler if TYPE_CHECKING : from gnupg.gnupg import GPG class AutoLocateKeyHandler ( StatusHandler ): \"\"\" This class handles status messages during key auto-locating. fingerprint: str key_length: int created_at: date email: str email_real_name: str \"\"\" def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . fingerprint = None self . type = None self . created_at = None self . email = None self . email_real_name = None def handle_status ( self , key : str , value : str ) -> None : if key == \"IMPORTED\" : _ , email , display_name = value . split () self . email = email self . email_real_name = display_name [ 1 : - 1 ] elif key == \"KEY_CONSIDERED\" : self . fingerprint = value . strip () . split ()[ 0 ] def pub ( self , args : list [ str ]) -> None : \"\"\" Internal method to handle the 'pub' status message. `pub` message contains the fingerprint of the public key, its type and its creation date. \"\"\" def uid ( self , args : list [ str ]) -> None : local_tz = datetime . now () . astimezone () . tzinfo self . created_at = datetime . fromtimestamp ( int ( args [ 5 ]), tz = local_tz ) raw_email_content = args [ 9 ] email , real_name = parseaddr ( raw_email_content ) self . email = email self . email_real_name = real_name def sub ( self , args : list [ str ]) -> None : self . key_length = int ( args [ 2 ]) def fpr ( self , args : list [ str ]) -> None : # Only store the first fingerprint self . fingerprint = self . fingerprint or args [ 9 ] Variables TYPE_CHECKING Classes AutoLocateKeyHandler class AutoLocateKeyHandler ( gpg : 'GPG' ) This class handles status messages during key auto-locating. fingerprint: str key_length: int created_at: date email: str email_real_name: str View Source class AutoLocateKeyHandler ( StatusHandler ) : \"\"\" This class handles status messages during key auto-locating. fingerprint: str key_length: int created_at: date email: str email_real_name: str \"\"\" def __ init__ ( self , gpg : GPG ) -> None : StatusHandler . __ init__ ( self , gpg ) self . fingerprint = None self . type = None self . created_at = None self . email = None self . email_real_name = None def handle_status ( self , key : str , val ue : str ) -> None : if key == \"IMPORTED\" : _ , email , display_name = val ue . split () self . email = email self . email_real_name = display_name [ 1 :- 1 ] elif key == \"KEY_CONSIDERED\" : self . fingerprint = val ue . strip (). split ()[ 0 ] def pub ( self , args : list [ str ]) -> None : \"\"\" Internal method to handle the 'pub' status message. `pub` message contains the fingerprint of the public key, its type and its creation date. \"\"\" def uid ( self , args : list [ str ]) -> None : local_tz = datetime . now (). astimezone (). tzinfo self . created_at = datetime . fromtimestamp ( int ( args [ 5 ]), tz = local_tz ) raw_email_content = args [ 9 ] email , real_name = parseaddr ( raw_email_content ) self . email = email self . email_real_name = real_name def sub ( self , args : list [ str ]) -> None : self . key_length = int ( args [ 2 ]) def fpr ( self , args : list [ str ]) -> None : # Only store the first fingerprint self . fingerprint = self . fingerprint or args [ 9 ] Ancestors (in MRO) gnupg.handlers.status_handler.StatusHandler Methods fpr def fpr ( self , args : 'list[str]' ) -> 'None' View Source def fpr ( self , args : list [ str ] ) -> None : # Only store the first fingerprint self . fingerprint = self . fingerprint or args [ 9 ] handle_status def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , val ue : str ) -> None : if key == \"IMPORTED\" : _ , email , display_name = val ue . split () self . email = email self . email_real_name = display_name [ 1 :- 1 ] elif key == \"KEY_CONSIDERED\" : self . fingerprint = val ue . strip (). split ()[ 0 ] pub def pub ( self , args : 'list[str]' ) -> 'None' Internal method to handle the 'pub' status message. pub message contains the fingerprint of the public key, its type and its creation date. View Source def pub ( self , args : list [ str ]) -> None : \"\"\" Internal method to handle the 'pub' status message. `pub` message contains the fingerprint of the public key, its type and its creation date. \"\"\" sub def sub ( self , args : 'list[str]' ) -> 'None' View Source def sub ( self , args : list [ str ] ) -> None : self . key_length = int ( args [ 2 ] ) uid def uid ( self , args : 'list[str]' ) -> 'None' View Source def uid ( self , args : list [ str ] ) -> None : local_tz = datetime . now (). astimezone (). tzinfo self . created_at = datetime . fromtimestamp ( int ( args [ 5 ] ), tz = local_tz ) raw_email_content = args [ 9 ] email , real_name = parseaddr ( raw_email_content ) self . email = email self . email_real_name = real_name","title":"Auto Locate Key Handler"},{"location":"reference/gnupg/handlers/auto_locate_key_handler/#module-gnupghandlersauto_locate_key_handler","text":"View Source from __future__ import annotations from datetime import datetime from email.utils import parseaddr from typing import TYPE_CHECKING from .status_handler import StatusHandler if TYPE_CHECKING : from gnupg.gnupg import GPG class AutoLocateKeyHandler ( StatusHandler ): \"\"\" This class handles status messages during key auto-locating. fingerprint: str key_length: int created_at: date email: str email_real_name: str \"\"\" def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . fingerprint = None self . type = None self . created_at = None self . email = None self . email_real_name = None def handle_status ( self , key : str , value : str ) -> None : if key == \"IMPORTED\" : _ , email , display_name = value . split () self . email = email self . email_real_name = display_name [ 1 : - 1 ] elif key == \"KEY_CONSIDERED\" : self . fingerprint = value . strip () . split ()[ 0 ] def pub ( self , args : list [ str ]) -> None : \"\"\" Internal method to handle the 'pub' status message. `pub` message contains the fingerprint of the public key, its type and its creation date. \"\"\" def uid ( self , args : list [ str ]) -> None : local_tz = datetime . now () . astimezone () . tzinfo self . created_at = datetime . fromtimestamp ( int ( args [ 5 ]), tz = local_tz ) raw_email_content = args [ 9 ] email , real_name = parseaddr ( raw_email_content ) self . email = email self . email_real_name = real_name def sub ( self , args : list [ str ]) -> None : self . key_length = int ( args [ 2 ]) def fpr ( self , args : list [ str ]) -> None : # Only store the first fingerprint self . fingerprint = self . fingerprint or args [ 9 ]","title":"Module gnupg.handlers.auto_locate_key_handler"},{"location":"reference/gnupg/handlers/auto_locate_key_handler/#variables","text":"TYPE_CHECKING","title":"Variables"},{"location":"reference/gnupg/handlers/auto_locate_key_handler/#classes","text":"","title":"Classes"},{"location":"reference/gnupg/handlers/auto_locate_key_handler/#autolocatekeyhandler","text":"class AutoLocateKeyHandler ( gpg : 'GPG' ) This class handles status messages during key auto-locating. fingerprint: str key_length: int created_at: date email: str email_real_name: str View Source class AutoLocateKeyHandler ( StatusHandler ) : \"\"\" This class handles status messages during key auto-locating. fingerprint: str key_length: int created_at: date email: str email_real_name: str \"\"\" def __ init__ ( self , gpg : GPG ) -> None : StatusHandler . __ init__ ( self , gpg ) self . fingerprint = None self . type = None self . created_at = None self . email = None self . email_real_name = None def handle_status ( self , key : str , val ue : str ) -> None : if key == \"IMPORTED\" : _ , email , display_name = val ue . split () self . email = email self . email_real_name = display_name [ 1 :- 1 ] elif key == \"KEY_CONSIDERED\" : self . fingerprint = val ue . strip (). split ()[ 0 ] def pub ( self , args : list [ str ]) -> None : \"\"\" Internal method to handle the 'pub' status message. `pub` message contains the fingerprint of the public key, its type and its creation date. \"\"\" def uid ( self , args : list [ str ]) -> None : local_tz = datetime . now (). astimezone (). tzinfo self . created_at = datetime . fromtimestamp ( int ( args [ 5 ]), tz = local_tz ) raw_email_content = args [ 9 ] email , real_name = parseaddr ( raw_email_content ) self . email = email self . email_real_name = real_name def sub ( self , args : list [ str ]) -> None : self . key_length = int ( args [ 2 ]) def fpr ( self , args : list [ str ]) -> None : # Only store the first fingerprint self . fingerprint = self . fingerprint or args [ 9 ]","title":"AutoLocateKeyHandler"},{"location":"reference/gnupg/handlers/auto_locate_key_handler/#ancestors-in-mro","text":"gnupg.handlers.status_handler.StatusHandler","title":"Ancestors (in MRO)"},{"location":"reference/gnupg/handlers/auto_locate_key_handler/#methods","text":"","title":"Methods"},{"location":"reference/gnupg/handlers/auto_locate_key_handler/#fpr","text":"def fpr ( self , args : 'list[str]' ) -> 'None' View Source def fpr ( self , args : list [ str ] ) -> None : # Only store the first fingerprint self . fingerprint = self . fingerprint or args [ 9 ]","title":"fpr"},{"location":"reference/gnupg/handlers/auto_locate_key_handler/#handle_status","text":"def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , val ue : str ) -> None : if key == \"IMPORTED\" : _ , email , display_name = val ue . split () self . email = email self . email_real_name = display_name [ 1 :- 1 ] elif key == \"KEY_CONSIDERED\" : self . fingerprint = val ue . strip (). split ()[ 0 ]","title":"handle_status"},{"location":"reference/gnupg/handlers/auto_locate_key_handler/#pub","text":"def pub ( self , args : 'list[str]' ) -> 'None' Internal method to handle the 'pub' status message. pub message contains the fingerprint of the public key, its type and its creation date. View Source def pub ( self , args : list [ str ]) -> None : \"\"\" Internal method to handle the 'pub' status message. `pub` message contains the fingerprint of the public key, its type and its creation date. \"\"\"","title":"pub"},{"location":"reference/gnupg/handlers/auto_locate_key_handler/#sub","text":"def sub ( self , args : 'list[str]' ) -> 'None' View Source def sub ( self , args : list [ str ] ) -> None : self . key_length = int ( args [ 2 ] )","title":"sub"},{"location":"reference/gnupg/handlers/auto_locate_key_handler/#uid","text":"def uid ( self , args : 'list[str]' ) -> 'None' View Source def uid ( self , args : list [ str ] ) -> None : local_tz = datetime . now (). astimezone (). tzinfo self . created_at = datetime . fromtimestamp ( int ( args [ 5 ] ), tz = local_tz ) raw_email_content = args [ 9 ] email , real_name = parseaddr ( raw_email_content ) self . email = email self . email_real_name = real_name","title":"uid"},{"location":"reference/gnupg/handlers/crypt_handler/","text":"Module gnupg.handlers.crypt_handler View Source from __future__ import annotations from typing import TYPE_CHECKING from gnupg.helper import _get_logger from .helper import _determine_invalid_recipient_or_signer from .text_handler import TextHandler from .verify_handler import VerifyHandler if TYPE_CHECKING : from gnupg.gnupg import GPG logger = _get_logger ( __name__ ) class CryptHandler ( VerifyHandler , TextHandler ): \"\"\" This class handles status messages during encryption and decryption. \"\"\" def __init__ ( self , gpg : GPG ) -> None : VerifyHandler . __init__ ( self , gpg ) self . data = \"\" self . ok = False self . status = \"\" self . status_detail = \"\" self . key_id = None def __nonzero__ ( self ) -> bool : return bool ( self . ok ) __bool__ = __nonzero__ def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ): logger . warning ( \"potential problem: %s : %s \" , key , value ) elif key == \"NODATA\" : if self . status not in ( \"decryption failed\" ,): self . status = \"no data was provided\" elif key in ( \"NEED_PASSPHRASE\" , \"BAD_PASSPHRASE\" , \"GOOD_PASSPHRASE\" , \"MISSING_PASSPHRASE\" , \"KEY_NOT_CREATED\" , \"NEED_PASSPHRASE_PIN\" , ): # pragma: no cover self . status = key . replace ( \"_\" , \" \" ) . lower () elif key == \"DECRYPTION_FAILED\" : # pragma: no cover if self . status != \"no secret key\" : # don't overwrite more useful message self . status = \"decryption failed\" elif key == \"NEED_PASSPHRASE_SYM\" : self . status = \"need symmetric passphrase\" elif key == \"BEGIN_DECRYPTION\" : if self . status != \"no secret key\" : # don't overwrite more useful message self . status = \"decryption incomplete\" elif key == \"BEGIN_ENCRYPTION\" : self . status = \"encryption incomplete\" elif key == \"DECRYPTION_OKAY\" : self . status = \"decryption ok\" self . ok = True elif key == \"END_ENCRYPTION\" : self . status = \"encryption ok\" self . ok = True elif key == \"INV_RECP\" : # pragma: no cover if not self . status : self . status = \"invalid recipient\" else : self . status = f \"invalid recipient: { self . status } \" self . status_detail = _determine_invalid_recipient_or_signer ( value ) elif key == \"KEYEXPIRED\" : # pragma: no cover self . status = \"key expired\" elif key == \"SIG_CREATED\" : # pragma: no cover self . status = \"sig created\" elif key == \"SIGEXPIRED\" : # pragma: no cover self . status = \"sig expired\" elif key == \"ENC_TO\" : # pragma: no cover # ENC_TO <long_keyid> <keytype> <keylength> self . key_id = value . split ( \" \" , 1 )[ 0 ] elif key in ( \"USERID_HINT\" , \"GOODMDC\" , \"END_DECRYPTION\" , \"CARDCTRL\" , \"BADMDC\" , \"SC_OP_FAILURE\" , \"SC_OP_SUCCESS\" , \"PINENTRY_LAUNCHED\" , ): pass else : VerifyHandler . handle_status ( self , key , value ) Variables TYPE_CHECKING logger Classes CryptHandler class CryptHandler ( gpg : 'GPG' ) This class handles status messages during encryption and decryption. View Source class CryptHandler ( VerifyHandler , TextHandler ): \"\"\" This class handles status messages during encryption and decryption. \"\"\" def __init__ ( self , gpg : GPG ) -> None : VerifyHandler . __init__ ( self , gpg ) self . data = \"\" self . ok = False self . status = \"\" self . status_detail = \"\" self . key_id = None def __nonzero__ ( self ) -> bool : return bool ( self . ok ) __bool__ = __nonzero__ def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ): logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key == \"NODATA\" : if self . status not in ( \"decryption failed\" ,): self . status = \"no data was provided\" elif key in ( \"NEED_PASSPHRASE\" , \"BAD_PASSPHRASE\" , \"GOOD_PASSPHRASE\" , \"MISSING_PASSPHRASE\" , \"KEY_NOT_CREATED\" , \"NEED_PASSPHRASE_PIN\" , ): # pragma : no cover self . status = key . replace ( \"_\" , \" \" ). lower () elif key == \"DECRYPTION_FAILED\" : # pragma : no cover if self . status != \"no secret key\" : # don ' t overwrite more useful message self . status = \"decryption failed\" elif key == \"NEED_PASSPHRASE_SYM\" : self . status = \"need symmetric passphrase\" elif key == \"BEGIN_DECRYPTION\" : if self . status != \"no secret key\" : # don ' t overwrite more useful message self . status = \"decryption incomplete\" elif key == \"BEGIN_ENCRYPTION\" : self . status = \"encryption incomplete\" elif key == \"DECRYPTION_OKAY\" : self . status = \"decryption ok\" self . ok = True elif key == \"END_ENCRYPTION\" : self . status = \"encryption ok\" self . ok = True elif key == \"INV_RECP\" : # pragma : no cover if not self . status : self . status = \"invalid recipient\" else : self . status = f \"invalid recipient: {self.status}\" self . status_detail = _determine_invalid_recipient_or_signer ( value ) elif key == \"KEYEXPIRED\" : # pragma : no cover self . status = \"key expired\" elif key == \"SIG_CREATED\" : # pragma : no cover self . status = \"sig created\" elif key == \"SIGEXPIRED\" : # pragma : no cover self . status = \"sig expired\" elif key == \"ENC_TO\" : # pragma : no cover # ENC_TO < long_keyid > < keytype > < keylength > self . key_id = value . split ( \" \" , 1 )[ 0 ] elif key in ( \"USERID_HINT\" , \"GOODMDC\" , \"END_DECRYPTION\" , \"CARDCTRL\" , \"BADMDC\" , \"SC_OP_FAILURE\" , \"SC_OP_SUCCESS\" , \"PINENTRY_LAUNCHED\" , ): pass else : VerifyHandler . handle_status ( self , key , value ) Ancestors (in MRO) gnupg.handlers.verify_handler.VerifyHandler gnupg.handlers.status_handler.StatusHandler gnupg.handlers.text_handler.TextHandler Class variables GPG_ERROR_CODES GPG_SYSTEM_ERROR_CODES TRUST_EXPIRED TRUST_FULLY TRUST_LEVELS TRUST_MARGINAL TRUST_NEVER TRUST_ULTIMATE TRUST_UNDEFINED returncode Methods handle_status def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ): logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key == \"NODATA\" : if self . status not in ( \"decryption failed\" ,): self . status = \"no data was provided\" elif key in ( \"NEED_PASSPHRASE\" , \"BAD_PASSPHRASE\" , \"GOOD_PASSPHRASE\" , \"MISSING_PASSPHRASE\" , \"KEY_NOT_CREATED\" , \"NEED_PASSPHRASE_PIN\" , ): # pragma : no cover self . status = key . replace ( \"_\" , \" \" ). lower () elif key == \"DECRYPTION_FAILED\" : # pragma : no cover if self . status != \"no secret key\" : # don ' t overwrite more useful message self . status = \"decryption failed\" elif key == \"NEED_PASSPHRASE_SYM\" : self . status = \"need symmetric passphrase\" elif key == \"BEGIN_DECRYPTION\" : if self . status != \"no secret key\" : # don ' t overwrite more useful message self . status = \"decryption incomplete\" elif key == \"BEGIN_ENCRYPTION\" : self . status = \"encryption incomplete\" elif key == \"DECRYPTION_OKAY\" : self . status = \"decryption ok\" self . ok = True elif key == \"END_ENCRYPTION\" : self . status = \"encryption ok\" self . ok = True elif key == \"INV_RECP\" : # pragma : no cover if not self . status : self . status = \"invalid recipient\" else : self . status = f \"invalid recipient: {self.status}\" self . status_detail = _determine_invalid_recipient_or_signer ( value ) elif key == \"KEYEXPIRED\" : # pragma : no cover self . status = \"key expired\" elif key == \"SIG_CREATED\" : # pragma : no cover self . status = \"sig created\" elif key == \"SIGEXPIRED\" : # pragma : no cover self . status = \"sig expired\" elif key == \"ENC_TO\" : # pragma : no cover # ENC_TO < long_keyid > < keytype > < keylength > self . key_id = value . split ( \" \" , 1 )[ 0 ] elif key in ( \"USERID_HINT\" , \"GOODMDC\" , \"END_DECRYPTION\" , \"CARDCTRL\" , \"BADMDC\" , \"SC_OP_FAILURE\" , \"SC_OP_SUCCESS\" , \"PINENTRY_LAUNCHED\" , ): pass else : VerifyHandler . handle_status ( self , key , value )","title":"Crypt Handler"},{"location":"reference/gnupg/handlers/crypt_handler/#module-gnupghandlerscrypt_handler","text":"View Source from __future__ import annotations from typing import TYPE_CHECKING from gnupg.helper import _get_logger from .helper import _determine_invalid_recipient_or_signer from .text_handler import TextHandler from .verify_handler import VerifyHandler if TYPE_CHECKING : from gnupg.gnupg import GPG logger = _get_logger ( __name__ ) class CryptHandler ( VerifyHandler , TextHandler ): \"\"\" This class handles status messages during encryption and decryption. \"\"\" def __init__ ( self , gpg : GPG ) -> None : VerifyHandler . __init__ ( self , gpg ) self . data = \"\" self . ok = False self . status = \"\" self . status_detail = \"\" self . key_id = None def __nonzero__ ( self ) -> bool : return bool ( self . ok ) __bool__ = __nonzero__ def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ): logger . warning ( \"potential problem: %s : %s \" , key , value ) elif key == \"NODATA\" : if self . status not in ( \"decryption failed\" ,): self . status = \"no data was provided\" elif key in ( \"NEED_PASSPHRASE\" , \"BAD_PASSPHRASE\" , \"GOOD_PASSPHRASE\" , \"MISSING_PASSPHRASE\" , \"KEY_NOT_CREATED\" , \"NEED_PASSPHRASE_PIN\" , ): # pragma: no cover self . status = key . replace ( \"_\" , \" \" ) . lower () elif key == \"DECRYPTION_FAILED\" : # pragma: no cover if self . status != \"no secret key\" : # don't overwrite more useful message self . status = \"decryption failed\" elif key == \"NEED_PASSPHRASE_SYM\" : self . status = \"need symmetric passphrase\" elif key == \"BEGIN_DECRYPTION\" : if self . status != \"no secret key\" : # don't overwrite more useful message self . status = \"decryption incomplete\" elif key == \"BEGIN_ENCRYPTION\" : self . status = \"encryption incomplete\" elif key == \"DECRYPTION_OKAY\" : self . status = \"decryption ok\" self . ok = True elif key == \"END_ENCRYPTION\" : self . status = \"encryption ok\" self . ok = True elif key == \"INV_RECP\" : # pragma: no cover if not self . status : self . status = \"invalid recipient\" else : self . status = f \"invalid recipient: { self . status } \" self . status_detail = _determine_invalid_recipient_or_signer ( value ) elif key == \"KEYEXPIRED\" : # pragma: no cover self . status = \"key expired\" elif key == \"SIG_CREATED\" : # pragma: no cover self . status = \"sig created\" elif key == \"SIGEXPIRED\" : # pragma: no cover self . status = \"sig expired\" elif key == \"ENC_TO\" : # pragma: no cover # ENC_TO <long_keyid> <keytype> <keylength> self . key_id = value . split ( \" \" , 1 )[ 0 ] elif key in ( \"USERID_HINT\" , \"GOODMDC\" , \"END_DECRYPTION\" , \"CARDCTRL\" , \"BADMDC\" , \"SC_OP_FAILURE\" , \"SC_OP_SUCCESS\" , \"PINENTRY_LAUNCHED\" , ): pass else : VerifyHandler . handle_status ( self , key , value )","title":"Module gnupg.handlers.crypt_handler"},{"location":"reference/gnupg/handlers/crypt_handler/#variables","text":"TYPE_CHECKING logger","title":"Variables"},{"location":"reference/gnupg/handlers/crypt_handler/#classes","text":"","title":"Classes"},{"location":"reference/gnupg/handlers/crypt_handler/#crypthandler","text":"class CryptHandler ( gpg : 'GPG' ) This class handles status messages during encryption and decryption. View Source class CryptHandler ( VerifyHandler , TextHandler ): \"\"\" This class handles status messages during encryption and decryption. \"\"\" def __init__ ( self , gpg : GPG ) -> None : VerifyHandler . __init__ ( self , gpg ) self . data = \"\" self . ok = False self . status = \"\" self . status_detail = \"\" self . key_id = None def __nonzero__ ( self ) -> bool : return bool ( self . ok ) __bool__ = __nonzero__ def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ): logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key == \"NODATA\" : if self . status not in ( \"decryption failed\" ,): self . status = \"no data was provided\" elif key in ( \"NEED_PASSPHRASE\" , \"BAD_PASSPHRASE\" , \"GOOD_PASSPHRASE\" , \"MISSING_PASSPHRASE\" , \"KEY_NOT_CREATED\" , \"NEED_PASSPHRASE_PIN\" , ): # pragma : no cover self . status = key . replace ( \"_\" , \" \" ). lower () elif key == \"DECRYPTION_FAILED\" : # pragma : no cover if self . status != \"no secret key\" : # don ' t overwrite more useful message self . status = \"decryption failed\" elif key == \"NEED_PASSPHRASE_SYM\" : self . status = \"need symmetric passphrase\" elif key == \"BEGIN_DECRYPTION\" : if self . status != \"no secret key\" : # don ' t overwrite more useful message self . status = \"decryption incomplete\" elif key == \"BEGIN_ENCRYPTION\" : self . status = \"encryption incomplete\" elif key == \"DECRYPTION_OKAY\" : self . status = \"decryption ok\" self . ok = True elif key == \"END_ENCRYPTION\" : self . status = \"encryption ok\" self . ok = True elif key == \"INV_RECP\" : # pragma : no cover if not self . status : self . status = \"invalid recipient\" else : self . status = f \"invalid recipient: {self.status}\" self . status_detail = _determine_invalid_recipient_or_signer ( value ) elif key == \"KEYEXPIRED\" : # pragma : no cover self . status = \"key expired\" elif key == \"SIG_CREATED\" : # pragma : no cover self . status = \"sig created\" elif key == \"SIGEXPIRED\" : # pragma : no cover self . status = \"sig expired\" elif key == \"ENC_TO\" : # pragma : no cover # ENC_TO < long_keyid > < keytype > < keylength > self . key_id = value . split ( \" \" , 1 )[ 0 ] elif key in ( \"USERID_HINT\" , \"GOODMDC\" , \"END_DECRYPTION\" , \"CARDCTRL\" , \"BADMDC\" , \"SC_OP_FAILURE\" , \"SC_OP_SUCCESS\" , \"PINENTRY_LAUNCHED\" , ): pass else : VerifyHandler . handle_status ( self , key , value )","title":"CryptHandler"},{"location":"reference/gnupg/handlers/crypt_handler/#ancestors-in-mro","text":"gnupg.handlers.verify_handler.VerifyHandler gnupg.handlers.status_handler.StatusHandler gnupg.handlers.text_handler.TextHandler","title":"Ancestors (in MRO)"},{"location":"reference/gnupg/handlers/crypt_handler/#class-variables","text":"GPG_ERROR_CODES GPG_SYSTEM_ERROR_CODES TRUST_EXPIRED TRUST_FULLY TRUST_LEVELS TRUST_MARGINAL TRUST_NEVER TRUST_ULTIMATE TRUST_UNDEFINED returncode","title":"Class variables"},{"location":"reference/gnupg/handlers/crypt_handler/#methods","text":"","title":"Methods"},{"location":"reference/gnupg/handlers/crypt_handler/#handle_status","text":"def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ): logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key == \"NODATA\" : if self . status not in ( \"decryption failed\" ,): self . status = \"no data was provided\" elif key in ( \"NEED_PASSPHRASE\" , \"BAD_PASSPHRASE\" , \"GOOD_PASSPHRASE\" , \"MISSING_PASSPHRASE\" , \"KEY_NOT_CREATED\" , \"NEED_PASSPHRASE_PIN\" , ): # pragma : no cover self . status = key . replace ( \"_\" , \" \" ). lower () elif key == \"DECRYPTION_FAILED\" : # pragma : no cover if self . status != \"no secret key\" : # don ' t overwrite more useful message self . status = \"decryption failed\" elif key == \"NEED_PASSPHRASE_SYM\" : self . status = \"need symmetric passphrase\" elif key == \"BEGIN_DECRYPTION\" : if self . status != \"no secret key\" : # don ' t overwrite more useful message self . status = \"decryption incomplete\" elif key == \"BEGIN_ENCRYPTION\" : self . status = \"encryption incomplete\" elif key == \"DECRYPTION_OKAY\" : self . status = \"decryption ok\" self . ok = True elif key == \"END_ENCRYPTION\" : self . status = \"encryption ok\" self . ok = True elif key == \"INV_RECP\" : # pragma : no cover if not self . status : self . status = \"invalid recipient\" else : self . status = f \"invalid recipient: {self.status}\" self . status_detail = _determine_invalid_recipient_or_signer ( value ) elif key == \"KEYEXPIRED\" : # pragma : no cover self . status = \"key expired\" elif key == \"SIG_CREATED\" : # pragma : no cover self . status = \"sig created\" elif key == \"SIGEXPIRED\" : # pragma : no cover self . status = \"sig expired\" elif key == \"ENC_TO\" : # pragma : no cover # ENC_TO < long_keyid > < keytype > < keylength > self . key_id = value . split ( \" \" , 1 )[ 0 ] elif key in ( \"USERID_HINT\" , \"GOODMDC\" , \"END_DECRYPTION\" , \"CARDCTRL\" , \"BADMDC\" , \"SC_OP_FAILURE\" , \"SC_OP_SUCCESS\" , \"PINENTRY_LAUNCHED\" , ): pass else : VerifyHandler . handle_status ( self , key , value )","title":"handle_status"},{"location":"reference/gnupg/handlers/delete_result_handler/","text":"Module gnupg.handlers.delete_result_handler View Source from __future__ import annotations from types import MappingProxyType from typing import TYPE_CHECKING from gnupg.helper import _get_logger from .status_handler import StatusHandler if TYPE_CHECKING : from gnupg.gnupg import GPG logger = _get_logger ( __name__ ) class DeleteResultHandler ( StatusHandler ): \"\"\" This class handles status messages during key deletion. \"\"\" returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . status = \"ok\" def __str__ ( self ) -> str : return self . status problem_reason = MappingProxyType ( { \"1\" : \"No such key\" , \"2\" : \"Must delete secret key first\" , \"3\" : \"Ambiguous specification\" , }, ) def handle_status ( self , key : str , value : str ) -> None : if key == \"DELETE_PROBLEM\" : # pragma: no cover self . status = self . problem_reason . get ( value , f \"Unknown error: { value !r} \" ) else : # pragma: no cover logger . debug ( \"message ignored: %s , %s \" , key , value ) def __nonzero__ ( self ) -> bool : # pragma: no cover return self . status == \"ok\" __bool__ = __nonzero__ Variables TYPE_CHECKING logger Classes DeleteResultHandler class DeleteResultHandler ( gpg : 'GPG' ) This class handles status messages during key deletion. View Source class DeleteResultHandler ( StatusHandler ): \"\"\" This class handles status messages during key deletion. \"\"\" returncode = None def __init__ ( self , gpg: GPG ) -> None: StatusHandler . __init__ ( self , gpg ) self . status = \"ok\" def __str__ ( self ) -> str: return self . status problem_reason = MappingProxyType ( { \"1\" : \"No such key\" , \"2\" : \"Must delete secret key first\" , \"3\" : \"Ambiguous specification\" , }, ) def handle_status ( self , key: str , value: str ) -> None: if key == \"DELETE_PROBLEM\" : # pragma: no cover self . status = self . problem_reason . get ( value , f \"Unknown error: {value!r}\" ) else: # pragma: no cover logger . debug ( \"message ignored: %s, %s\" , key , value ) def __nonzero__ ( self ) -> bool: # pragma: no cover return self . status == \"ok\" __bool__ = __nonzero__ Ancestors (in MRO) gnupg.handlers.status_handler.StatusHandler Descendants gnupg.handlers.trust_result_handler.TrustResultHandler Class variables problem_reason returncode Methods handle_status def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : if key == \"DELETE_PROBLEM\" : # pragma : no cover self . status = self . problem_reason . get ( value , f \"Unknown error: {value!r}\" ) else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value )","title":"Delete Result Handler"},{"location":"reference/gnupg/handlers/delete_result_handler/#module-gnupghandlersdelete_result_handler","text":"View Source from __future__ import annotations from types import MappingProxyType from typing import TYPE_CHECKING from gnupg.helper import _get_logger from .status_handler import StatusHandler if TYPE_CHECKING : from gnupg.gnupg import GPG logger = _get_logger ( __name__ ) class DeleteResultHandler ( StatusHandler ): \"\"\" This class handles status messages during key deletion. \"\"\" returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . status = \"ok\" def __str__ ( self ) -> str : return self . status problem_reason = MappingProxyType ( { \"1\" : \"No such key\" , \"2\" : \"Must delete secret key first\" , \"3\" : \"Ambiguous specification\" , }, ) def handle_status ( self , key : str , value : str ) -> None : if key == \"DELETE_PROBLEM\" : # pragma: no cover self . status = self . problem_reason . get ( value , f \"Unknown error: { value !r} \" ) else : # pragma: no cover logger . debug ( \"message ignored: %s , %s \" , key , value ) def __nonzero__ ( self ) -> bool : # pragma: no cover return self . status == \"ok\" __bool__ = __nonzero__","title":"Module gnupg.handlers.delete_result_handler"},{"location":"reference/gnupg/handlers/delete_result_handler/#variables","text":"TYPE_CHECKING logger","title":"Variables"},{"location":"reference/gnupg/handlers/delete_result_handler/#classes","text":"","title":"Classes"},{"location":"reference/gnupg/handlers/delete_result_handler/#deleteresulthandler","text":"class DeleteResultHandler ( gpg : 'GPG' ) This class handles status messages during key deletion. View Source class DeleteResultHandler ( StatusHandler ): \"\"\" This class handles status messages during key deletion. \"\"\" returncode = None def __init__ ( self , gpg: GPG ) -> None: StatusHandler . __init__ ( self , gpg ) self . status = \"ok\" def __str__ ( self ) -> str: return self . status problem_reason = MappingProxyType ( { \"1\" : \"No such key\" , \"2\" : \"Must delete secret key first\" , \"3\" : \"Ambiguous specification\" , }, ) def handle_status ( self , key: str , value: str ) -> None: if key == \"DELETE_PROBLEM\" : # pragma: no cover self . status = self . problem_reason . get ( value , f \"Unknown error: {value!r}\" ) else: # pragma: no cover logger . debug ( \"message ignored: %s, %s\" , key , value ) def __nonzero__ ( self ) -> bool: # pragma: no cover return self . status == \"ok\" __bool__ = __nonzero__","title":"DeleteResultHandler"},{"location":"reference/gnupg/handlers/delete_result_handler/#ancestors-in-mro","text":"gnupg.handlers.status_handler.StatusHandler","title":"Ancestors (in MRO)"},{"location":"reference/gnupg/handlers/delete_result_handler/#descendants","text":"gnupg.handlers.trust_result_handler.TrustResultHandler","title":"Descendants"},{"location":"reference/gnupg/handlers/delete_result_handler/#class-variables","text":"problem_reason returncode","title":"Class variables"},{"location":"reference/gnupg/handlers/delete_result_handler/#methods","text":"","title":"Methods"},{"location":"reference/gnupg/handlers/delete_result_handler/#handle_status","text":"def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : if key == \"DELETE_PROBLEM\" : # pragma : no cover self . status = self . problem_reason . get ( value , f \"Unknown error: {value!r}\" ) else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value )","title":"handle_status"},{"location":"reference/gnupg/handlers/export_result_handler/","text":"Module gnupg.handlers.export_result_handler View Source from __future__ import annotations from .gen_key_handler import GenKeyHandler class ExportResultHandler ( GenKeyHandler ): \"\"\" This class handles status messages during key export. \"\"\" # For now, just use an existing class to base it on - if needed, we # can override handle_status for more specific message handling. def handle_status ( self , key : str , value : str ) -> None : if key in ( \"EXPORTED\" , \"EXPORT_RES\" ): pass else : super () . handle_status ( key , value ) Classes ExportResultHandler class ExportResultHandler ( gpg : 'GPG' ) This class handles status messages during key export. View Source class ExportResultHandler ( GenKeyHandler ): \"\"\" This class handles status messages during key export. \"\"\" # For now, just use an existing class to base it on - if needed, we # can override handle_status for more specific message handling. def handle_status ( self , key : str , value : str ) -> None : if key in ( \"EXPORTED\" , \"EXPORT_RES\" ): pass else : super () . handle_status ( key , value ) Ancestors (in MRO) gnupg.handlers.gen_key_handler.GenKeyHandler gnupg.handlers.status_handler.StatusHandler Class variables returncode Methods handle_status def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : if key in ( \"EXPORTED\" , \"EXPORT_RES\" ) : pass else : super (). handle_status ( key , value )","title":"Export Result Handler"},{"location":"reference/gnupg/handlers/export_result_handler/#module-gnupghandlersexport_result_handler","text":"View Source from __future__ import annotations from .gen_key_handler import GenKeyHandler class ExportResultHandler ( GenKeyHandler ): \"\"\" This class handles status messages during key export. \"\"\" # For now, just use an existing class to base it on - if needed, we # can override handle_status for more specific message handling. def handle_status ( self , key : str , value : str ) -> None : if key in ( \"EXPORTED\" , \"EXPORT_RES\" ): pass else : super () . handle_status ( key , value )","title":"Module gnupg.handlers.export_result_handler"},{"location":"reference/gnupg/handlers/export_result_handler/#classes","text":"","title":"Classes"},{"location":"reference/gnupg/handlers/export_result_handler/#exportresulthandler","text":"class ExportResultHandler ( gpg : 'GPG' ) This class handles status messages during key export. View Source class ExportResultHandler ( GenKeyHandler ): \"\"\" This class handles status messages during key export. \"\"\" # For now, just use an existing class to base it on - if needed, we # can override handle_status for more specific message handling. def handle_status ( self , key : str , value : str ) -> None : if key in ( \"EXPORTED\" , \"EXPORT_RES\" ): pass else : super () . handle_status ( key , value )","title":"ExportResultHandler"},{"location":"reference/gnupg/handlers/export_result_handler/#ancestors-in-mro","text":"gnupg.handlers.gen_key_handler.GenKeyHandler gnupg.handlers.status_handler.StatusHandler","title":"Ancestors (in MRO)"},{"location":"reference/gnupg/handlers/export_result_handler/#class-variables","text":"returncode","title":"Class variables"},{"location":"reference/gnupg/handlers/export_result_handler/#methods","text":"","title":"Methods"},{"location":"reference/gnupg/handlers/export_result_handler/#handle_status","text":"def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : if key in ( \"EXPORTED\" , \"EXPORT_RES\" ) : pass else : super (). handle_status ( key , value )","title":"handle_status"},{"location":"reference/gnupg/handlers/gen_key_handler/","text":"Module gnupg.handlers.gen_key_handler View Source from __future__ import annotations from typing import TYPE_CHECKING from gnupg.helper import _get_logger from .status_handler import StatusHandler if TYPE_CHECKING : from gnupg.gnupg import GPG logger = _get_logger ( __name__ ) class GenKeyHandler ( StatusHandler ): \"\"\" This class handles status messages during key generation. \"\"\" returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . type = None self . fingerprint = \"\" self . status = None def __nonzero__ ( self ) -> bool : # pragma: no cover return bool ( self . fingerprint ) __bool__ = __nonzero__ def __str__ ( self ) -> str : # pragma: no cover return self . fingerprint def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ): # pragma: no cover logger . warning ( \"potential problem: %s : %s \" , key , value ) elif key == \"KEY_CREATED\" : parts = value . split () ( self . type , self . fingerprint ) = parts [: 2 ] self . status = \"ok\" elif key == \"KEY_NOT_CREATED\" : self . status = key . replace ( \"_\" , \" \" ) . lower () elif key in ( \"PROGRESS\" , \"GOOD_PASSPHRASE\" ): # pragma: no cover pass else : # pragma: no cover logger . debug ( \"message ignored: %s , %s \" , key , value ) Variables TYPE_CHECKING logger Classes GenKeyHandler class GenKeyHandler ( gpg : 'GPG' ) This class handles status messages during key generation. View Source class GenKeyHandler ( StatusHandler ): \"\"\" This class handles status messages during key generation. \"\"\" returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . type = None self . fingerprint = \"\" self . status = None def __nonzero__ ( self ) -> bool : # pragma : no cover return bool ( self . fingerprint ) __bool__ = __nonzero__ def __str__ ( self ) -> str : # pragma : no cover return self . fingerprint def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ): # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key == \"KEY_CREATED\" : parts = value . split () ( self . type , self . fingerprint ) = parts [: 2 ] self . status = \"ok\" elif key == \"KEY_NOT_CREATED\" : self . status = key . replace ( \"_\" , \" \" ). lower () elif key in ( \"PROGRESS\" , \"GOOD_PASSPHRASE\" ): # pragma : no cover pass else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value ) Ancestors (in MRO) gnupg.handlers.status_handler.StatusHandler Descendants gnupg.handlers.export_result_handler.ExportResultHandler Class variables returncode Methods handle_status def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ): # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key == \"KEY_CREATED\" : parts = value . split () ( self . type , self . fingerprint ) = parts [: 2 ] self . status = \"ok\" elif key == \"KEY_NOT_CREATED\" : self . status = key . replace ( \"_\" , \" \" ). lower () elif key in ( \"PROGRESS\" , \"GOOD_PASSPHRASE\" ): # pragma : no cover pass else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value )","title":"Gen Key Handler"},{"location":"reference/gnupg/handlers/gen_key_handler/#module-gnupghandlersgen_key_handler","text":"View Source from __future__ import annotations from typing import TYPE_CHECKING from gnupg.helper import _get_logger from .status_handler import StatusHandler if TYPE_CHECKING : from gnupg.gnupg import GPG logger = _get_logger ( __name__ ) class GenKeyHandler ( StatusHandler ): \"\"\" This class handles status messages during key generation. \"\"\" returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . type = None self . fingerprint = \"\" self . status = None def __nonzero__ ( self ) -> bool : # pragma: no cover return bool ( self . fingerprint ) __bool__ = __nonzero__ def __str__ ( self ) -> str : # pragma: no cover return self . fingerprint def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ): # pragma: no cover logger . warning ( \"potential problem: %s : %s \" , key , value ) elif key == \"KEY_CREATED\" : parts = value . split () ( self . type , self . fingerprint ) = parts [: 2 ] self . status = \"ok\" elif key == \"KEY_NOT_CREATED\" : self . status = key . replace ( \"_\" , \" \" ) . lower () elif key in ( \"PROGRESS\" , \"GOOD_PASSPHRASE\" ): # pragma: no cover pass else : # pragma: no cover logger . debug ( \"message ignored: %s , %s \" , key , value )","title":"Module gnupg.handlers.gen_key_handler"},{"location":"reference/gnupg/handlers/gen_key_handler/#variables","text":"TYPE_CHECKING logger","title":"Variables"},{"location":"reference/gnupg/handlers/gen_key_handler/#classes","text":"","title":"Classes"},{"location":"reference/gnupg/handlers/gen_key_handler/#genkeyhandler","text":"class GenKeyHandler ( gpg : 'GPG' ) This class handles status messages during key generation. View Source class GenKeyHandler ( StatusHandler ): \"\"\" This class handles status messages during key generation. \"\"\" returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . type = None self . fingerprint = \"\" self . status = None def __nonzero__ ( self ) -> bool : # pragma : no cover return bool ( self . fingerprint ) __bool__ = __nonzero__ def __str__ ( self ) -> str : # pragma : no cover return self . fingerprint def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ): # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key == \"KEY_CREATED\" : parts = value . split () ( self . type , self . fingerprint ) = parts [: 2 ] self . status = \"ok\" elif key == \"KEY_NOT_CREATED\" : self . status = key . replace ( \"_\" , \" \" ). lower () elif key in ( \"PROGRESS\" , \"GOOD_PASSPHRASE\" ): # pragma : no cover pass else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value )","title":"GenKeyHandler"},{"location":"reference/gnupg/handlers/gen_key_handler/#ancestors-in-mro","text":"gnupg.handlers.status_handler.StatusHandler","title":"Ancestors (in MRO)"},{"location":"reference/gnupg/handlers/gen_key_handler/#descendants","text":"gnupg.handlers.export_result_handler.ExportResultHandler","title":"Descendants"},{"location":"reference/gnupg/handlers/gen_key_handler/#class-variables","text":"returncode","title":"Class variables"},{"location":"reference/gnupg/handlers/gen_key_handler/#methods","text":"","title":"Methods"},{"location":"reference/gnupg/handlers/gen_key_handler/#handle_status","text":"def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ): # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key == \"KEY_CREATED\" : parts = value . split () ( self . type , self . fingerprint ) = parts [: 2 ] self . status = \"ok\" elif key == \"KEY_NOT_CREATED\" : self . status = key . replace ( \"_\" , \" \" ). lower () elif key in ( \"PROGRESS\" , \"GOOD_PASSPHRASE\" ): # pragma : no cover pass else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value )","title":"handle_status"},{"location":"reference/gnupg/handlers/helper/","text":"Module gnupg.handlers.helper View Source from __future__ import annotations from types import MappingProxyType from typing import Any _INVALID_KEY_REASONS = MappingProxyType ( { 0 : \"no specific reason given\" , 1 : \"not found\" , 2 : \"ambiguous specification\" , 3 : \"wrong key usage\" , 4 : \"key revoked\" , 5 : \"key expired\" , 6 : \"no crl known\" , 7 : \"crl too old\" , 8 : \"policy mismatch\" , 9 : \"not a secret key\" , 10 : \"key not trusted\" , 11 : \"missing certificate\" , 12 : \"missing issuer certificate\" , 13 : \"key disabled\" , 14 : \"syntax error in specification\" , }, ) def _determine_invalid_recipient_or_signer ( s : str ) -> str : # pragma: no cover parts = s . split () if len ( parts ) >= 2 : # noqa: PLR2004 code , ident = parts [: 2 ] else : code = parts [ 0 ] ident = \"<no ident>\" unexpected = f \"unexpected return code { code !r} \" try : key = int ( code ) result = _INVALID_KEY_REASONS . get ( key , unexpected ) except ValueError : result = unexpected return f \" { result } : { ident } \" def _set_fields ( target : dict [ Any , Any ], fieldnames : list [ str ], args : list [ str ]) -> None : for i , var in enumerate ( fieldnames ): if i < len ( args ): target [ var ] = args [ i ] else : target [ var ] = \"unavailable\"","title":"Helper"},{"location":"reference/gnupg/handlers/helper/#module-gnupghandlershelper","text":"View Source from __future__ import annotations from types import MappingProxyType from typing import Any _INVALID_KEY_REASONS = MappingProxyType ( { 0 : \"no specific reason given\" , 1 : \"not found\" , 2 : \"ambiguous specification\" , 3 : \"wrong key usage\" , 4 : \"key revoked\" , 5 : \"key expired\" , 6 : \"no crl known\" , 7 : \"crl too old\" , 8 : \"policy mismatch\" , 9 : \"not a secret key\" , 10 : \"key not trusted\" , 11 : \"missing certificate\" , 12 : \"missing issuer certificate\" , 13 : \"key disabled\" , 14 : \"syntax error in specification\" , }, ) def _determine_invalid_recipient_or_signer ( s : str ) -> str : # pragma: no cover parts = s . split () if len ( parts ) >= 2 : # noqa: PLR2004 code , ident = parts [: 2 ] else : code = parts [ 0 ] ident = \"<no ident>\" unexpected = f \"unexpected return code { code !r} \" try : key = int ( code ) result = _INVALID_KEY_REASONS . get ( key , unexpected ) except ValueError : result = unexpected return f \" { result } : { ident } \" def _set_fields ( target : dict [ Any , Any ], fieldnames : list [ str ], args : list [ str ]) -> None : for i , var in enumerate ( fieldnames ): if i < len ( args ): target [ var ] = args [ i ] else : target [ var ] = \"unavailable\"","title":"Module gnupg.handlers.helper"},{"location":"reference/gnupg/handlers/import_result_handler/","text":"Module gnupg.handlers.import_result_handler View Source from __future__ import annotations from types import MappingProxyType from typing import TYPE_CHECKING from gnupg.helper import _get_logger from .status_handler import StatusHandler if TYPE_CHECKING : from gnupg.gnupg import GPG logger = _get_logger ( __name__ ) class ImportResultHandler ( StatusHandler ): \"\"\" This class handles status messages during key import. \"\"\" counts = \"\"\"count no_user_id imported imported_rsa unchanged n_uids n_subk n_sigs n_revoc sec_read sec_imported sec_dups not_imported\"\"\" . split () returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . results = [] self . fingerprints = [] for result in self . counts : setattr ( self , result , 0 ) def __nonzero__ ( self ) -> bool : return bool ( not self . not_imported and self . fingerprints ) __bool__ = __nonzero__ ok_reason = MappingProxyType ( { \"0\" : \"Not actually changed\" , \"1\" : \"Entirely new key\" , \"2\" : \"New user IDs\" , \"4\" : \"New signatures\" , \"8\" : \"New subkeys\" , \"16\" : \"Contains private key\" , }, ) problem_reason = MappingProxyType ( { \"0\" : \"No specific reason given\" , \"1\" : \"Invalid Certificate\" , \"2\" : \"Issuer Certificate missing\" , \"3\" : \"Certificate Chain too long\" , \"4\" : \"Error storing certificate\" , }, ) def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ): # pragma: no cover logger . warning ( \"potential problem: %s : %s \" , key , value ) elif key in ( \"IMPORTED\" , \"KEY_CONSIDERED\" ): # this duplicates info we already see in import_ok & import_problem pass elif key == \"NODATA\" : # pragma: no cover self . results . append ({ \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"No valid data found\" }) elif key == \"IMPORT_OK\" : reason , fingerprint = value . split () reasons = [] for code , text in list ( self . ok_reason . items ()): if int ( reason ) | int ( code ) == int ( reason ): reasons . append ( text ) reasontext = \" \\n \" . join ( reasons ) + \" \\n \" self . results . append ({ \"fingerprint\" : fingerprint , \"ok\" : reason , \"text\" : reasontext }) self . fingerprints . append ( fingerprint ) elif key == \"IMPORT_PROBLEM\" : # pragma: no cover try : reason , fingerprint = value . split () except ( AttributeError , Exception ): reason = value fingerprint = \"<unknown>\" self . results . append ({ \"fingerprint\" : fingerprint , \"problem\" : reason , \"text\" : self . problem_reason [ reason ]}) elif key == \"IMPORT_RES\" : import_res = value . split () for i , count in enumerate ( self . counts ): setattr ( self , count , int ( import_res [ i ])) elif key == \"KEYEXPIRED\" : # pragma: no cover self . results . append ({ \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"Key expired\" }) elif key == \"SIGEXPIRED\" : # pragma: no cover self . results . append ({ \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"Signature expired\" }) elif key == \"FAILURE\" : # pragma: no cover self . results . append ({ \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"Other failure\" }) else : # pragma: no cover logger . debug ( \"message ignored: %s , %s \" , key , value ) def summary ( self ) -> str : \"\"\" Return a summary indicating how many keys were imported and how many were not imported. \"\"\" result = [] result . append ( \" %d imported\" % self . imported ) if self . not_imported : # pragma: no cover result . append ( \" %d not imported\" % self . not_imported ) return \", \" . join ( result ) Variables TYPE_CHECKING logger Classes ImportResultHandler class ImportResultHandler ( gpg : 'GPG' ) This class handles status messages during key import. View Source class ImportResultHandler ( StatusHandler ) : \"\"\" This class handles status messages during key import. \"\"\" counts = \"\"\"count no_user_id imported imported_rsa unchanged n_uids n_subk n_sigs n_revoc sec_read sec_imported sec_dups not_imported\"\"\" . split () returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . results = [] self . fingerprints = [] for result in self . counts : setattr ( self , result , 0 ) def __nonzero__ ( self ) -> bool : return bool ( not self . not_imported and self . fingerprints ) __bool__ = __nonzero__ ok_reason = MappingProxyType ( { \"0\" : \"Not actually changed\" , \"1\" : \"Entirely new key\" , \"2\" : \"New user IDs\" , \"4\" : \"New signatures\" , \"8\" : \"New subkeys\" , \"16\" : \"Contains private key\" , } , ) problem_reason = MappingProxyType ( { \"0\" : \"No specific reason given\" , \"1\" : \"Invalid Certificate\" , \"2\" : \"Issuer Certificate missing\" , \"3\" : \"Certificate Chain too long\" , \"4\" : \"Error storing certificate\" , } , ) def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ) : # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key in ( \"IMPORTED\" , \"KEY_CONSIDERED\" ) : # this duplicates info we already see in import_ok & import_problem pass elif key == \"NODATA\" : # pragma : no cover self . results . append ( { \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"No valid data found\" } ) elif key == \"IMPORT_OK\" : reason , fingerprint = value . split () reasons = [] for code , text in list ( self . ok_reason . items ()) : if int ( reason ) | int ( code ) == int ( reason ) : reasons . append ( text ) reasontext = \"\\n\" . join ( reasons ) + \"\\n\" self . results . append ( { \"fingerprint\" : fingerprint , \"ok\" : reason , \"text\" : reasontext } ) self . fingerprints . append ( fingerprint ) elif key == \"IMPORT_PROBLEM\" : # pragma : no cover try : reason , fingerprint = value . split () except ( AttributeError , Exception ) : reason = value fingerprint = \"<unknown>\" self . results . append ( { \"fingerprint\" : fingerprint , \"problem\" : reason , \"text\" : self . problem_reason [ reason ] } ) elif key == \"IMPORT_RES\" : import_res = value . split () for i , count in enumerate ( self . counts ) : setattr ( self , count , int ( import_res [ i ] )) elif key == \"KEYEXPIRED\" : # pragma : no cover self . results . append ( { \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"Key expired\" } ) elif key == \"SIGEXPIRED\" : # pragma : no cover self . results . append ( { \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"Signature expired\" } ) elif key == \"FAILURE\" : # pragma : no cover self . results . append ( { \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"Other failure\" } ) else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value ) def summary ( self ) -> str : \"\"\" Return a summary indicating how many keys were imported and how many were not imported. \"\"\" result = [] result . append ( \"%d imported\" % self . imported ) if self . not_imported : # pragma : no cover result . append ( \"%d not imported\" % self . not_imported ) return \", \" . join ( result ) Ancestors (in MRO) gnupg.handlers.status_handler.StatusHandler Class variables counts ok_reason problem_reason returncode Methods handle_status def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ) : # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key in ( \"IMPORTED\" , \"KEY_CONSIDERED\" ) : # this duplicates info we already see in import_ok & import_problem pass elif key == \"NODATA\" : # pragma : no cover self . results . append ( { \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"No valid data found\" } ) elif key == \"IMPORT_OK\" : reason , fingerprint = value . split () reasons = [] for code , text in list ( self . ok_reason . items ()) : if int ( reason ) | int ( code ) == int ( reason ) : reasons . append ( text ) reasontext = \"\\n\" . join ( reasons ) + \"\\n\" self . results . append ( { \"fingerprint\" : fingerprint , \"ok\" : reason , \"text\" : reasontext } ) self . fingerprints . append ( fingerprint ) elif key == \"IMPORT_PROBLEM\" : # pragma : no cover try : reason , fingerprint = value . split () except ( AttributeError , Exception ) : reason = value fingerprint = \"<unknown>\" self . results . append ( { \"fingerprint\" : fingerprint , \"problem\" : reason , \"text\" : self . problem_reason [ reason ] } ) elif key == \"IMPORT_RES\" : import_res = value . split () for i , count in enumerate ( self . counts ) : setattr ( self , count , int ( import_res [ i ] )) elif key == \"KEYEXPIRED\" : # pragma : no cover self . results . append ( { \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"Key expired\" } ) elif key == \"SIGEXPIRED\" : # pragma : no cover self . results . append ( { \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"Signature expired\" } ) elif key == \"FAILURE\" : # pragma : no cover self . results . append ( { \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"Other failure\" } ) else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value ) summary def summary ( self ) -> 'str' Return a summary indicating how many keys were imported and how many were not imported. View Source def summary ( self ) -> str : \"\"\" Return a summary indicating how many keys were imported and how many were not imported. \"\"\" result = [] result . append ( \"%d imported\" % self . imported ) if self . not_imported : # pragma : no cover result . append ( \"%d not imported\" % self . not_imported ) return \", \" . join ( result )","title":"Import Result Handler"},{"location":"reference/gnupg/handlers/import_result_handler/#module-gnupghandlersimport_result_handler","text":"View Source from __future__ import annotations from types import MappingProxyType from typing import TYPE_CHECKING from gnupg.helper import _get_logger from .status_handler import StatusHandler if TYPE_CHECKING : from gnupg.gnupg import GPG logger = _get_logger ( __name__ ) class ImportResultHandler ( StatusHandler ): \"\"\" This class handles status messages during key import. \"\"\" counts = \"\"\"count no_user_id imported imported_rsa unchanged n_uids n_subk n_sigs n_revoc sec_read sec_imported sec_dups not_imported\"\"\" . split () returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . results = [] self . fingerprints = [] for result in self . counts : setattr ( self , result , 0 ) def __nonzero__ ( self ) -> bool : return bool ( not self . not_imported and self . fingerprints ) __bool__ = __nonzero__ ok_reason = MappingProxyType ( { \"0\" : \"Not actually changed\" , \"1\" : \"Entirely new key\" , \"2\" : \"New user IDs\" , \"4\" : \"New signatures\" , \"8\" : \"New subkeys\" , \"16\" : \"Contains private key\" , }, ) problem_reason = MappingProxyType ( { \"0\" : \"No specific reason given\" , \"1\" : \"Invalid Certificate\" , \"2\" : \"Issuer Certificate missing\" , \"3\" : \"Certificate Chain too long\" , \"4\" : \"Error storing certificate\" , }, ) def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ): # pragma: no cover logger . warning ( \"potential problem: %s : %s \" , key , value ) elif key in ( \"IMPORTED\" , \"KEY_CONSIDERED\" ): # this duplicates info we already see in import_ok & import_problem pass elif key == \"NODATA\" : # pragma: no cover self . results . append ({ \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"No valid data found\" }) elif key == \"IMPORT_OK\" : reason , fingerprint = value . split () reasons = [] for code , text in list ( self . ok_reason . items ()): if int ( reason ) | int ( code ) == int ( reason ): reasons . append ( text ) reasontext = \" \\n \" . join ( reasons ) + \" \\n \" self . results . append ({ \"fingerprint\" : fingerprint , \"ok\" : reason , \"text\" : reasontext }) self . fingerprints . append ( fingerprint ) elif key == \"IMPORT_PROBLEM\" : # pragma: no cover try : reason , fingerprint = value . split () except ( AttributeError , Exception ): reason = value fingerprint = \"<unknown>\" self . results . append ({ \"fingerprint\" : fingerprint , \"problem\" : reason , \"text\" : self . problem_reason [ reason ]}) elif key == \"IMPORT_RES\" : import_res = value . split () for i , count in enumerate ( self . counts ): setattr ( self , count , int ( import_res [ i ])) elif key == \"KEYEXPIRED\" : # pragma: no cover self . results . append ({ \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"Key expired\" }) elif key == \"SIGEXPIRED\" : # pragma: no cover self . results . append ({ \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"Signature expired\" }) elif key == \"FAILURE\" : # pragma: no cover self . results . append ({ \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"Other failure\" }) else : # pragma: no cover logger . debug ( \"message ignored: %s , %s \" , key , value ) def summary ( self ) -> str : \"\"\" Return a summary indicating how many keys were imported and how many were not imported. \"\"\" result = [] result . append ( \" %d imported\" % self . imported ) if self . not_imported : # pragma: no cover result . append ( \" %d not imported\" % self . not_imported ) return \", \" . join ( result )","title":"Module gnupg.handlers.import_result_handler"},{"location":"reference/gnupg/handlers/import_result_handler/#variables","text":"TYPE_CHECKING logger","title":"Variables"},{"location":"reference/gnupg/handlers/import_result_handler/#classes","text":"","title":"Classes"},{"location":"reference/gnupg/handlers/import_result_handler/#importresulthandler","text":"class ImportResultHandler ( gpg : 'GPG' ) This class handles status messages during key import. View Source class ImportResultHandler ( StatusHandler ) : \"\"\" This class handles status messages during key import. \"\"\" counts = \"\"\"count no_user_id imported imported_rsa unchanged n_uids n_subk n_sigs n_revoc sec_read sec_imported sec_dups not_imported\"\"\" . split () returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . results = [] self . fingerprints = [] for result in self . counts : setattr ( self , result , 0 ) def __nonzero__ ( self ) -> bool : return bool ( not self . not_imported and self . fingerprints ) __bool__ = __nonzero__ ok_reason = MappingProxyType ( { \"0\" : \"Not actually changed\" , \"1\" : \"Entirely new key\" , \"2\" : \"New user IDs\" , \"4\" : \"New signatures\" , \"8\" : \"New subkeys\" , \"16\" : \"Contains private key\" , } , ) problem_reason = MappingProxyType ( { \"0\" : \"No specific reason given\" , \"1\" : \"Invalid Certificate\" , \"2\" : \"Issuer Certificate missing\" , \"3\" : \"Certificate Chain too long\" , \"4\" : \"Error storing certificate\" , } , ) def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ) : # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key in ( \"IMPORTED\" , \"KEY_CONSIDERED\" ) : # this duplicates info we already see in import_ok & import_problem pass elif key == \"NODATA\" : # pragma : no cover self . results . append ( { \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"No valid data found\" } ) elif key == \"IMPORT_OK\" : reason , fingerprint = value . split () reasons = [] for code , text in list ( self . ok_reason . items ()) : if int ( reason ) | int ( code ) == int ( reason ) : reasons . append ( text ) reasontext = \"\\n\" . join ( reasons ) + \"\\n\" self . results . append ( { \"fingerprint\" : fingerprint , \"ok\" : reason , \"text\" : reasontext } ) self . fingerprints . append ( fingerprint ) elif key == \"IMPORT_PROBLEM\" : # pragma : no cover try : reason , fingerprint = value . split () except ( AttributeError , Exception ) : reason = value fingerprint = \"<unknown>\" self . results . append ( { \"fingerprint\" : fingerprint , \"problem\" : reason , \"text\" : self . problem_reason [ reason ] } ) elif key == \"IMPORT_RES\" : import_res = value . split () for i , count in enumerate ( self . counts ) : setattr ( self , count , int ( import_res [ i ] )) elif key == \"KEYEXPIRED\" : # pragma : no cover self . results . append ( { \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"Key expired\" } ) elif key == \"SIGEXPIRED\" : # pragma : no cover self . results . append ( { \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"Signature expired\" } ) elif key == \"FAILURE\" : # pragma : no cover self . results . append ( { \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"Other failure\" } ) else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value ) def summary ( self ) -> str : \"\"\" Return a summary indicating how many keys were imported and how many were not imported. \"\"\" result = [] result . append ( \"%d imported\" % self . imported ) if self . not_imported : # pragma : no cover result . append ( \"%d not imported\" % self . not_imported ) return \", \" . join ( result )","title":"ImportResultHandler"},{"location":"reference/gnupg/handlers/import_result_handler/#ancestors-in-mro","text":"gnupg.handlers.status_handler.StatusHandler","title":"Ancestors (in MRO)"},{"location":"reference/gnupg/handlers/import_result_handler/#class-variables","text":"counts ok_reason problem_reason returncode","title":"Class variables"},{"location":"reference/gnupg/handlers/import_result_handler/#methods","text":"","title":"Methods"},{"location":"reference/gnupg/handlers/import_result_handler/#handle_status","text":"def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" ) : # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key in ( \"IMPORTED\" , \"KEY_CONSIDERED\" ) : # this duplicates info we already see in import_ok & import_problem pass elif key == \"NODATA\" : # pragma : no cover self . results . append ( { \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"No valid data found\" } ) elif key == \"IMPORT_OK\" : reason , fingerprint = value . split () reasons = [] for code , text in list ( self . ok_reason . items ()) : if int ( reason ) | int ( code ) == int ( reason ) : reasons . append ( text ) reasontext = \"\\n\" . join ( reasons ) + \"\\n\" self . results . append ( { \"fingerprint\" : fingerprint , \"ok\" : reason , \"text\" : reasontext } ) self . fingerprints . append ( fingerprint ) elif key == \"IMPORT_PROBLEM\" : # pragma : no cover try : reason , fingerprint = value . split () except ( AttributeError , Exception ) : reason = value fingerprint = \"<unknown>\" self . results . append ( { \"fingerprint\" : fingerprint , \"problem\" : reason , \"text\" : self . problem_reason [ reason ] } ) elif key == \"IMPORT_RES\" : import_res = value . split () for i , count in enumerate ( self . counts ) : setattr ( self , count , int ( import_res [ i ] )) elif key == \"KEYEXPIRED\" : # pragma : no cover self . results . append ( { \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"Key expired\" } ) elif key == \"SIGEXPIRED\" : # pragma : no cover self . results . append ( { \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"Signature expired\" } ) elif key == \"FAILURE\" : # pragma : no cover self . results . append ( { \"fingerprint\" : None , \"problem\" : \"0\" , \"text\" : \"Other failure\" } ) else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value )","title":"handle_status"},{"location":"reference/gnupg/handlers/import_result_handler/#summary","text":"def summary ( self ) -> 'str' Return a summary indicating how many keys were imported and how many were not imported. View Source def summary ( self ) -> str : \"\"\" Return a summary indicating how many keys were imported and how many were not imported. \"\"\" result = [] result . append ( \"%d imported\" % self . imported ) if self . not_imported : # pragma : no cover result . append ( \"%d not imported\" % self . not_imported ) return \", \" . join ( result )","title":"summary"},{"location":"reference/gnupg/handlers/list_keys_handler/","text":"Module gnupg.handlers.list_keys_handler View Source from __future__ import annotations from typing import TYPE_CHECKING from .helper import _set_fields from .search_keys_handler import SearchKeysHandler if TYPE_CHECKING : from gnupg.gnupg import GPG class ListKeysHandler ( SearchKeysHandler ): \"\"\" This class handles status messages during listing keys and signatures. Handle pub and uid (relating the latter to the former). We don't care about (info from GnuPG DETAILS file): crt = X.509 certificate crs = X.509 certificate and private key available uat = user attribute (same as user id except for field 10). sig = signature rev = revocation signature pkd = public key data (special field format, see below) grp = reserved for gpgsm rvk = revocation key \"\"\" UID_INDEX = 9 FIELDS = ( \"type trust length algo keyid date expires dummy ownertrust uid sig\" \" cap issuer flag token hash curve compliance updated origin keygrip\" ) . split () def __init__ ( self , gpg : GPG ) -> None : super () . __init__ ( gpg ) self . in_subkey = False self . key_map = {} def key ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" self . curkey = curkey = self . get_fields ( args ) if curkey [ \"uid\" ]: # pragma: no cover curkey [ \"uids\" ] . append ( curkey [ \"uid\" ]) del curkey [ \"uid\" ] curkey [ \"subkeys\" ] = [] self . append ( curkey ) self . in_subkey = False pub = sec = key def fpr ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" fp = args [ 9 ] if fp in self . key_map and self . gpg . check_fingerprint_collisions : # pragma: no cover msg = f \"Unexpected fingerprint collision: { fp } \" raise ValueError ( msg ) if not self . in_subkey : self . curkey [ \"fingerprint\" ] = fp self . fingerprints . append ( fp ) self . key_map [ fp ] = self . curkey else : self . curkey [ \"subkeys\" ][ - 1 ][ 2 ] = fp self . key_map [ fp ] = self . curkey def grp ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" grp = args [ 9 ] if not self . in_subkey : self . curkey [ \"keygrip\" ] = grp else : self . curkey [ \"subkeys\" ][ - 1 ][ 3 ] = grp def _collect_subkey_info ( self , curkey : dict [ str , str | list [ str ] | list [ list [ str | None ]] | dict [ str , dict [ str , str ]] | list [ tuple [ str , str , str ]], ], args : list [ str ], ) -> None : info_map = curkey . setdefault ( \"subkey_info\" , {}) info = {} _set_fields ( info , self . FIELDS , args ) info_map [ args [ 4 ]] = info def sub ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" # See issue #81. We create a dict with more information about # subkeys, but for backward compatibility reason, have to add it in # as a separate entry 'subkey_info' subkey = [ args [ 4 ], args [ 11 ], None , None ] # keyid, type, fp, grp self . curkey [ \"subkeys\" ] . append ( subkey ) self . _collect_subkey_info ( self . curkey , args ) self . in_subkey = True def ssb ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" subkey = [ args [ 4 ], None , None , None ] # keyid, type, fp, grp self . curkey [ \"subkeys\" ] . append ( subkey ) self . _collect_subkey_info ( self . curkey , args ) self . in_subkey = True def sig ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" # keyid, uid, sigclass self . curkey [ \"sigs\" ] . append (( args [ 4 ], args [ 9 ], args [ 10 ])) Variables TYPE_CHECKING Classes ListKeysHandler class ListKeysHandler ( gpg : 'GPG' ) This class handles status messages during listing keys and signatures. Handle pub and uid (relating the latter to the former). We don't care about (info from GnuPG DETAILS file): crt = X.509 certificate crs = X.509 certificate and private key available uat = user attribute (same as user id except for field 10). sig = signature rev = revocation signature pkd = public key data (special field format, see below) grp = reserved for gpgsm rvk = revocation key View Source class ListKeysHandler ( SearchKeysHandler ) : \"\"\" This class handles status messages during listing keys and signatures. Handle pub and uid (relating the latter to the former). We don't care about (info from GnuPG DETAILS file): crt = X.509 certificate crs = X.509 certificate and private key available uat = user attribute (same as user id except for field 10). sig = signature rev = revocation signature pkd = public key data (special field format, see below) grp = reserved for gpgsm rvk = revocation key \"\"\" UID_INDEX = 9 FIELDS = ( \"type trust length algo keyid date expires dummy ownertrust uid sig\" \" cap issuer flag token hash curve compliance updated origin keygrip\" ). split () def __init__ ( self , gpg : GPG ) -> None : super (). __init__ ( gpg ) self . in_subkey = False self . key_map = {} def key ( self , args : list [ str ] ) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" self . curkey = curkey = self . get_fields ( args ) if curkey [ \"uid\" ] : # pragma : no cover curkey [ \"uids\" ] . append ( curkey [ \"uid\" ] ) del curkey [ \"uid\" ] curkey [ \"subkeys\" ] = [] self . append ( curkey ) self . in_subkey = False pub = sec = key def fpr ( self , args : list [ str ] ) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" fp = args [ 9 ] if fp in self . key_map and self . gpg . check_fingerprint_collisions : # pragma : no cover msg = f \"Unexpected fingerprint collision: {fp}\" raise ValueError ( msg ) if not self . in_subkey : self . curkey [ \"fingerprint\" ] = fp self . fingerprints . append ( fp ) self . key_map [ fp ] = self . curkey else : self . curkey [ \"subkeys\" ][ -1 ][ 2 ] = fp self . key_map [ fp ] = self . curkey def grp ( self , args : list [ str ] ) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" grp = args [ 9 ] if not self . in_subkey : self . curkey [ \"keygrip\" ] = grp else : self . curkey [ \"subkeys\" ][ -1 ][ 3 ] = grp def _collect_subkey_info ( self , curkey : dict [ str, str | list[str ] | list [ list[str | None ] ] | dict [ str, dict[str, str ] ] | list [ tuple[str, str, str ] ] , ] , args : list [ str ] , ) -> None : info_map = curkey . setdefault ( \"subkey_info\" , {} ) info = {} _set_fields ( info , self . FIELDS , args ) info_map [ args[4 ] ] = info def sub ( self , args : list [ str ] ) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" # See issue #81 . We create a dict with more information about # subkeys , but for backward compatibility reason , have to add it in # as a separate entry 'subkey_info' subkey = [ args[4 ] , args [ 11 ] , None , None ] # keyid , type , fp , grp self . curkey [ \"subkeys\" ] . append ( subkey ) self . _collect_subkey_info ( self . curkey , args ) self . in_subkey = True def ssb ( self , args : list [ str ] ) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" subkey = [ args[4 ] , None , None , None ] # keyid , type , fp , grp self . curkey [ \"subkeys\" ] . append ( subkey ) self . _collect_subkey_info ( self . curkey , args ) self . in_subkey = True def sig ( self , args : list [ str ] ) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" # keyid , uid , sigclass self . curkey [ \"sigs\" ] . append (( args [ 4 ] , args [ 9 ] , args [ 10 ] )) Ancestors (in MRO) gnupg.handlers.search_keys_handler.SearchKeysHandler gnupg.handlers.status_handler.StatusHandler builtins.list Descendants gnupg.handlers.scan_keys_handler.ScanKeysHandler Class variables FIELDS UID_INDEX returncode Methods append def append ( self , object , / ) Append object to the end of the list. clear def clear ( self , / ) Remove all items from list. copy def copy ( self , / ) Return a shallow copy of the list. count def count ( self , value , / ) Return number of occurrences of value. extend def extend ( self , iterable , / ) Extend list by appending elements from the iterable. fpr def fpr ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def fpr ( self , args : list [ str ] ) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" fp = args [ 9 ] if fp in self . key_map and self . gpg . check_fingerprint_collisions : # pragma : no cover msg = f \"Unexpected fingerprint collision: {fp}\" raise ValueError ( msg ) if not self . in_subkey : self . curkey [ \"fingerprint\" ] = fp self . fingerprints . append ( fp ) self . key_map [ fp ] = self . curkey else : self . curkey [ \"subkeys\" ][ -1 ][ 2 ] = fp self . key_map [ fp ] = self . curkey get_fields def get_fields ( self , args : 'list[str]' ) -> 'dict[str, str]' Internal method used to update the instance from a gpg status message. View Source def get_fields ( self , args : list [ str ] ) -> dict [ str , str ] : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" result = {} _set_fields ( result , self . FIELDS , args ) result [ \"uids\" ] = [] result [ \"sigs\" ] = [] return result grp def grp ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def grp ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" grp = args [ 9 ] if not self . in_subkey : self . curkey [ \"keygrip\" ] = grp else : self . curkey [ \"subkeys\" ][ - 1 ][ 3 ] = grp handle_status def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : # pragma : no cover pass index def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present. insert def insert ( self , index , object , / ) Insert object before index. key def key ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def key ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" self . curkey = curkey = self . get_fields ( args ) if curkey [ \"uid\" ] : # pragma: no cover curkey [ \"uids\" ] . append ( curkey [ \"uid\" ] ) del curkey [ \"uid\" ] curkey [ \"subkeys\" ] = [] self . append ( curkey ) self . in_subkey = False pop def pop ( self , index =- 1 , / ) Remove and return item at index (default last). Raises IndexError if list is empty or index is out of range. pub def pub ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def key ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" self . curkey = curkey = self . get_fields ( args ) if curkey [ \"uid\" ] : # pragma: no cover curkey [ \"uids\" ] . append ( curkey [ \"uid\" ] ) del curkey [ \"uid\" ] curkey [ \"subkeys\" ] = [] self . append ( curkey ) self . in_subkey = False remove def remove ( self , value , / ) Remove first occurrence of value. Raises ValueError if the value is not present. reverse def reverse ( self , / ) Reverse IN PLACE . sec def sec ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def key ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" self . curkey = curkey = self . get_fields ( args ) if curkey [ \"uid\" ] : # pragma: no cover curkey [ \"uids\" ] . append ( curkey [ \"uid\" ] ) del curkey [ \"uid\" ] curkey [ \"subkeys\" ] = [] self . append ( curkey ) self . in_subkey = False sig def sig ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def sig ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" # keyid, uid, sigclass self . curkey [ \"sigs\" ] . append (( args [ 4 ] , args [ 9 ] , args [ 10 ] )) sort def sort ( self , / , * , key = None , reverse = False ) Sort the list in ascending order and return None. The sort is in-place (i.e. the list itself is modified) and stable (i.e. the order of two equal elements is maintained). If a key function is given, apply it once to each list item and sort them, ascending or descending, according to their function values. The reverse flag can be set to sort in descending order. ssb def ssb ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def ssb ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" subkey = [ args [ 4 ], None , None , None ] # keyid , type , fp , grp self . curkey [ \"subkeys\" ]. append ( subkey ) self . _collect_subkey_info ( self . curkey , args ) self . in_subkey = True sub def sub ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def sub ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" # See issue # 81 . We create a dict with more information about # subkeys , but for backward compatibility reason , have to add it in # as a separate entry ' subkey_info ' subkey = [ args [ 4 ], args [ 11 ], None , None ] # keyid , type , fp , grp self . curkey [ \"subkeys\" ]. append ( subkey ) self . _collect_subkey_info ( self . curkey , args ) self . in_subkey = True uid def uid ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def uid ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" uid = args [ self . UID_INDEX ] uid = ESCAPE_PATTERN . sub ( lambda m : chr ( int ( m . group ( 1 ), 16 )), uid ) for k , v in BASIC_ESCAPES . items () : uid = uid . replace ( k , v ) self . curkey [ \"uids\" ] . append ( uid ) self . uids . append ( uid )","title":"List Keys Handler"},{"location":"reference/gnupg/handlers/list_keys_handler/#module-gnupghandlerslist_keys_handler","text":"View Source from __future__ import annotations from typing import TYPE_CHECKING from .helper import _set_fields from .search_keys_handler import SearchKeysHandler if TYPE_CHECKING : from gnupg.gnupg import GPG class ListKeysHandler ( SearchKeysHandler ): \"\"\" This class handles status messages during listing keys and signatures. Handle pub and uid (relating the latter to the former). We don't care about (info from GnuPG DETAILS file): crt = X.509 certificate crs = X.509 certificate and private key available uat = user attribute (same as user id except for field 10). sig = signature rev = revocation signature pkd = public key data (special field format, see below) grp = reserved for gpgsm rvk = revocation key \"\"\" UID_INDEX = 9 FIELDS = ( \"type trust length algo keyid date expires dummy ownertrust uid sig\" \" cap issuer flag token hash curve compliance updated origin keygrip\" ) . split () def __init__ ( self , gpg : GPG ) -> None : super () . __init__ ( gpg ) self . in_subkey = False self . key_map = {} def key ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" self . curkey = curkey = self . get_fields ( args ) if curkey [ \"uid\" ]: # pragma: no cover curkey [ \"uids\" ] . append ( curkey [ \"uid\" ]) del curkey [ \"uid\" ] curkey [ \"subkeys\" ] = [] self . append ( curkey ) self . in_subkey = False pub = sec = key def fpr ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" fp = args [ 9 ] if fp in self . key_map and self . gpg . check_fingerprint_collisions : # pragma: no cover msg = f \"Unexpected fingerprint collision: { fp } \" raise ValueError ( msg ) if not self . in_subkey : self . curkey [ \"fingerprint\" ] = fp self . fingerprints . append ( fp ) self . key_map [ fp ] = self . curkey else : self . curkey [ \"subkeys\" ][ - 1 ][ 2 ] = fp self . key_map [ fp ] = self . curkey def grp ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" grp = args [ 9 ] if not self . in_subkey : self . curkey [ \"keygrip\" ] = grp else : self . curkey [ \"subkeys\" ][ - 1 ][ 3 ] = grp def _collect_subkey_info ( self , curkey : dict [ str , str | list [ str ] | list [ list [ str | None ]] | dict [ str , dict [ str , str ]] | list [ tuple [ str , str , str ]], ], args : list [ str ], ) -> None : info_map = curkey . setdefault ( \"subkey_info\" , {}) info = {} _set_fields ( info , self . FIELDS , args ) info_map [ args [ 4 ]] = info def sub ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" # See issue #81. We create a dict with more information about # subkeys, but for backward compatibility reason, have to add it in # as a separate entry 'subkey_info' subkey = [ args [ 4 ], args [ 11 ], None , None ] # keyid, type, fp, grp self . curkey [ \"subkeys\" ] . append ( subkey ) self . _collect_subkey_info ( self . curkey , args ) self . in_subkey = True def ssb ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" subkey = [ args [ 4 ], None , None , None ] # keyid, type, fp, grp self . curkey [ \"subkeys\" ] . append ( subkey ) self . _collect_subkey_info ( self . curkey , args ) self . in_subkey = True def sig ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" # keyid, uid, sigclass self . curkey [ \"sigs\" ] . append (( args [ 4 ], args [ 9 ], args [ 10 ]))","title":"Module gnupg.handlers.list_keys_handler"},{"location":"reference/gnupg/handlers/list_keys_handler/#variables","text":"TYPE_CHECKING","title":"Variables"},{"location":"reference/gnupg/handlers/list_keys_handler/#classes","text":"","title":"Classes"},{"location":"reference/gnupg/handlers/list_keys_handler/#listkeyshandler","text":"class ListKeysHandler ( gpg : 'GPG' ) This class handles status messages during listing keys and signatures. Handle pub and uid (relating the latter to the former). We don't care about (info from GnuPG DETAILS file): crt = X.509 certificate crs = X.509 certificate and private key available uat = user attribute (same as user id except for field 10). sig = signature rev = revocation signature pkd = public key data (special field format, see below) grp = reserved for gpgsm rvk = revocation key View Source class ListKeysHandler ( SearchKeysHandler ) : \"\"\" This class handles status messages during listing keys and signatures. Handle pub and uid (relating the latter to the former). We don't care about (info from GnuPG DETAILS file): crt = X.509 certificate crs = X.509 certificate and private key available uat = user attribute (same as user id except for field 10). sig = signature rev = revocation signature pkd = public key data (special field format, see below) grp = reserved for gpgsm rvk = revocation key \"\"\" UID_INDEX = 9 FIELDS = ( \"type trust length algo keyid date expires dummy ownertrust uid sig\" \" cap issuer flag token hash curve compliance updated origin keygrip\" ). split () def __init__ ( self , gpg : GPG ) -> None : super (). __init__ ( gpg ) self . in_subkey = False self . key_map = {} def key ( self , args : list [ str ] ) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" self . curkey = curkey = self . get_fields ( args ) if curkey [ \"uid\" ] : # pragma : no cover curkey [ \"uids\" ] . append ( curkey [ \"uid\" ] ) del curkey [ \"uid\" ] curkey [ \"subkeys\" ] = [] self . append ( curkey ) self . in_subkey = False pub = sec = key def fpr ( self , args : list [ str ] ) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" fp = args [ 9 ] if fp in self . key_map and self . gpg . check_fingerprint_collisions : # pragma : no cover msg = f \"Unexpected fingerprint collision: {fp}\" raise ValueError ( msg ) if not self . in_subkey : self . curkey [ \"fingerprint\" ] = fp self . fingerprints . append ( fp ) self . key_map [ fp ] = self . curkey else : self . curkey [ \"subkeys\" ][ -1 ][ 2 ] = fp self . key_map [ fp ] = self . curkey def grp ( self , args : list [ str ] ) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" grp = args [ 9 ] if not self . in_subkey : self . curkey [ \"keygrip\" ] = grp else : self . curkey [ \"subkeys\" ][ -1 ][ 3 ] = grp def _collect_subkey_info ( self , curkey : dict [ str, str | list[str ] | list [ list[str | None ] ] | dict [ str, dict[str, str ] ] | list [ tuple[str, str, str ] ] , ] , args : list [ str ] , ) -> None : info_map = curkey . setdefault ( \"subkey_info\" , {} ) info = {} _set_fields ( info , self . FIELDS , args ) info_map [ args[4 ] ] = info def sub ( self , args : list [ str ] ) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" # See issue #81 . We create a dict with more information about # subkeys , but for backward compatibility reason , have to add it in # as a separate entry 'subkey_info' subkey = [ args[4 ] , args [ 11 ] , None , None ] # keyid , type , fp , grp self . curkey [ \"subkeys\" ] . append ( subkey ) self . _collect_subkey_info ( self . curkey , args ) self . in_subkey = True def ssb ( self , args : list [ str ] ) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" subkey = [ args[4 ] , None , None , None ] # keyid , type , fp , grp self . curkey [ \"subkeys\" ] . append ( subkey ) self . _collect_subkey_info ( self . curkey , args ) self . in_subkey = True def sig ( self , args : list [ str ] ) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" # keyid , uid , sigclass self . curkey [ \"sigs\" ] . append (( args [ 4 ] , args [ 9 ] , args [ 10 ] ))","title":"ListKeysHandler"},{"location":"reference/gnupg/handlers/list_keys_handler/#ancestors-in-mro","text":"gnupg.handlers.search_keys_handler.SearchKeysHandler gnupg.handlers.status_handler.StatusHandler builtins.list","title":"Ancestors (in MRO)"},{"location":"reference/gnupg/handlers/list_keys_handler/#descendants","text":"gnupg.handlers.scan_keys_handler.ScanKeysHandler","title":"Descendants"},{"location":"reference/gnupg/handlers/list_keys_handler/#class-variables","text":"FIELDS UID_INDEX returncode","title":"Class variables"},{"location":"reference/gnupg/handlers/list_keys_handler/#methods","text":"","title":"Methods"},{"location":"reference/gnupg/handlers/list_keys_handler/#append","text":"def append ( self , object , / ) Append object to the end of the list.","title":"append"},{"location":"reference/gnupg/handlers/list_keys_handler/#clear","text":"def clear ( self , / ) Remove all items from list.","title":"clear"},{"location":"reference/gnupg/handlers/list_keys_handler/#copy","text":"def copy ( self , / ) Return a shallow copy of the list.","title":"copy"},{"location":"reference/gnupg/handlers/list_keys_handler/#count","text":"def count ( self , value , / ) Return number of occurrences of value.","title":"count"},{"location":"reference/gnupg/handlers/list_keys_handler/#extend","text":"def extend ( self , iterable , / ) Extend list by appending elements from the iterable.","title":"extend"},{"location":"reference/gnupg/handlers/list_keys_handler/#fpr","text":"def fpr ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def fpr ( self , args : list [ str ] ) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" fp = args [ 9 ] if fp in self . key_map and self . gpg . check_fingerprint_collisions : # pragma : no cover msg = f \"Unexpected fingerprint collision: {fp}\" raise ValueError ( msg ) if not self . in_subkey : self . curkey [ \"fingerprint\" ] = fp self . fingerprints . append ( fp ) self . key_map [ fp ] = self . curkey else : self . curkey [ \"subkeys\" ][ -1 ][ 2 ] = fp self . key_map [ fp ] = self . curkey","title":"fpr"},{"location":"reference/gnupg/handlers/list_keys_handler/#get_fields","text":"def get_fields ( self , args : 'list[str]' ) -> 'dict[str, str]' Internal method used to update the instance from a gpg status message. View Source def get_fields ( self , args : list [ str ] ) -> dict [ str , str ] : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" result = {} _set_fields ( result , self . FIELDS , args ) result [ \"uids\" ] = [] result [ \"sigs\" ] = [] return result","title":"get_fields"},{"location":"reference/gnupg/handlers/list_keys_handler/#grp","text":"def grp ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def grp ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" grp = args [ 9 ] if not self . in_subkey : self . curkey [ \"keygrip\" ] = grp else : self . curkey [ \"subkeys\" ][ - 1 ][ 3 ] = grp","title":"grp"},{"location":"reference/gnupg/handlers/list_keys_handler/#handle_status","text":"def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : # pragma : no cover pass","title":"handle_status"},{"location":"reference/gnupg/handlers/list_keys_handler/#index","text":"def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present.","title":"index"},{"location":"reference/gnupg/handlers/list_keys_handler/#insert","text":"def insert ( self , index , object , / ) Insert object before index.","title":"insert"},{"location":"reference/gnupg/handlers/list_keys_handler/#key","text":"def key ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def key ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" self . curkey = curkey = self . get_fields ( args ) if curkey [ \"uid\" ] : # pragma: no cover curkey [ \"uids\" ] . append ( curkey [ \"uid\" ] ) del curkey [ \"uid\" ] curkey [ \"subkeys\" ] = [] self . append ( curkey ) self . in_subkey = False","title":"key"},{"location":"reference/gnupg/handlers/list_keys_handler/#pop","text":"def pop ( self , index =- 1 , / ) Remove and return item at index (default last). Raises IndexError if list is empty or index is out of range.","title":"pop"},{"location":"reference/gnupg/handlers/list_keys_handler/#pub","text":"def pub ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def key ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" self . curkey = curkey = self . get_fields ( args ) if curkey [ \"uid\" ] : # pragma: no cover curkey [ \"uids\" ] . append ( curkey [ \"uid\" ] ) del curkey [ \"uid\" ] curkey [ \"subkeys\" ] = [] self . append ( curkey ) self . in_subkey = False","title":"pub"},{"location":"reference/gnupg/handlers/list_keys_handler/#remove","text":"def remove ( self , value , / ) Remove first occurrence of value. Raises ValueError if the value is not present.","title":"remove"},{"location":"reference/gnupg/handlers/list_keys_handler/#reverse","text":"def reverse ( self , / ) Reverse IN PLACE .","title":"reverse"},{"location":"reference/gnupg/handlers/list_keys_handler/#sec","text":"def sec ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def key ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" self . curkey = curkey = self . get_fields ( args ) if curkey [ \"uid\" ] : # pragma: no cover curkey [ \"uids\" ] . append ( curkey [ \"uid\" ] ) del curkey [ \"uid\" ] curkey [ \"subkeys\" ] = [] self . append ( curkey ) self . in_subkey = False","title":"sec"},{"location":"reference/gnupg/handlers/list_keys_handler/#sig","text":"def sig ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def sig ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" # keyid, uid, sigclass self . curkey [ \"sigs\" ] . append (( args [ 4 ] , args [ 9 ] , args [ 10 ] ))","title":"sig"},{"location":"reference/gnupg/handlers/list_keys_handler/#sort","text":"def sort ( self , / , * , key = None , reverse = False ) Sort the list in ascending order and return None. The sort is in-place (i.e. the list itself is modified) and stable (i.e. the order of two equal elements is maintained). If a key function is given, apply it once to each list item and sort them, ascending or descending, according to their function values. The reverse flag can be set to sort in descending order.","title":"sort"},{"location":"reference/gnupg/handlers/list_keys_handler/#ssb","text":"def ssb ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def ssb ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" subkey = [ args [ 4 ], None , None , None ] # keyid , type , fp , grp self . curkey [ \"subkeys\" ]. append ( subkey ) self . _collect_subkey_info ( self . curkey , args ) self . in_subkey = True","title":"ssb"},{"location":"reference/gnupg/handlers/list_keys_handler/#sub","text":"def sub ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def sub ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" # See issue # 81 . We create a dict with more information about # subkeys , but for backward compatibility reason , have to add it in # as a separate entry ' subkey_info ' subkey = [ args [ 4 ], args [ 11 ], None , None ] # keyid , type , fp , grp self . curkey [ \"subkeys\" ]. append ( subkey ) self . _collect_subkey_info ( self . curkey , args ) self . in_subkey = True","title":"sub"},{"location":"reference/gnupg/handlers/list_keys_handler/#uid","text":"def uid ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def uid ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" uid = args [ self . UID_INDEX ] uid = ESCAPE_PATTERN . sub ( lambda m : chr ( int ( m . group ( 1 ), 16 )), uid ) for k , v in BASIC_ESCAPES . items () : uid = uid . replace ( k , v ) self . curkey [ \"uids\" ] . append ( uid ) self . uids . append ( uid )","title":"uid"},{"location":"reference/gnupg/handlers/scan_keys_handler/","text":"Module gnupg.handlers.scan_keys_handler View Source from __future__ import annotations from .list_keys_handler import ListKeysHandler class ScanKeysHandler ( ListKeysHandler ): \"\"\" This class handles status messages during scanning keys. \"\"\" def sub ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" # --with-fingerprint --with-colons somehow outputs fewer colons, # use the last value args[-1] instead of args[11] subkey = [ args [ 4 ], args [ - 1 ], None , None ] self . curkey [ \"subkeys\" ] . append ( subkey ) self . _collect_subkey_info ( self . curkey , args ) self . in_subkey = True Classes ScanKeysHandler class ScanKeysHandler ( gpg : 'GPG' ) This class handles status messages during scanning keys. View Source class ScanKeysHandler ( ListKeysHandler ) : \" \"\" This class handles status messages during scanning keys. \"\" \" def sub ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" # --with-fingerprint --with-colons somehow outputs fewer colons, # use the last value args[-1] instead of args[11] subkey = [ args [ 4 ] , args [ - 1 ] , None , None ] self . curkey [ \"subkeys\" ] . append ( subkey ) self . _collect_subkey_info ( self . curkey , args ) self . in_subkey = True Ancestors (in MRO) gnupg.handlers.list_keys_handler.ListKeysHandler gnupg.handlers.search_keys_handler.SearchKeysHandler gnupg.handlers.status_handler.StatusHandler builtins.list Class variables FIELDS UID_INDEX returncode Methods append def append ( self , object , / ) Append object to the end of the list. clear def clear ( self , / ) Remove all items from list. copy def copy ( self , / ) Return a shallow copy of the list. count def count ( self , value , / ) Return number of occurrences of value. extend def extend ( self , iterable , / ) Extend list by appending elements from the iterable. fpr def fpr ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def fpr ( self , args : list [ str ] ) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" fp = args [ 9 ] if fp in self . key_map and self . gpg . check_fingerprint_collisions : # pragma : no cover msg = f \"Unexpected fingerprint collision: {fp}\" raise ValueError ( msg ) if not self . in_subkey : self . curkey [ \"fingerprint\" ] = fp self . fingerprints . append ( fp ) self . key_map [ fp ] = self . curkey else : self . curkey [ \"subkeys\" ][ -1 ][ 2 ] = fp self . key_map [ fp ] = self . curkey get_fields def get_fields ( self , args : 'list[str]' ) -> 'dict[str, str]' Internal method used to update the instance from a gpg status message. View Source def get_fields ( self , args : list [ str ] ) -> dict [ str , str ] : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" result = {} _set_fields ( result , self . FIELDS , args ) result [ \"uids\" ] = [] result [ \"sigs\" ] = [] return result grp def grp ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def grp ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" grp = args [ 9 ] if not self . in_subkey : self . curkey [ \"keygrip\" ] = grp else : self . curkey [ \"subkeys\" ][ - 1 ][ 3 ] = grp handle_status def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : # pragma : no cover pass index def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present. insert def insert ( self , index , object , / ) Insert object before index. key def key ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def key ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" self . curkey = curkey = self . get_fields ( args ) if curkey [ \"uid\" ] : # pragma: no cover curkey [ \"uids\" ] . append ( curkey [ \"uid\" ] ) del curkey [ \"uid\" ] curkey [ \"subkeys\" ] = [] self . append ( curkey ) self . in_subkey = False pop def pop ( self , index =- 1 , / ) Remove and return item at index (default last). Raises IndexError if list is empty or index is out of range. pub def pub ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def key ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" self . curkey = curkey = self . get_fields ( args ) if curkey [ \"uid\" ] : # pragma: no cover curkey [ \"uids\" ] . append ( curkey [ \"uid\" ] ) del curkey [ \"uid\" ] curkey [ \"subkeys\" ] = [] self . append ( curkey ) self . in_subkey = False remove def remove ( self , value , / ) Remove first occurrence of value. Raises ValueError if the value is not present. reverse def reverse ( self , / ) Reverse IN PLACE . sec def sec ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def key ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" self . curkey = curkey = self . get_fields ( args ) if curkey [ \"uid\" ] : # pragma: no cover curkey [ \"uids\" ] . append ( curkey [ \"uid\" ] ) del curkey [ \"uid\" ] curkey [ \"subkeys\" ] = [] self . append ( curkey ) self . in_subkey = False sig def sig ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def sig ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" # keyid, uid, sigclass self . curkey [ \"sigs\" ] . append (( args [ 4 ] , args [ 9 ] , args [ 10 ] )) sort def sort ( self , / , * , key = None , reverse = False ) Sort the list in ascending order and return None. The sort is in-place (i.e. the list itself is modified) and stable (i.e. the order of two equal elements is maintained). If a key function is given, apply it once to each list item and sort them, ascending or descending, according to their function values. The reverse flag can be set to sort in descending order. ssb def ssb ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def ssb ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" subkey = [ args [ 4 ], None , None , None ] # keyid , type , fp , grp self . curkey [ \"subkeys\" ]. append ( subkey ) self . _collect_subkey_info ( self . curkey , args ) self . in_subkey = True sub def sub ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def sub ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" # --with-fingerprint --with-colons somehow outputs fewer colons, # use the last value args[-1] instead of args[11] subkey = [ args [ 4 ] , args [ - 1 ] , None , None ] self . curkey [ \"subkeys\" ] . append ( subkey ) self . _collect_subkey_info ( self . curkey , args ) self . in_subkey = True uid def uid ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def uid ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" uid = args [ self . UID_INDEX ] uid = ESCAPE_PATTERN . sub ( lambda m : chr ( int ( m . group ( 1 ), 16 )), uid ) for k , v in BASIC_ESCAPES . items () : uid = uid . replace ( k , v ) self . curkey [ \"uids\" ] . append ( uid ) self . uids . append ( uid )","title":"Scan Keys Handler"},{"location":"reference/gnupg/handlers/scan_keys_handler/#module-gnupghandlersscan_keys_handler","text":"View Source from __future__ import annotations from .list_keys_handler import ListKeysHandler class ScanKeysHandler ( ListKeysHandler ): \"\"\" This class handles status messages during scanning keys. \"\"\" def sub ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" # --with-fingerprint --with-colons somehow outputs fewer colons, # use the last value args[-1] instead of args[11] subkey = [ args [ 4 ], args [ - 1 ], None , None ] self . curkey [ \"subkeys\" ] . append ( subkey ) self . _collect_subkey_info ( self . curkey , args ) self . in_subkey = True","title":"Module gnupg.handlers.scan_keys_handler"},{"location":"reference/gnupg/handlers/scan_keys_handler/#classes","text":"","title":"Classes"},{"location":"reference/gnupg/handlers/scan_keys_handler/#scankeyshandler","text":"class ScanKeysHandler ( gpg : 'GPG' ) This class handles status messages during scanning keys. View Source class ScanKeysHandler ( ListKeysHandler ) : \" \"\" This class handles status messages during scanning keys. \"\" \" def sub ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" # --with-fingerprint --with-colons somehow outputs fewer colons, # use the last value args[-1] instead of args[11] subkey = [ args [ 4 ] , args [ - 1 ] , None , None ] self . curkey [ \"subkeys\" ] . append ( subkey ) self . _collect_subkey_info ( self . curkey , args ) self . in_subkey = True","title":"ScanKeysHandler"},{"location":"reference/gnupg/handlers/scan_keys_handler/#ancestors-in-mro","text":"gnupg.handlers.list_keys_handler.ListKeysHandler gnupg.handlers.search_keys_handler.SearchKeysHandler gnupg.handlers.status_handler.StatusHandler builtins.list","title":"Ancestors (in MRO)"},{"location":"reference/gnupg/handlers/scan_keys_handler/#class-variables","text":"FIELDS UID_INDEX returncode","title":"Class variables"},{"location":"reference/gnupg/handlers/scan_keys_handler/#methods","text":"","title":"Methods"},{"location":"reference/gnupg/handlers/scan_keys_handler/#append","text":"def append ( self , object , / ) Append object to the end of the list.","title":"append"},{"location":"reference/gnupg/handlers/scan_keys_handler/#clear","text":"def clear ( self , / ) Remove all items from list.","title":"clear"},{"location":"reference/gnupg/handlers/scan_keys_handler/#copy","text":"def copy ( self , / ) Return a shallow copy of the list.","title":"copy"},{"location":"reference/gnupg/handlers/scan_keys_handler/#count","text":"def count ( self , value , / ) Return number of occurrences of value.","title":"count"},{"location":"reference/gnupg/handlers/scan_keys_handler/#extend","text":"def extend ( self , iterable , / ) Extend list by appending elements from the iterable.","title":"extend"},{"location":"reference/gnupg/handlers/scan_keys_handler/#fpr","text":"def fpr ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def fpr ( self , args : list [ str ] ) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" fp = args [ 9 ] if fp in self . key_map and self . gpg . check_fingerprint_collisions : # pragma : no cover msg = f \"Unexpected fingerprint collision: {fp}\" raise ValueError ( msg ) if not self . in_subkey : self . curkey [ \"fingerprint\" ] = fp self . fingerprints . append ( fp ) self . key_map [ fp ] = self . curkey else : self . curkey [ \"subkeys\" ][ -1 ][ 2 ] = fp self . key_map [ fp ] = self . curkey","title":"fpr"},{"location":"reference/gnupg/handlers/scan_keys_handler/#get_fields","text":"def get_fields ( self , args : 'list[str]' ) -> 'dict[str, str]' Internal method used to update the instance from a gpg status message. View Source def get_fields ( self , args : list [ str ] ) -> dict [ str , str ] : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" result = {} _set_fields ( result , self . FIELDS , args ) result [ \"uids\" ] = [] result [ \"sigs\" ] = [] return result","title":"get_fields"},{"location":"reference/gnupg/handlers/scan_keys_handler/#grp","text":"def grp ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def grp ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" grp = args [ 9 ] if not self . in_subkey : self . curkey [ \"keygrip\" ] = grp else : self . curkey [ \"subkeys\" ][ - 1 ][ 3 ] = grp","title":"grp"},{"location":"reference/gnupg/handlers/scan_keys_handler/#handle_status","text":"def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : # pragma : no cover pass","title":"handle_status"},{"location":"reference/gnupg/handlers/scan_keys_handler/#index","text":"def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present.","title":"index"},{"location":"reference/gnupg/handlers/scan_keys_handler/#insert","text":"def insert ( self , index , object , / ) Insert object before index.","title":"insert"},{"location":"reference/gnupg/handlers/scan_keys_handler/#key","text":"def key ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def key ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" self . curkey = curkey = self . get_fields ( args ) if curkey [ \"uid\" ] : # pragma: no cover curkey [ \"uids\" ] . append ( curkey [ \"uid\" ] ) del curkey [ \"uid\" ] curkey [ \"subkeys\" ] = [] self . append ( curkey ) self . in_subkey = False","title":"key"},{"location":"reference/gnupg/handlers/scan_keys_handler/#pop","text":"def pop ( self , index =- 1 , / ) Remove and return item at index (default last). Raises IndexError if list is empty or index is out of range.","title":"pop"},{"location":"reference/gnupg/handlers/scan_keys_handler/#pub","text":"def pub ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def key ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" self . curkey = curkey = self . get_fields ( args ) if curkey [ \"uid\" ] : # pragma: no cover curkey [ \"uids\" ] . append ( curkey [ \"uid\" ] ) del curkey [ \"uid\" ] curkey [ \"subkeys\" ] = [] self . append ( curkey ) self . in_subkey = False","title":"pub"},{"location":"reference/gnupg/handlers/scan_keys_handler/#remove","text":"def remove ( self , value , / ) Remove first occurrence of value. Raises ValueError if the value is not present.","title":"remove"},{"location":"reference/gnupg/handlers/scan_keys_handler/#reverse","text":"def reverse ( self , / ) Reverse IN PLACE .","title":"reverse"},{"location":"reference/gnupg/handlers/scan_keys_handler/#sec","text":"def sec ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def key ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" self . curkey = curkey = self . get_fields ( args ) if curkey [ \"uid\" ] : # pragma: no cover curkey [ \"uids\" ] . append ( curkey [ \"uid\" ] ) del curkey [ \"uid\" ] curkey [ \"subkeys\" ] = [] self . append ( curkey ) self . in_subkey = False","title":"sec"},{"location":"reference/gnupg/handlers/scan_keys_handler/#sig","text":"def sig ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def sig ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" # keyid, uid, sigclass self . curkey [ \"sigs\" ] . append (( args [ 4 ] , args [ 9 ] , args [ 10 ] ))","title":"sig"},{"location":"reference/gnupg/handlers/scan_keys_handler/#sort","text":"def sort ( self , / , * , key = None , reverse = False ) Sort the list in ascending order and return None. The sort is in-place (i.e. the list itself is modified) and stable (i.e. the order of two equal elements is maintained). If a key function is given, apply it once to each list item and sort them, ascending or descending, according to their function values. The reverse flag can be set to sort in descending order.","title":"sort"},{"location":"reference/gnupg/handlers/scan_keys_handler/#ssb","text":"def ssb ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def ssb ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" subkey = [ args [ 4 ], None , None , None ] # keyid , type , fp , grp self . curkey [ \"subkeys\" ]. append ( subkey ) self . _collect_subkey_info ( self . curkey , args ) self . in_subkey = True","title":"ssb"},{"location":"reference/gnupg/handlers/scan_keys_handler/#sub","text":"def sub ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def sub ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" # --with-fingerprint --with-colons somehow outputs fewer colons, # use the last value args[-1] instead of args[11] subkey = [ args [ 4 ] , args [ - 1 ] , None , None ] self . curkey [ \"subkeys\" ] . append ( subkey ) self . _collect_subkey_info ( self . curkey , args ) self . in_subkey = True","title":"sub"},{"location":"reference/gnupg/handlers/scan_keys_handler/#uid","text":"def uid ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def uid ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" uid = args [ self . UID_INDEX ] uid = ESCAPE_PATTERN . sub ( lambda m : chr ( int ( m . group ( 1 ), 16 )), uid ) for k , v in BASIC_ESCAPES . items () : uid = uid . replace ( k , v ) self . curkey [ \"uids\" ] . append ( uid ) self . uids . append ( uid )","title":"uid"},{"location":"reference/gnupg/handlers/search_keys_handler/","text":"Module gnupg.handlers.search_keys_handler View Source from __future__ import annotations import re from typing import TYPE_CHECKING from .helper import _set_fields from .status_handler import StatusHandler if TYPE_CHECKING : from gnupg.gnupg import GPG ESCAPE_PATTERN = re . compile ( r \" \\\\ x([0-9a-f][0-9a-f])\" , re . IGNORECASE ) BASIC_ESCAPES = { r \"\\n\" : \" \\n \" , r \"\\r\" : \" \\r \" , r \"\\f\" : \" \\f \" , r \"\\v\" : \" \\v \" , r \"\\b\" : \" \\b \" , r \"\\0\" : \" \\0 \" , } class SearchKeysHandler ( StatusHandler , list ): \"\"\" This class handles status messages during key search. \"\"\" # Handle pub and uid (relating the latter to the former). # Don't care about the rest UID_INDEX = 1 FIELDS = \"type keyid algo length date expires\" . split () returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . curkey = None self . fingerprints = [] self . uids = [] def get_fields ( self , args : list [ str ]) -> dict [ str , str ]: \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" result = {} _set_fields ( result , self . FIELDS , args ) result [ \"uids\" ] = [] result [ \"sigs\" ] = [] return result def pub ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" self . curkey = curkey = self . get_fields ( args ) self . append ( curkey ) def uid ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" uid = args [ self . UID_INDEX ] uid = ESCAPE_PATTERN . sub ( lambda m : chr ( int ( m . group ( 1 ), 16 )), uid ) for k , v in BASIC_ESCAPES . items (): uid = uid . replace ( k , v ) self . curkey [ \"uids\" ] . append ( uid ) self . uids . append ( uid ) def handle_status ( self , key : str , value : str ) -> None : # pragma: no cover pass Variables BASIC_ESCAPES ESCAPE_PATTERN TYPE_CHECKING Classes SearchKeysHandler class SearchKeysHandler ( gpg : 'GPG' ) This class handles status messages during key search. View Source class SearchKeysHandler ( StatusHandler , list ): \"\"\" This class handles status messages during key search. \"\"\" # Handle pub and uid ( relating the latter to the former ). # Don ' t care about the rest UID_INDEX = 1 FIELDS = \"type keyid algo length date expires\" . split () returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . curkey = None self . fingerprints = [] self . uids = [] def get_fields ( self , args : list [ str ]) -> dict [ str , str ]: \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" result = {} _set_fields ( result , self . FIELDS , args ) result [ \"uids\" ] = [] result [ \"sigs\" ] = [] return result def pub ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" self . curkey = curkey = self . get_fields ( args ) self . append ( curkey ) def uid ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" uid = args [ self . UID_INDEX ] uid = ESCAPE_PATTERN . sub ( lambda m : chr ( int ( m . group ( 1 ), 16 )), uid ) for k , v in BASIC_ESCAPES . items (): uid = uid . replace ( k , v ) self . curkey [ \"uids\" ]. append ( uid ) self . uids . append ( uid ) def handle_status ( self , key : str , value : str ) -> None : # pragma : no cover pass Ancestors (in MRO) gnupg.handlers.status_handler.StatusHandler builtins.list Descendants gnupg.handlers.list_keys_handler.ListKeysHandler Class variables FIELDS UID_INDEX returncode Methods append def append ( self , object , / ) Append object to the end of the list. clear def clear ( self , / ) Remove all items from list. copy def copy ( self , / ) Return a shallow copy of the list. count def count ( self , value , / ) Return number of occurrences of value. extend def extend ( self , iterable , / ) Extend list by appending elements from the iterable. get_fields def get_fields ( self , args : 'list[str]' ) -> 'dict[str, str]' Internal method used to update the instance from a gpg status message. View Source def get_fields ( self , args : list [ str ] ) -> dict [ str , str ] : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" result = {} _set_fields ( result , self . FIELDS , args ) result [ \"uids\" ] = [] result [ \"sigs\" ] = [] return result handle_status def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : # pragma : no cover pass index def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present. insert def insert ( self , index , object , / ) Insert object before index. pop def pop ( self , index =- 1 , / ) Remove and return item at index (default last). Raises IndexError if list is empty or index is out of range. pub def pub ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def pub ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" self . curkey = curkey = self . get_fields ( args ) self . append ( curkey ) remove def remove ( self , value , / ) Remove first occurrence of value. Raises ValueError if the value is not present. reverse def reverse ( self , / ) Reverse IN PLACE . sort def sort ( self , / , * , key = None , reverse = False ) Sort the list in ascending order and return None. The sort is in-place (i.e. the list itself is modified) and stable (i.e. the order of two equal elements is maintained). If a key function is given, apply it once to each list item and sort them, ascending or descending, according to their function values. The reverse flag can be set to sort in descending order. uid def uid ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def uid ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" uid = args [ self . UID_INDEX ] uid = ESCAPE_PATTERN . sub ( lambda m : chr ( int ( m . group ( 1 ), 16 )), uid ) for k , v in BASIC_ESCAPES . items () : uid = uid . replace ( k , v ) self . curkey [ \"uids\" ] . append ( uid ) self . uids . append ( uid )","title":"Search Keys Handler"},{"location":"reference/gnupg/handlers/search_keys_handler/#module-gnupghandlerssearch_keys_handler","text":"View Source from __future__ import annotations import re from typing import TYPE_CHECKING from .helper import _set_fields from .status_handler import StatusHandler if TYPE_CHECKING : from gnupg.gnupg import GPG ESCAPE_PATTERN = re . compile ( r \" \\\\ x([0-9a-f][0-9a-f])\" , re . IGNORECASE ) BASIC_ESCAPES = { r \"\\n\" : \" \\n \" , r \"\\r\" : \" \\r \" , r \"\\f\" : \" \\f \" , r \"\\v\" : \" \\v \" , r \"\\b\" : \" \\b \" , r \"\\0\" : \" \\0 \" , } class SearchKeysHandler ( StatusHandler , list ): \"\"\" This class handles status messages during key search. \"\"\" # Handle pub and uid (relating the latter to the former). # Don't care about the rest UID_INDEX = 1 FIELDS = \"type keyid algo length date expires\" . split () returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . curkey = None self . fingerprints = [] self . uids = [] def get_fields ( self , args : list [ str ]) -> dict [ str , str ]: \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" result = {} _set_fields ( result , self . FIELDS , args ) result [ \"uids\" ] = [] result [ \"sigs\" ] = [] return result def pub ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" self . curkey = curkey = self . get_fields ( args ) self . append ( curkey ) def uid ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" uid = args [ self . UID_INDEX ] uid = ESCAPE_PATTERN . sub ( lambda m : chr ( int ( m . group ( 1 ), 16 )), uid ) for k , v in BASIC_ESCAPES . items (): uid = uid . replace ( k , v ) self . curkey [ \"uids\" ] . append ( uid ) self . uids . append ( uid ) def handle_status ( self , key : str , value : str ) -> None : # pragma: no cover pass","title":"Module gnupg.handlers.search_keys_handler"},{"location":"reference/gnupg/handlers/search_keys_handler/#variables","text":"BASIC_ESCAPES ESCAPE_PATTERN TYPE_CHECKING","title":"Variables"},{"location":"reference/gnupg/handlers/search_keys_handler/#classes","text":"","title":"Classes"},{"location":"reference/gnupg/handlers/search_keys_handler/#searchkeyshandler","text":"class SearchKeysHandler ( gpg : 'GPG' ) This class handles status messages during key search. View Source class SearchKeysHandler ( StatusHandler , list ): \"\"\" This class handles status messages during key search. \"\"\" # Handle pub and uid ( relating the latter to the former ). # Don ' t care about the rest UID_INDEX = 1 FIELDS = \"type keyid algo length date expires\" . split () returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . curkey = None self . fingerprints = [] self . uids = [] def get_fields ( self , args : list [ str ]) -> dict [ str , str ]: \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" result = {} _set_fields ( result , self . FIELDS , args ) result [ \"uids\" ] = [] result [ \"sigs\" ] = [] return result def pub ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" self . curkey = curkey = self . get_fields ( args ) self . append ( curkey ) def uid ( self , args : list [ str ]) -> None : \"\"\" Internal method used to update the instance from a `gpg` status message. \"\"\" uid = args [ self . UID_INDEX ] uid = ESCAPE_PATTERN . sub ( lambda m : chr ( int ( m . group ( 1 ), 16 )), uid ) for k , v in BASIC_ESCAPES . items (): uid = uid . replace ( k , v ) self . curkey [ \"uids\" ]. append ( uid ) self . uids . append ( uid ) def handle_status ( self , key : str , value : str ) -> None : # pragma : no cover pass","title":"SearchKeysHandler"},{"location":"reference/gnupg/handlers/search_keys_handler/#ancestors-in-mro","text":"gnupg.handlers.status_handler.StatusHandler builtins.list","title":"Ancestors (in MRO)"},{"location":"reference/gnupg/handlers/search_keys_handler/#descendants","text":"gnupg.handlers.list_keys_handler.ListKeysHandler","title":"Descendants"},{"location":"reference/gnupg/handlers/search_keys_handler/#class-variables","text":"FIELDS UID_INDEX returncode","title":"Class variables"},{"location":"reference/gnupg/handlers/search_keys_handler/#methods","text":"","title":"Methods"},{"location":"reference/gnupg/handlers/search_keys_handler/#append","text":"def append ( self , object , / ) Append object to the end of the list.","title":"append"},{"location":"reference/gnupg/handlers/search_keys_handler/#clear","text":"def clear ( self , / ) Remove all items from list.","title":"clear"},{"location":"reference/gnupg/handlers/search_keys_handler/#copy","text":"def copy ( self , / ) Return a shallow copy of the list.","title":"copy"},{"location":"reference/gnupg/handlers/search_keys_handler/#count","text":"def count ( self , value , / ) Return number of occurrences of value.","title":"count"},{"location":"reference/gnupg/handlers/search_keys_handler/#extend","text":"def extend ( self , iterable , / ) Extend list by appending elements from the iterable.","title":"extend"},{"location":"reference/gnupg/handlers/search_keys_handler/#get_fields","text":"def get_fields ( self , args : 'list[str]' ) -> 'dict[str, str]' Internal method used to update the instance from a gpg status message. View Source def get_fields ( self , args : list [ str ] ) -> dict [ str , str ] : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" result = {} _set_fields ( result , self . FIELDS , args ) result [ \"uids\" ] = [] result [ \"sigs\" ] = [] return result","title":"get_fields"},{"location":"reference/gnupg/handlers/search_keys_handler/#handle_status","text":"def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : # pragma : no cover pass","title":"handle_status"},{"location":"reference/gnupg/handlers/search_keys_handler/#index","text":"def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present.","title":"index"},{"location":"reference/gnupg/handlers/search_keys_handler/#insert","text":"def insert ( self , index , object , / ) Insert object before index.","title":"insert"},{"location":"reference/gnupg/handlers/search_keys_handler/#pop","text":"def pop ( self , index =- 1 , / ) Remove and return item at index (default last). Raises IndexError if list is empty or index is out of range.","title":"pop"},{"location":"reference/gnupg/handlers/search_keys_handler/#pub","text":"def pub ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def pub ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" self . curkey = curkey = self . get_fields ( args ) self . append ( curkey )","title":"pub"},{"location":"reference/gnupg/handlers/search_keys_handler/#remove","text":"def remove ( self , value , / ) Remove first occurrence of value. Raises ValueError if the value is not present.","title":"remove"},{"location":"reference/gnupg/handlers/search_keys_handler/#reverse","text":"def reverse ( self , / ) Reverse IN PLACE .","title":"reverse"},{"location":"reference/gnupg/handlers/search_keys_handler/#sort","text":"def sort ( self , / , * , key = None , reverse = False ) Sort the list in ascending order and return None. The sort is in-place (i.e. the list itself is modified) and stable (i.e. the order of two equal elements is maintained). If a key function is given, apply it once to each list item and sort them, ascending or descending, according to their function values. The reverse flag can be set to sort in descending order.","title":"sort"},{"location":"reference/gnupg/handlers/search_keys_handler/#uid","text":"def uid ( self , args : 'list[str]' ) -> 'None' Internal method used to update the instance from a gpg status message. View Source def uid ( self , args : list [ str ] ) -> None : \" \"\" Internal method used to update the instance from a `gpg` status message. \"\" \" uid = args [ self . UID_INDEX ] uid = ESCAPE_PATTERN . sub ( lambda m : chr ( int ( m . group ( 1 ), 16 )), uid ) for k , v in BASIC_ESCAPES . items () : uid = uid . replace ( k , v ) self . curkey [ \"uids\" ] . append ( uid ) self . uids . append ( uid )","title":"uid"},{"location":"reference/gnupg/handlers/send_result_handler/","text":"Module gnupg.handlers.send_result_handler View Source from __future__ import annotations from gnupg.helper import _get_logger from .status_handler import StatusHandler logger = _get_logger ( __name__ ) class SendResultHandler ( StatusHandler ): \"\"\" This class handles status messages during key sending. \"\"\" returncode = None def handle_status ( self , key : str , value : str ) -> None : logger . debug ( \"SendResult: %s : %s \" , key , value ) Variables logger Classes SendResultHandler class SendResultHandler ( gpg : 'GPG' ) This class handles status messages during key sending. View Source class SendResultHandler ( StatusHandler ): \"\"\" This class handles status messages during key sending. \"\"\" returncode = None def handle_status ( self , key: str , value: str ) -> None: logger . debug ( \"SendResult: %s: %s\" , key , value ) Ancestors (in MRO) gnupg.handlers.status_handler.StatusHandler Class variables returncode Methods handle_status def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : logger . debug ( \"SendResult: %s: %s\" , key , value )","title":"Send Result Handler"},{"location":"reference/gnupg/handlers/send_result_handler/#module-gnupghandlerssend_result_handler","text":"View Source from __future__ import annotations from gnupg.helper import _get_logger from .status_handler import StatusHandler logger = _get_logger ( __name__ ) class SendResultHandler ( StatusHandler ): \"\"\" This class handles status messages during key sending. \"\"\" returncode = None def handle_status ( self , key : str , value : str ) -> None : logger . debug ( \"SendResult: %s : %s \" , key , value )","title":"Module gnupg.handlers.send_result_handler"},{"location":"reference/gnupg/handlers/send_result_handler/#variables","text":"logger","title":"Variables"},{"location":"reference/gnupg/handlers/send_result_handler/#classes","text":"","title":"Classes"},{"location":"reference/gnupg/handlers/send_result_handler/#sendresulthandler","text":"class SendResultHandler ( gpg : 'GPG' ) This class handles status messages during key sending. View Source class SendResultHandler ( StatusHandler ): \"\"\" This class handles status messages during key sending. \"\"\" returncode = None def handle_status ( self , key: str , value: str ) -> None: logger . debug ( \"SendResult: %s: %s\" , key , value )","title":"SendResultHandler"},{"location":"reference/gnupg/handlers/send_result_handler/#ancestors-in-mro","text":"gnupg.handlers.status_handler.StatusHandler","title":"Ancestors (in MRO)"},{"location":"reference/gnupg/handlers/send_result_handler/#class-variables","text":"returncode","title":"Class variables"},{"location":"reference/gnupg/handlers/send_result_handler/#methods","text":"","title":"Methods"},{"location":"reference/gnupg/handlers/send_result_handler/#handle_status","text":"def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : logger . debug ( \"SendResult: %s: %s\" , key , value )","title":"handle_status"},{"location":"reference/gnupg/handlers/sign_handler/","text":"Module gnupg.handlers.sign_handler View Source from __future__ import annotations from typing import TYPE_CHECKING from gnupg.helper import _get_logger from .helper import _determine_invalid_recipient_or_signer from .status_handler import StatusHandler from .text_handler import TextHandler if TYPE_CHECKING : from gnupg.gnupg import GPG logger = _get_logger ( __name__ ) class SignHandler ( StatusHandler , TextHandler ): \"\"\" This class handles status messages during signing. \"\"\" returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . type = None self . hash_algo = None self . fingerprint = None self . status = None self . status_detail = None self . key_id = None self . username = None def __nonzero__ ( self ) -> bool : return self . fingerprint is not None __bool__ = __nonzero__ def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" , \"FAILURE\" ): # pragma: no cover logger . warning ( \"potential problem: %s : %s \" , key , value ) elif key in ( \"KEYEXPIRED\" , \"SIGEXPIRED\" ): # pragma: no cover self . status = \"key expired\" elif key == \"KEYREVOKED\" : # pragma: no cover self . status = \"key revoked\" elif key == \"SIG_CREATED\" : ( self . type , algo , self . hash_algo , cls , self . timestamp , self . fingerprint ) = value . split () self . status = \"signature created\" elif key == \"USERID_HINT\" : # pragma: no cover self . key_id , self . username = value . split ( \" \" , 1 ) elif key == \"BAD_PASSPHRASE\" : # pragma: no cover self . status = \"bad passphrase\" elif key in ( \"INV_SGNR\" , \"INV_RECP\" ): # pragma: no cover # INV_RECP is returned in older versions if not self . status : self . status = \"invalid signer\" else : self . status = f \"invalid signer: { self . status } \" self . status_detail = _determine_invalid_recipient_or_signer ( value ) elif key in ( \"NEED_PASSPHRASE\" , \"GOOD_PASSPHRASE\" , \"BEGIN_SIGNING\" ): pass else : # pragma: no cover logger . debug ( \"message ignored: %s , %s \" , key , value ) Variables TYPE_CHECKING logger Classes SignHandler class SignHandler ( gpg : 'GPG' ) This class handles status messages during signing. View Source class SignHandler ( StatusHandler , TextHandler ): \"\"\" This class handles status messages during signing. \"\"\" returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . type = None self . hash_algo = None self . fingerprint = None self . status = None self . status_detail = None self . key_id = None self . username = None def __nonzero__ ( self ) -> bool : return self . fingerprint is not None __bool__ = __nonzero__ def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" , \"FAILURE\" ): # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key in ( \"KEYEXPIRED\" , \"SIGEXPIRED\" ): # pragma : no cover self . status = \"key expired\" elif key == \"KEYREVOKED\" : # pragma : no cover self . status = \"key revoked\" elif key == \"SIG_CREATED\" : ( self . type , algo , self . hash_algo , cls , self . timestamp , self . fingerprint ) = value . split () self . status = \"signature created\" elif key == \"USERID_HINT\" : # pragma : no cover self . key_id , self . username = value . split ( \" \" , 1 ) elif key == \"BAD_PASSPHRASE\" : # pragma : no cover self . status = \"bad passphrase\" elif key in ( \"INV_SGNR\" , \"INV_RECP\" ): # pragma : no cover # INV_RECP is returned in older versions if not self . status : self . status = \"invalid signer\" else : self . status = f \"invalid signer: {self.status}\" self . status_detail = _determine_invalid_recipient_or_signer ( value ) elif key in ( \"NEED_PASSPHRASE\" , \"GOOD_PASSPHRASE\" , \"BEGIN_SIGNING\" ): pass else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value ) Ancestors (in MRO) gnupg.handlers.status_handler.StatusHandler gnupg.handlers.text_handler.TextHandler Class variables returncode Methods handle_status def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" , \"FAILURE\" ): # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key in ( \"KEYEXPIRED\" , \"SIGEXPIRED\" ): # pragma : no cover self . status = \"key expired\" elif key == \"KEYREVOKED\" : # pragma : no cover self . status = \"key revoked\" elif key == \"SIG_CREATED\" : ( self . type , algo , self . hash_algo , cls , self . timestamp , self . fingerprint ) = value . split () self . status = \"signature created\" elif key == \"USERID_HINT\" : # pragma : no cover self . key_id , self . username = value . split ( \" \" , 1 ) elif key == \"BAD_PASSPHRASE\" : # pragma : no cover self . status = \"bad passphrase\" elif key in ( \"INV_SGNR\" , \"INV_RECP\" ): # pragma : no cover # INV_RECP is returned in older versions if not self . status : self . status = \"invalid signer\" else : self . status = f \"invalid signer: {self.status}\" self . status_detail = _determine_invalid_recipient_or_signer ( value ) elif key in ( \"NEED_PASSPHRASE\" , \"GOOD_PASSPHRASE\" , \"BEGIN_SIGNING\" ): pass else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value )","title":"Sign Handler"},{"location":"reference/gnupg/handlers/sign_handler/#module-gnupghandlerssign_handler","text":"View Source from __future__ import annotations from typing import TYPE_CHECKING from gnupg.helper import _get_logger from .helper import _determine_invalid_recipient_or_signer from .status_handler import StatusHandler from .text_handler import TextHandler if TYPE_CHECKING : from gnupg.gnupg import GPG logger = _get_logger ( __name__ ) class SignHandler ( StatusHandler , TextHandler ): \"\"\" This class handles status messages during signing. \"\"\" returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . type = None self . hash_algo = None self . fingerprint = None self . status = None self . status_detail = None self . key_id = None self . username = None def __nonzero__ ( self ) -> bool : return self . fingerprint is not None __bool__ = __nonzero__ def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" , \"FAILURE\" ): # pragma: no cover logger . warning ( \"potential problem: %s : %s \" , key , value ) elif key in ( \"KEYEXPIRED\" , \"SIGEXPIRED\" ): # pragma: no cover self . status = \"key expired\" elif key == \"KEYREVOKED\" : # pragma: no cover self . status = \"key revoked\" elif key == \"SIG_CREATED\" : ( self . type , algo , self . hash_algo , cls , self . timestamp , self . fingerprint ) = value . split () self . status = \"signature created\" elif key == \"USERID_HINT\" : # pragma: no cover self . key_id , self . username = value . split ( \" \" , 1 ) elif key == \"BAD_PASSPHRASE\" : # pragma: no cover self . status = \"bad passphrase\" elif key in ( \"INV_SGNR\" , \"INV_RECP\" ): # pragma: no cover # INV_RECP is returned in older versions if not self . status : self . status = \"invalid signer\" else : self . status = f \"invalid signer: { self . status } \" self . status_detail = _determine_invalid_recipient_or_signer ( value ) elif key in ( \"NEED_PASSPHRASE\" , \"GOOD_PASSPHRASE\" , \"BEGIN_SIGNING\" ): pass else : # pragma: no cover logger . debug ( \"message ignored: %s , %s \" , key , value )","title":"Module gnupg.handlers.sign_handler"},{"location":"reference/gnupg/handlers/sign_handler/#variables","text":"TYPE_CHECKING logger","title":"Variables"},{"location":"reference/gnupg/handlers/sign_handler/#classes","text":"","title":"Classes"},{"location":"reference/gnupg/handlers/sign_handler/#signhandler","text":"class SignHandler ( gpg : 'GPG' ) This class handles status messages during signing. View Source class SignHandler ( StatusHandler , TextHandler ): \"\"\" This class handles status messages during signing. \"\"\" returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . type = None self . hash_algo = None self . fingerprint = None self . status = None self . status_detail = None self . key_id = None self . username = None def __nonzero__ ( self ) -> bool : return self . fingerprint is not None __bool__ = __nonzero__ def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" , \"FAILURE\" ): # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key in ( \"KEYEXPIRED\" , \"SIGEXPIRED\" ): # pragma : no cover self . status = \"key expired\" elif key == \"KEYREVOKED\" : # pragma : no cover self . status = \"key revoked\" elif key == \"SIG_CREATED\" : ( self . type , algo , self . hash_algo , cls , self . timestamp , self . fingerprint ) = value . split () self . status = \"signature created\" elif key == \"USERID_HINT\" : # pragma : no cover self . key_id , self . username = value . split ( \" \" , 1 ) elif key == \"BAD_PASSPHRASE\" : # pragma : no cover self . status = \"bad passphrase\" elif key in ( \"INV_SGNR\" , \"INV_RECP\" ): # pragma : no cover # INV_RECP is returned in older versions if not self . status : self . status = \"invalid signer\" else : self . status = f \"invalid signer: {self.status}\" self . status_detail = _determine_invalid_recipient_or_signer ( value ) elif key in ( \"NEED_PASSPHRASE\" , \"GOOD_PASSPHRASE\" , \"BEGIN_SIGNING\" ): pass else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value )","title":"SignHandler"},{"location":"reference/gnupg/handlers/sign_handler/#ancestors-in-mro","text":"gnupg.handlers.status_handler.StatusHandler gnupg.handlers.text_handler.TextHandler","title":"Ancestors (in MRO)"},{"location":"reference/gnupg/handlers/sign_handler/#class-variables","text":"returncode","title":"Class variables"},{"location":"reference/gnupg/handlers/sign_handler/#methods","text":"","title":"Methods"},{"location":"reference/gnupg/handlers/sign_handler/#handle_status","text":"def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : if key in ( \"WARNING\" , \"ERROR\" , \"FAILURE\" ): # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key in ( \"KEYEXPIRED\" , \"SIGEXPIRED\" ): # pragma : no cover self . status = \"key expired\" elif key == \"KEYREVOKED\" : # pragma : no cover self . status = \"key revoked\" elif key == \"SIG_CREATED\" : ( self . type , algo , self . hash_algo , cls , self . timestamp , self . fingerprint ) = value . split () self . status = \"signature created\" elif key == \"USERID_HINT\" : # pragma : no cover self . key_id , self . username = value . split ( \" \" , 1 ) elif key == \"BAD_PASSPHRASE\" : # pragma : no cover self . status = \"bad passphrase\" elif key in ( \"INV_SGNR\" , \"INV_RECP\" ): # pragma : no cover # INV_RECP is returned in older versions if not self . status : self . status = \"invalid signer\" else : self . status = f \"invalid signer: {self.status}\" self . status_detail = _determine_invalid_recipient_or_signer ( value ) elif key in ( \"NEED_PASSPHRASE\" , \"GOOD_PASSPHRASE\" , \"BEGIN_SIGNING\" ): pass else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value )","title":"handle_status"},{"location":"reference/gnupg/handlers/status_handler/","text":"Module gnupg.handlers.status_handler View Source from __future__ import annotations from typing import TYPE_CHECKING , NoReturn if TYPE_CHECKING : from gnupg.gnupg import GPG class StatusHandler : \"\"\" The base class for handling status messages from `gpg`. \"\"\" def __init__ ( self , gpg : GPG ) -> None : \"\"\" Initialize an instance. Args: gpg (GPG): The :class:`GPG` instance in use. \"\"\" self . gpg = gpg self . data : str | None = None def handle_status ( self , key : str , value : str ) -> NoReturn : \"\"\" Handle status messages from the `gpg` child process. These are lines of the format [GNUPG:] <key> <value> Args: key (str): Identifies what the status message is. value (str): Identifies additional data, which differs depending on the key. \"\"\" raise NotImplementedError Variables TYPE_CHECKING Classes StatusHandler class StatusHandler ( gpg : 'GPG' ) The base class for handling status messages from gpg . View Source class StatusHandler : \" \"\" The base class for handling status messages from `gpg`. \"\" \" def __init__ ( self , gpg : GPG ) -> None : \" \"\" Initialize an instance. Args: gpg (GPG): The :class:`GPG` instance in use. \"\" \" self . gpg = gpg self . data : str | None = None def handle_status ( self , key : str , value : str ) -> NoReturn : \" \"\" Handle status messages from the `gpg` child process. These are lines of the format [GNUPG:] <key> <value> Args: key (str): Identifies what the status message is. value (str): Identifies additional data, which differs depending on the key. \"\" \" raise NotImplementedError Descendants gnupg.handlers.add_subkey_handler.AddSubkeyHandler gnupg.handlers.auto_locate_key_handler.AutoLocateKeyHandler gnupg.handlers.verify_handler.VerifyHandler gnupg.handlers.delete_result_handler.DeleteResultHandler gnupg.handlers.gen_key_handler.GenKeyHandler gnupg.handlers.import_result_handler.ImportResultHandler gnupg.handlers.search_keys_handler.SearchKeysHandler gnupg.handlers.send_result_handler.SendResultHandler gnupg.handlers.sign_handler.SignHandler Methods handle_status def handle_status ( self , key : 'str' , value : 'str' ) -> 'NoReturn' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> NoReturn : \" \"\" Handle status messages from the `gpg` child process. These are lines of the format [GNUPG:] <key> <value> Args: key (str): Identifies what the status message is. value (str): Identifies additional data, which differs depending on the key. \"\" \" raise NotImplementedError","title":"Status Handler"},{"location":"reference/gnupg/handlers/status_handler/#module-gnupghandlersstatus_handler","text":"View Source from __future__ import annotations from typing import TYPE_CHECKING , NoReturn if TYPE_CHECKING : from gnupg.gnupg import GPG class StatusHandler : \"\"\" The base class for handling status messages from `gpg`. \"\"\" def __init__ ( self , gpg : GPG ) -> None : \"\"\" Initialize an instance. Args: gpg (GPG): The :class:`GPG` instance in use. \"\"\" self . gpg = gpg self . data : str | None = None def handle_status ( self , key : str , value : str ) -> NoReturn : \"\"\" Handle status messages from the `gpg` child process. These are lines of the format [GNUPG:] <key> <value> Args: key (str): Identifies what the status message is. value (str): Identifies additional data, which differs depending on the key. \"\"\" raise NotImplementedError","title":"Module gnupg.handlers.status_handler"},{"location":"reference/gnupg/handlers/status_handler/#variables","text":"TYPE_CHECKING","title":"Variables"},{"location":"reference/gnupg/handlers/status_handler/#classes","text":"","title":"Classes"},{"location":"reference/gnupg/handlers/status_handler/#statushandler","text":"class StatusHandler ( gpg : 'GPG' ) The base class for handling status messages from gpg . View Source class StatusHandler : \" \"\" The base class for handling status messages from `gpg`. \"\" \" def __init__ ( self , gpg : GPG ) -> None : \" \"\" Initialize an instance. Args: gpg (GPG): The :class:`GPG` instance in use. \"\" \" self . gpg = gpg self . data : str | None = None def handle_status ( self , key : str , value : str ) -> NoReturn : \" \"\" Handle status messages from the `gpg` child process. These are lines of the format [GNUPG:] <key> <value> Args: key (str): Identifies what the status message is. value (str): Identifies additional data, which differs depending on the key. \"\" \" raise NotImplementedError","title":"StatusHandler"},{"location":"reference/gnupg/handlers/status_handler/#descendants","text":"gnupg.handlers.add_subkey_handler.AddSubkeyHandler gnupg.handlers.auto_locate_key_handler.AutoLocateKeyHandler gnupg.handlers.verify_handler.VerifyHandler gnupg.handlers.delete_result_handler.DeleteResultHandler gnupg.handlers.gen_key_handler.GenKeyHandler gnupg.handlers.import_result_handler.ImportResultHandler gnupg.handlers.search_keys_handler.SearchKeysHandler gnupg.handlers.send_result_handler.SendResultHandler gnupg.handlers.sign_handler.SignHandler","title":"Descendants"},{"location":"reference/gnupg/handlers/status_handler/#methods","text":"","title":"Methods"},{"location":"reference/gnupg/handlers/status_handler/#handle_status","text":"def handle_status ( self , key : 'str' , value : 'str' ) -> 'NoReturn' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> NoReturn : \" \"\" Handle status messages from the `gpg` child process. These are lines of the format [GNUPG:] <key> <value> Args: key (str): Identifies what the status message is. value (str): Identifies additional data, which differs depending on the key. \"\" \" raise NotImplementedError","title":"handle_status"},{"location":"reference/gnupg/handlers/text_handler/","text":"Module gnupg.handlers.text_handler View Source from __future__ import annotations class TextHandler : def _as_text ( self ) -> str : return self . data . decode ( self . gpg . encoding , self . gpg . decode_errors ) __str__ = _as_text Classes TextHandler class TextHandler ( / , * args , ** kwargs ) View Source class TextHandler: def _as_text ( self ) -> str: return self . data . decode ( self . gpg . encoding , self . gpg . decode_errors ) __str__ = _as_text Descendants gnupg.handlers.crypt_handler.CryptHandler gnupg.handlers.sign_handler.SignHandler","title":"Text Handler"},{"location":"reference/gnupg/handlers/text_handler/#module-gnupghandlerstext_handler","text":"View Source from __future__ import annotations class TextHandler : def _as_text ( self ) -> str : return self . data . decode ( self . gpg . encoding , self . gpg . decode_errors ) __str__ = _as_text","title":"Module gnupg.handlers.text_handler"},{"location":"reference/gnupg/handlers/text_handler/#classes","text":"","title":"Classes"},{"location":"reference/gnupg/handlers/text_handler/#texthandler","text":"class TextHandler ( / , * args , ** kwargs ) View Source class TextHandler: def _as_text ( self ) -> str: return self . data . decode ( self . gpg . encoding , self . gpg . decode_errors ) __str__ = _as_text","title":"TextHandler"},{"location":"reference/gnupg/handlers/text_handler/#descendants","text":"gnupg.handlers.crypt_handler.CryptHandler gnupg.handlers.sign_handler.SignHandler","title":"Descendants"},{"location":"reference/gnupg/handlers/trust_result_handler/","text":"Module gnupg.handlers.trust_result_handler View Source from __future__ import annotations from .delete_result_handler import DeleteResultHandler class TrustResultHandler ( DeleteResultHandler ): \"\"\" This class handles status messages during key trust setting. \"\"\" Classes TrustResultHandler class TrustResultHandler ( gpg : 'GPG' ) This class handles status messages during key trust setting. View Source class TrustResultHandler ( DeleteResultHandler ): \"\"\" This class handles status messages during key trust setting. \"\"\" Ancestors (in MRO) gnupg.handlers.delete_result_handler.DeleteResultHandler gnupg.handlers.status_handler.StatusHandler Class variables problem_reason returncode Methods handle_status def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : if key == \"DELETE_PROBLEM\" : # pragma : no cover self . status = self . problem_reason . get ( value , f \"Unknown error: {value!r}\" ) else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value )","title":"Trust Result Handler"},{"location":"reference/gnupg/handlers/trust_result_handler/#module-gnupghandlerstrust_result_handler","text":"View Source from __future__ import annotations from .delete_result_handler import DeleteResultHandler class TrustResultHandler ( DeleteResultHandler ): \"\"\" This class handles status messages during key trust setting. \"\"\"","title":"Module gnupg.handlers.trust_result_handler"},{"location":"reference/gnupg/handlers/trust_result_handler/#classes","text":"","title":"Classes"},{"location":"reference/gnupg/handlers/trust_result_handler/#trustresulthandler","text":"class TrustResultHandler ( gpg : 'GPG' ) This class handles status messages during key trust setting. View Source class TrustResultHandler ( DeleteResultHandler ): \"\"\" This class handles status messages during key trust setting. \"\"\"","title":"TrustResultHandler"},{"location":"reference/gnupg/handlers/trust_result_handler/#ancestors-in-mro","text":"gnupg.handlers.delete_result_handler.DeleteResultHandler gnupg.handlers.status_handler.StatusHandler","title":"Ancestors (in MRO)"},{"location":"reference/gnupg/handlers/trust_result_handler/#class-variables","text":"problem_reason returncode","title":"Class variables"},{"location":"reference/gnupg/handlers/trust_result_handler/#methods","text":"","title":"Methods"},{"location":"reference/gnupg/handlers/trust_result_handler/#handle_status","text":"def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : if key == \"DELETE_PROBLEM\" : # pragma : no cover self . status = self . problem_reason . get ( value , f \"Unknown error: {value!r}\" ) else : # pragma : no cover logger . debug ( \"message ignored: %s, %s\" , key , value )","title":"handle_status"},{"location":"reference/gnupg/handlers/verify_handler/","text":"Module gnupg.handlers.verify_handler View Source from __future__ import annotations from types import MappingProxyType from typing import TYPE_CHECKING from gnupg.helper import _get_logger from .status_handler import StatusHandler if TYPE_CHECKING : from gnupg.gnupg import GPG logger = _get_logger ( __name__ ) class VerifyHandler ( StatusHandler ): \"\"\" This class handles status messages during signature verificaton. \"\"\" TRUST_EXPIRED = 0 TRUST_UNDEFINED = 1 TRUST_NEVER = 2 TRUST_MARGINAL = 3 TRUST_FULLY = 4 TRUST_ULTIMATE = 5 TRUST_LEVELS = MappingProxyType ( { \"TRUST_EXPIRED\" : TRUST_EXPIRED , \"TRUST_UNDEFINED\" : TRUST_UNDEFINED , \"TRUST_NEVER\" : TRUST_NEVER , \"TRUST_MARGINAL\" : TRUST_MARGINAL , \"TRUST_FULLY\" : TRUST_FULLY , \"TRUST_ULTIMATE\" : TRUST_ULTIMATE , }, ) # for now, just the most common error codes. This can be expanded as and # when reports come in of other errors. GPG_SYSTEM_ERROR_CODES = MappingProxyType ( { 1 : \"permission denied\" , 35 : \"file exists\" , 81 : \"file not found\" , 97 : \"not a directory\" , }, ) GPG_ERROR_CODES = MappingProxyType ( { 11 : \"incorrect passphrase\" , }, ) returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . valid = False self . fingerprint = self . creation_date = self . timestamp = None self . signature_id = self . key_id = None self . username = None self . key_id = None self . key_status = None self . status = None self . pubkey_fingerprint = None self . expire_timestamp = None self . sig_timestamp = None self . trust_text = None self . trust_level = None self . sig_info = {} self . problems = [] def __nonzero__ ( self ) -> bool : # pragma: no cover return self . valid __bool__ = __nonzero__ def handle_status ( self , key : str , value : str ) -> None : def update_sig_info ( ** kwargs : object ) -> None : sig_id = self . signature_id if sig_id : info = self . sig_info [ sig_id ] info . update ( kwargs ) else : logger . debug ( \"Ignored due to missing sig iD: %s \" , kwargs ) if key in self . TRUST_LEVELS : self . trust_text = key self . trust_level = self . TRUST_LEVELS [ key ] update_sig_info ( trust_level = self . trust_level , trust_text = self . trust_text ) # See Issue #214. Once we see this, we're done with the signature just seen. # Zap the signature ID, because we don't see a SIG_ID unless we have a new # good signature. self . signature_id = None elif key in ( \"WARNING\" , \"ERROR\" ): # pragma: no cover logger . warning ( \"potential problem: %s : %s \" , key , value ) elif key == \"BADSIG\" : # pragma: no cover self . valid = False self . status = \"signature bad\" self . key_id , self . username = value . split ( None , 1 ) self . problems . append ({ \"status\" : self . status , \"keyid\" : self . key_id , \"user\" : self . username }) update_sig_info ( keyid = self . key_id , username = self . username , status = self . status ) elif key == \"ERRSIG\" : # pragma: no cover self . valid = False parts = value . split () ( self . key_id , algo , hash_algo , cls , self . timestamp ) = parts [: 5 ] # Since GnuPG 2.2.7, a fingerprint is tacked on if len ( parts ) >= 7 : # noqa: PLR2004 self . fingerprint = parts [ 6 ] self . status = \"signature error\" update_sig_info ( keyid = self . key_id , timestamp = self . timestamp , fingerprint = self . fingerprint , status = self . status , ) self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id , \"timestamp\" : self . timestamp , \"fingerprint\" : self . fingerprint , }, ) elif key == \"EXPSIG\" : # pragma: no cover self . valid = False self . status = \"signature expired\" self . key_id , self . username = value . split ( None , 1 ) update_sig_info ( keyid = self . key_id , username = self . username , status = self . status ) self . problems . append ({ \"status\" : self . status , \"keyid\" : self . key_id , \"user\" : self . username }) elif key == \"GOODSIG\" : self . valid = True self . status = \"signature good\" self . key_id , self . username = value . split ( None , 1 ) update_sig_info ( keyid = self . key_id , username = self . username , status = self . status ) elif key == \"VALIDSIG\" : parts = value . split () fingerprint , creation_date , sig_ts , expire_ts = parts [: 4 ] ( self . fingerprint , self . creation_date , self . sig_timestamp , self . expire_timestamp ) = ( fingerprint , creation_date , sig_ts , expire_ts , ) # may be different if signature is made with a subkey if len ( parts ) >= 10 : # noqa: PLR2004 self . pubkey_fingerprint = parts [ 9 ] self . status = \"signature valid\" update_sig_info ( fingerprint = fingerprint , creation_date = creation_date , timestamp = sig_ts , expiry = expire_ts , pubkey_fingerprint = self . pubkey_fingerprint , status = self . status , ) elif key == \"SIG_ID\" : sig_id , creation_date , timestamp = value . split () self . sig_info [ sig_id ] = { \"creation_date\" : creation_date , \"timestamp\" : timestamp } ( self . signature_id , self . creation_date , self . timestamp ) = ( sig_id , creation_date , timestamp ) elif key == \"NO_PUBKEY\" : # pragma: no cover self . valid = False self . key_id = value self . status = \"no public key\" self . problems . append ({ \"status\" : self . status , \"keyid\" : self . key_id }) elif key == \"NO_SECKEY\" : # pragma: no cover self . valid = False self . key_id = value self . status = \"no secret key\" self . problems . append ({ \"status\" : self . status , \"keyid\" : self . key_id }) elif key in ( \"EXPKEYSIG\" , \"REVKEYSIG\" ): # pragma: no cover # signed with expired or revoked key self . valid = False self . key_id = value . split ()[ 0 ] if key == \"EXPKEYSIG\" : self . key_status = \"signing key has expired\" else : self . key_status = \"signing key was revoked\" self . status = self . key_status update_sig_info ( status = self . status , keyid = self . key_id ) self . problems . append ({ \"status\" : self . status , \"keyid\" : self . key_id }) elif key in ( \"UNEXPECTED\" , \"FAILURE\" ): # pragma: no cover self . valid = False if key == \"UNEXPECTED\" : self . status = \"unexpected data\" else : # N.B. there might be other reasons. For example, if an output # file can't be created - /dev/null/foo will lead to a # \"not a directory\" error, but which is not sent as a status # message with the [GNUPG:] prefix. Similarly if you try to # write to \"/etc/foo\" as a non-root user, a \"permission denied\" # error will be sent as a non-status message. message = f \"error - { value } \" operation , code = value . rsplit ( \" \" , 1 ) if code . isdigit (): code = int ( code ) & 0xFFFFFF # lose the error source if self . gpg . error_map and code in self . gpg . error_map : message = f \" { operation } : { self . gpg . error_map [ code ] } \" else : system_error = bool ( code & 0x8000 ) code = code & 0x7FFF mapping = self . GPG_SYSTEM_ERROR_CODES if system_error else self . GPG_ERROR_CODES if code in mapping : message = f \" { operation } : { mapping [ code ] } \" if not self . status : self . status = message elif key == \"NODATA\" : # pragma: no cover # See issue GH-191 self . valid = False self . status = \"signature expected but not found\" elif key in ( \"DECRYPTION_INFO\" , \"PLAINTEXT\" , \"PLAINTEXT_LENGTH\" , \"BEGIN_SIGNING\" , \"KEY_CONSIDERED\" ): pass elif key in ( \"NEWSIG\" ,): # Only sent in gpg2. Clear any signature ID, to be set by a following SIG_ID self . signature_id = None else : # pragma: no cover logger . debug ( \"message ignored: %r , %r \" , key , value ) Variables TYPE_CHECKING logger Classes VerifyHandler class VerifyHandler ( gpg : 'GPG' ) This class handles status messages during signature verificaton. View Source class VerifyHandler ( StatusHandler ) : \"\"\" This class handles status messages during signature verificaton. \"\"\" TRUST_EXPIRED = 0 TRUST_UNDEFINED = 1 TRUST_NEVER = 2 TRUST_MARGINAL = 3 TRUST_FULLY = 4 TRUST_ULTIMATE = 5 TRUST_LEVELS = MappingProxyType ( { \"TRUST_EXPIRED\" : TRUST_EXPIRED , \"TRUST_UNDEFINED\" : TRUST_UNDEFINED , \"TRUST_NEVER\" : TRUST_NEVER , \"TRUST_MARGINAL\" : TRUST_MARGINAL , \"TRUST_FULLY\" : TRUST_FULLY , \"TRUST_ULTIMATE\" : TRUST_ULTIMATE , } , ) # for now , just the most common error codes . This can be expanded as and # when reports come in of other errors . GPG_SYSTEM_ERROR_CODES = MappingProxyType ( { 1 : \"permission denied\" , 35 : \"file exists\" , 81 : \"file not found\" , 97 : \"not a directory\" , } , ) GPG_ERROR_CODES = MappingProxyType ( { 11 : \"incorrect passphrase\" , } , ) returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . valid = False self . fingerprint = self . creation_date = self . timestamp = None self . signature_id = self . key_id = None self . username = None self . key_id = None self . key_status = None self . status = None self . pubkey_fingerprint = None self . expire_timestamp = None self . sig_timestamp = None self . trust_text = None self . trust_level = None self . sig_info = {} self . problems = [] def __nonzero__ ( self ) -> bool : # pragma : no cover return self . valid __bool__ = __nonzero__ def handle_status ( self , key : str , value : str ) -> None : def update_sig_info ( ** kwargs : object ) -> None : sig_id = self . signature_id if sig_id : info = self . sig_info [ sig_id ] info . update ( kwargs ) else : logger . debug ( \"Ignored due to missing sig iD: %s\" , kwargs ) if key in self . TRUST_LEVELS : self . trust_text = key self . trust_level = self . TRUST_LEVELS [ key ] update_sig_info ( trust_level = self . trust_level , trust_text = self . trust_text ) # See Issue #214 . Once we see this , we 're done with the signature just seen. # Zap the signature ID, because we don' t see a SIG_ID unless we have a new # good signature . self . signature_id = None elif key in ( \"WARNING\" , \"ERROR\" ) : # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key == \"BADSIG\" : # pragma : no cover self . valid = False self . status = \"signature bad\" self . key_id , self . username = value . split ( None , 1 ) self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id , \"user\" : self . username } ) update_sig_info ( keyid = self . key_id , username = self . username , status = self . status ) elif key == \"ERRSIG\" : # pragma : no cover self . valid = False parts = value . split () ( self . key_id , algo , hash_algo , cls , self . timestamp ) = parts [ :5 ] # Since GnuPG 2.2.7 , a fingerprint is tacked on if len ( parts ) >= 7 : # noqa : PLR2004 self . fingerprint = parts [ 6 ] self . status = \"signature error\" update_sig_info ( keyid = self . key_id , timestamp = self . timestamp , fingerprint = self . fingerprint , status = self . status , ) self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id , \"timestamp\" : self . timestamp , \"fingerprint\" : self . fingerprint , } , ) elif key == \"EXPSIG\" : # pragma : no cover self . valid = False self . status = \"signature expired\" self . key_id , self . username = value . split ( None , 1 ) update_sig_info ( keyid = self . key_id , username = self . username , status = self . status ) self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id , \"user\" : self . username } ) elif key == \"GOODSIG\" : self . valid = True self . status = \"signature good\" self . key_id , self . username = value . split ( None , 1 ) update_sig_info ( keyid = self . key_id , username = self . username , status = self . status ) elif key == \"VALIDSIG\" : parts = value . split () fingerprint , creation_date , sig_ts , expire_ts = parts [ :4 ] ( self . fingerprint , self . creation_date , self . sig_timestamp , self . expire_timestamp ) = ( fingerprint , creation_date , sig_ts , expire_ts , ) # may be different if signature is made with a subkey if len ( parts ) >= 10 : # noqa : PLR2004 self . pubkey_fingerprint = parts [ 9 ] self . status = \"signature valid\" update_sig_info ( fingerprint = fingerprint , creation_date = creation_date , timestamp = sig_ts , expiry = expire_ts , pubkey_fingerprint = self . pubkey_fingerprint , status = self . status , ) elif key == \"SIG_ID\" : sig_id , creation_date , timestamp = value . split () self . sig_info [ sig_id ] = { \"creation_date\" : creation_date , \"timestamp\" : timestamp } ( self . signature_id , self . creation_date , self . timestamp ) = ( sig_id , creation_date , timestamp ) elif key == \"NO_PUBKEY\" : # pragma : no cover self . valid = False self . key_id = value self . status = \"no public key\" self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id } ) elif key == \"NO_SECKEY\" : # pragma : no cover self . valid = False self . key_id = value self . status = \"no secret key\" self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id } ) elif key in ( \"EXPKEYSIG\" , \"REVKEYSIG\" ) : # pragma : no cover # signed with expired or revoked key self . valid = False self . key_id = value . split () [ 0 ] if key == \"EXPKEYSIG\" : self . key_status = \"signing key has expired\" else : self . key_status = \"signing key was revoked\" self . status = self . key_status update_sig_info ( status = self . status , keyid = self . key_id ) self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id } ) elif key in ( \"UNEXPECTED\" , \"FAILURE\" ) : # pragma : no cover self . valid = False if key == \"UNEXPECTED\" : self . status = \"unexpected data\" else : # N . B . there might be other reasons . For example , if an output # file can ' t be created - / dev / null / foo will lead to a # \"not a directory\" error , but which is not sent as a status # message with the [ GNUPG: ] prefix . Similarly if you try to # write to \"/etc/foo\" as a non - root user , a \"permission denied\" # error will be sent as a non - status message . message = f \"error - {value}\" operation , code = value . rsplit ( \" \" , 1 ) if code . isdigit () : code = int ( code ) & 0xFFFFFF # lose the error source if self . gpg . error_map and code in self . gpg . error_map : message = f \"{operation}: {self.gpg.error_map[code]}\" else : system_error = bool ( code & 0x8000 ) code = code & 0x7FFF mapping = self . GPG_SYSTEM_ERROR_CODES if system_error else self . GPG_ERROR_CODES if code in mapping : message = f \"{operation}: {mapping[code]}\" if not self . status : self . status = message elif key == \"NODATA\" : # pragma : no cover # See issue GH - 191 self . valid = False self . status = \"signature expected but not found\" elif key in ( \"DECRYPTION_INFO\" , \"PLAINTEXT\" , \"PLAINTEXT_LENGTH\" , \"BEGIN_SIGNING\" , \"KEY_CONSIDERED\" ) : pass elif key in ( \"NEWSIG\" ,) : # Only sent in gpg2 . Clear any signature ID , to be set by a following SIG_ID self . signature_id = None else : # pragma : no cover logger . debug ( \"message ignored: %r, %r\" , key , value ) Ancestors (in MRO) gnupg.handlers.status_handler.StatusHandler Descendants gnupg.handlers.crypt_handler.CryptHandler Class variables GPG_ERROR_CODES GPG_SYSTEM_ERROR_CODES TRUST_EXPIRED TRUST_FULLY TRUST_LEVELS TRUST_MARGINAL TRUST_NEVER TRUST_ULTIMATE TRUST_UNDEFINED returncode Methods handle_status def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : def update_sig_info ( ** kwargs : object ) -> None : sig_id = self . signature_id if sig_id : info = self . sig_info [ sig_id ] info . update ( kwargs ) else : logger . debug ( \"Ignored due to missing sig iD: %s\" , kwargs ) if key in self . TRUST_LEVELS : self . trust_text = key self . trust_level = self . TRUST_LEVELS [ key ] update_sig_info ( trust_level = self . trust_level , trust_text = self . trust_text ) # See Issue #214 . Once we see this , we 're done with the signature just seen. # Zap the signature ID, because we don' t see a SIG_ID unless we have a new # good signature . self . signature_id = None elif key in ( \"WARNING\" , \"ERROR\" ) : # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key == \"BADSIG\" : # pragma : no cover self . valid = False self . status = \"signature bad\" self . key_id , self . username = value . split ( None , 1 ) self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id , \"user\" : self . username } ) update_sig_info ( keyid = self . key_id , username = self . username , status = self . status ) elif key == \"ERRSIG\" : # pragma : no cover self . valid = False parts = value . split () ( self . key_id , algo , hash_algo , cls , self . timestamp ) = parts [ :5 ] # Since GnuPG 2.2.7 , a fingerprint is tacked on if len ( parts ) >= 7 : # noqa : PLR2004 self . fingerprint = parts [ 6 ] self . status = \"signature error\" update_sig_info ( keyid = self . key_id , timestamp = self . timestamp , fingerprint = self . fingerprint , status = self . status , ) self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id , \"timestamp\" : self . timestamp , \"fingerprint\" : self . fingerprint , } , ) elif key == \"EXPSIG\" : # pragma : no cover self . valid = False self . status = \"signature expired\" self . key_id , self . username = value . split ( None , 1 ) update_sig_info ( keyid = self . key_id , username = self . username , status = self . status ) self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id , \"user\" : self . username } ) elif key == \"GOODSIG\" : self . valid = True self . status = \"signature good\" self . key_id , self . username = value . split ( None , 1 ) update_sig_info ( keyid = self . key_id , username = self . username , status = self . status ) elif key == \"VALIDSIG\" : parts = value . split () fingerprint , creation_date , sig_ts , expire_ts = parts [ :4 ] ( self . fingerprint , self . creation_date , self . sig_timestamp , self . expire_timestamp ) = ( fingerprint , creation_date , sig_ts , expire_ts , ) # may be different if signature is made with a subkey if len ( parts ) >= 10 : # noqa : PLR2004 self . pubkey_fingerprint = parts [ 9 ] self . status = \"signature valid\" update_sig_info ( fingerprint = fingerprint , creation_date = creation_date , timestamp = sig_ts , expiry = expire_ts , pubkey_fingerprint = self . pubkey_fingerprint , status = self . status , ) elif key == \"SIG_ID\" : sig_id , creation_date , timestamp = value . split () self . sig_info [ sig_id ] = { \"creation_date\" : creation_date , \"timestamp\" : timestamp } ( self . signature_id , self . creation_date , self . timestamp ) = ( sig_id , creation_date , timestamp ) elif key == \"NO_PUBKEY\" : # pragma : no cover self . valid = False self . key_id = value self . status = \"no public key\" self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id } ) elif key == \"NO_SECKEY\" : # pragma : no cover self . valid = False self . key_id = value self . status = \"no secret key\" self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id } ) elif key in ( \"EXPKEYSIG\" , \"REVKEYSIG\" ) : # pragma : no cover # signed with expired or revoked key self . valid = False self . key_id = value . split () [ 0 ] if key == \"EXPKEYSIG\" : self . key_status = \"signing key has expired\" else : self . key_status = \"signing key was revoked\" self . status = self . key_status update_sig_info ( status = self . status , keyid = self . key_id ) self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id } ) elif key in ( \"UNEXPECTED\" , \"FAILURE\" ) : # pragma : no cover self . valid = False if key == \"UNEXPECTED\" : self . status = \"unexpected data\" else : # N . B . there might be other reasons . For example , if an output # file can ' t be created - / dev / null / foo will lead to a # \"not a directory\" error , but which is not sent as a status # message with the [ GNUPG: ] prefix . Similarly if you try to # write to \"/etc/foo\" as a non - root user , a \"permission denied\" # error will be sent as a non - status message . message = f \"error - {value}\" operation , code = value . rsplit ( \" \" , 1 ) if code . isdigit () : code = int ( code ) & 0xFFFFFF # lose the error source if self . gpg . error_map and code in self . gpg . error_map : message = f \"{operation}: {self.gpg.error_map[code]}\" else : system_error = bool ( code & 0x8000 ) code = code & 0x7FFF mapping = self . GPG_SYSTEM_ERROR_CODES if system_error else self . GPG_ERROR_CODES if code in mapping : message = f \"{operation}: {mapping[code]}\" if not self . status : self . status = message elif key == \"NODATA\" : # pragma : no cover # See issue GH - 191 self . valid = False self . status = \"signature expected but not found\" elif key in ( \"DECRYPTION_INFO\" , \"PLAINTEXT\" , \"PLAINTEXT_LENGTH\" , \"BEGIN_SIGNING\" , \"KEY_CONSIDERED\" ) : pass elif key in ( \"NEWSIG\" ,) : # Only sent in gpg2 . Clear any signature ID , to be set by a following SIG_ID self . signature_id = None else : # pragma : no cover logger . debug ( \"message ignored: %r, %r\" , key , value )","title":"Verify Handler"},{"location":"reference/gnupg/handlers/verify_handler/#module-gnupghandlersverify_handler","text":"View Source from __future__ import annotations from types import MappingProxyType from typing import TYPE_CHECKING from gnupg.helper import _get_logger from .status_handler import StatusHandler if TYPE_CHECKING : from gnupg.gnupg import GPG logger = _get_logger ( __name__ ) class VerifyHandler ( StatusHandler ): \"\"\" This class handles status messages during signature verificaton. \"\"\" TRUST_EXPIRED = 0 TRUST_UNDEFINED = 1 TRUST_NEVER = 2 TRUST_MARGINAL = 3 TRUST_FULLY = 4 TRUST_ULTIMATE = 5 TRUST_LEVELS = MappingProxyType ( { \"TRUST_EXPIRED\" : TRUST_EXPIRED , \"TRUST_UNDEFINED\" : TRUST_UNDEFINED , \"TRUST_NEVER\" : TRUST_NEVER , \"TRUST_MARGINAL\" : TRUST_MARGINAL , \"TRUST_FULLY\" : TRUST_FULLY , \"TRUST_ULTIMATE\" : TRUST_ULTIMATE , }, ) # for now, just the most common error codes. This can be expanded as and # when reports come in of other errors. GPG_SYSTEM_ERROR_CODES = MappingProxyType ( { 1 : \"permission denied\" , 35 : \"file exists\" , 81 : \"file not found\" , 97 : \"not a directory\" , }, ) GPG_ERROR_CODES = MappingProxyType ( { 11 : \"incorrect passphrase\" , }, ) returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . valid = False self . fingerprint = self . creation_date = self . timestamp = None self . signature_id = self . key_id = None self . username = None self . key_id = None self . key_status = None self . status = None self . pubkey_fingerprint = None self . expire_timestamp = None self . sig_timestamp = None self . trust_text = None self . trust_level = None self . sig_info = {} self . problems = [] def __nonzero__ ( self ) -> bool : # pragma: no cover return self . valid __bool__ = __nonzero__ def handle_status ( self , key : str , value : str ) -> None : def update_sig_info ( ** kwargs : object ) -> None : sig_id = self . signature_id if sig_id : info = self . sig_info [ sig_id ] info . update ( kwargs ) else : logger . debug ( \"Ignored due to missing sig iD: %s \" , kwargs ) if key in self . TRUST_LEVELS : self . trust_text = key self . trust_level = self . TRUST_LEVELS [ key ] update_sig_info ( trust_level = self . trust_level , trust_text = self . trust_text ) # See Issue #214. Once we see this, we're done with the signature just seen. # Zap the signature ID, because we don't see a SIG_ID unless we have a new # good signature. self . signature_id = None elif key in ( \"WARNING\" , \"ERROR\" ): # pragma: no cover logger . warning ( \"potential problem: %s : %s \" , key , value ) elif key == \"BADSIG\" : # pragma: no cover self . valid = False self . status = \"signature bad\" self . key_id , self . username = value . split ( None , 1 ) self . problems . append ({ \"status\" : self . status , \"keyid\" : self . key_id , \"user\" : self . username }) update_sig_info ( keyid = self . key_id , username = self . username , status = self . status ) elif key == \"ERRSIG\" : # pragma: no cover self . valid = False parts = value . split () ( self . key_id , algo , hash_algo , cls , self . timestamp ) = parts [: 5 ] # Since GnuPG 2.2.7, a fingerprint is tacked on if len ( parts ) >= 7 : # noqa: PLR2004 self . fingerprint = parts [ 6 ] self . status = \"signature error\" update_sig_info ( keyid = self . key_id , timestamp = self . timestamp , fingerprint = self . fingerprint , status = self . status , ) self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id , \"timestamp\" : self . timestamp , \"fingerprint\" : self . fingerprint , }, ) elif key == \"EXPSIG\" : # pragma: no cover self . valid = False self . status = \"signature expired\" self . key_id , self . username = value . split ( None , 1 ) update_sig_info ( keyid = self . key_id , username = self . username , status = self . status ) self . problems . append ({ \"status\" : self . status , \"keyid\" : self . key_id , \"user\" : self . username }) elif key == \"GOODSIG\" : self . valid = True self . status = \"signature good\" self . key_id , self . username = value . split ( None , 1 ) update_sig_info ( keyid = self . key_id , username = self . username , status = self . status ) elif key == \"VALIDSIG\" : parts = value . split () fingerprint , creation_date , sig_ts , expire_ts = parts [: 4 ] ( self . fingerprint , self . creation_date , self . sig_timestamp , self . expire_timestamp ) = ( fingerprint , creation_date , sig_ts , expire_ts , ) # may be different if signature is made with a subkey if len ( parts ) >= 10 : # noqa: PLR2004 self . pubkey_fingerprint = parts [ 9 ] self . status = \"signature valid\" update_sig_info ( fingerprint = fingerprint , creation_date = creation_date , timestamp = sig_ts , expiry = expire_ts , pubkey_fingerprint = self . pubkey_fingerprint , status = self . status , ) elif key == \"SIG_ID\" : sig_id , creation_date , timestamp = value . split () self . sig_info [ sig_id ] = { \"creation_date\" : creation_date , \"timestamp\" : timestamp } ( self . signature_id , self . creation_date , self . timestamp ) = ( sig_id , creation_date , timestamp ) elif key == \"NO_PUBKEY\" : # pragma: no cover self . valid = False self . key_id = value self . status = \"no public key\" self . problems . append ({ \"status\" : self . status , \"keyid\" : self . key_id }) elif key == \"NO_SECKEY\" : # pragma: no cover self . valid = False self . key_id = value self . status = \"no secret key\" self . problems . append ({ \"status\" : self . status , \"keyid\" : self . key_id }) elif key in ( \"EXPKEYSIG\" , \"REVKEYSIG\" ): # pragma: no cover # signed with expired or revoked key self . valid = False self . key_id = value . split ()[ 0 ] if key == \"EXPKEYSIG\" : self . key_status = \"signing key has expired\" else : self . key_status = \"signing key was revoked\" self . status = self . key_status update_sig_info ( status = self . status , keyid = self . key_id ) self . problems . append ({ \"status\" : self . status , \"keyid\" : self . key_id }) elif key in ( \"UNEXPECTED\" , \"FAILURE\" ): # pragma: no cover self . valid = False if key == \"UNEXPECTED\" : self . status = \"unexpected data\" else : # N.B. there might be other reasons. For example, if an output # file can't be created - /dev/null/foo will lead to a # \"not a directory\" error, but which is not sent as a status # message with the [GNUPG:] prefix. Similarly if you try to # write to \"/etc/foo\" as a non-root user, a \"permission denied\" # error will be sent as a non-status message. message = f \"error - { value } \" operation , code = value . rsplit ( \" \" , 1 ) if code . isdigit (): code = int ( code ) & 0xFFFFFF # lose the error source if self . gpg . error_map and code in self . gpg . error_map : message = f \" { operation } : { self . gpg . error_map [ code ] } \" else : system_error = bool ( code & 0x8000 ) code = code & 0x7FFF mapping = self . GPG_SYSTEM_ERROR_CODES if system_error else self . GPG_ERROR_CODES if code in mapping : message = f \" { operation } : { mapping [ code ] } \" if not self . status : self . status = message elif key == \"NODATA\" : # pragma: no cover # See issue GH-191 self . valid = False self . status = \"signature expected but not found\" elif key in ( \"DECRYPTION_INFO\" , \"PLAINTEXT\" , \"PLAINTEXT_LENGTH\" , \"BEGIN_SIGNING\" , \"KEY_CONSIDERED\" ): pass elif key in ( \"NEWSIG\" ,): # Only sent in gpg2. Clear any signature ID, to be set by a following SIG_ID self . signature_id = None else : # pragma: no cover logger . debug ( \"message ignored: %r , %r \" , key , value )","title":"Module gnupg.handlers.verify_handler"},{"location":"reference/gnupg/handlers/verify_handler/#variables","text":"TYPE_CHECKING logger","title":"Variables"},{"location":"reference/gnupg/handlers/verify_handler/#classes","text":"","title":"Classes"},{"location":"reference/gnupg/handlers/verify_handler/#verifyhandler","text":"class VerifyHandler ( gpg : 'GPG' ) This class handles status messages during signature verificaton. View Source class VerifyHandler ( StatusHandler ) : \"\"\" This class handles status messages during signature verificaton. \"\"\" TRUST_EXPIRED = 0 TRUST_UNDEFINED = 1 TRUST_NEVER = 2 TRUST_MARGINAL = 3 TRUST_FULLY = 4 TRUST_ULTIMATE = 5 TRUST_LEVELS = MappingProxyType ( { \"TRUST_EXPIRED\" : TRUST_EXPIRED , \"TRUST_UNDEFINED\" : TRUST_UNDEFINED , \"TRUST_NEVER\" : TRUST_NEVER , \"TRUST_MARGINAL\" : TRUST_MARGINAL , \"TRUST_FULLY\" : TRUST_FULLY , \"TRUST_ULTIMATE\" : TRUST_ULTIMATE , } , ) # for now , just the most common error codes . This can be expanded as and # when reports come in of other errors . GPG_SYSTEM_ERROR_CODES = MappingProxyType ( { 1 : \"permission denied\" , 35 : \"file exists\" , 81 : \"file not found\" , 97 : \"not a directory\" , } , ) GPG_ERROR_CODES = MappingProxyType ( { 11 : \"incorrect passphrase\" , } , ) returncode = None def __init__ ( self , gpg : GPG ) -> None : StatusHandler . __init__ ( self , gpg ) self . valid = False self . fingerprint = self . creation_date = self . timestamp = None self . signature_id = self . key_id = None self . username = None self . key_id = None self . key_status = None self . status = None self . pubkey_fingerprint = None self . expire_timestamp = None self . sig_timestamp = None self . trust_text = None self . trust_level = None self . sig_info = {} self . problems = [] def __nonzero__ ( self ) -> bool : # pragma : no cover return self . valid __bool__ = __nonzero__ def handle_status ( self , key : str , value : str ) -> None : def update_sig_info ( ** kwargs : object ) -> None : sig_id = self . signature_id if sig_id : info = self . sig_info [ sig_id ] info . update ( kwargs ) else : logger . debug ( \"Ignored due to missing sig iD: %s\" , kwargs ) if key in self . TRUST_LEVELS : self . trust_text = key self . trust_level = self . TRUST_LEVELS [ key ] update_sig_info ( trust_level = self . trust_level , trust_text = self . trust_text ) # See Issue #214 . Once we see this , we 're done with the signature just seen. # Zap the signature ID, because we don' t see a SIG_ID unless we have a new # good signature . self . signature_id = None elif key in ( \"WARNING\" , \"ERROR\" ) : # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key == \"BADSIG\" : # pragma : no cover self . valid = False self . status = \"signature bad\" self . key_id , self . username = value . split ( None , 1 ) self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id , \"user\" : self . username } ) update_sig_info ( keyid = self . key_id , username = self . username , status = self . status ) elif key == \"ERRSIG\" : # pragma : no cover self . valid = False parts = value . split () ( self . key_id , algo , hash_algo , cls , self . timestamp ) = parts [ :5 ] # Since GnuPG 2.2.7 , a fingerprint is tacked on if len ( parts ) >= 7 : # noqa : PLR2004 self . fingerprint = parts [ 6 ] self . status = \"signature error\" update_sig_info ( keyid = self . key_id , timestamp = self . timestamp , fingerprint = self . fingerprint , status = self . status , ) self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id , \"timestamp\" : self . timestamp , \"fingerprint\" : self . fingerprint , } , ) elif key == \"EXPSIG\" : # pragma : no cover self . valid = False self . status = \"signature expired\" self . key_id , self . username = value . split ( None , 1 ) update_sig_info ( keyid = self . key_id , username = self . username , status = self . status ) self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id , \"user\" : self . username } ) elif key == \"GOODSIG\" : self . valid = True self . status = \"signature good\" self . key_id , self . username = value . split ( None , 1 ) update_sig_info ( keyid = self . key_id , username = self . username , status = self . status ) elif key == \"VALIDSIG\" : parts = value . split () fingerprint , creation_date , sig_ts , expire_ts = parts [ :4 ] ( self . fingerprint , self . creation_date , self . sig_timestamp , self . expire_timestamp ) = ( fingerprint , creation_date , sig_ts , expire_ts , ) # may be different if signature is made with a subkey if len ( parts ) >= 10 : # noqa : PLR2004 self . pubkey_fingerprint = parts [ 9 ] self . status = \"signature valid\" update_sig_info ( fingerprint = fingerprint , creation_date = creation_date , timestamp = sig_ts , expiry = expire_ts , pubkey_fingerprint = self . pubkey_fingerprint , status = self . status , ) elif key == \"SIG_ID\" : sig_id , creation_date , timestamp = value . split () self . sig_info [ sig_id ] = { \"creation_date\" : creation_date , \"timestamp\" : timestamp } ( self . signature_id , self . creation_date , self . timestamp ) = ( sig_id , creation_date , timestamp ) elif key == \"NO_PUBKEY\" : # pragma : no cover self . valid = False self . key_id = value self . status = \"no public key\" self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id } ) elif key == \"NO_SECKEY\" : # pragma : no cover self . valid = False self . key_id = value self . status = \"no secret key\" self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id } ) elif key in ( \"EXPKEYSIG\" , \"REVKEYSIG\" ) : # pragma : no cover # signed with expired or revoked key self . valid = False self . key_id = value . split () [ 0 ] if key == \"EXPKEYSIG\" : self . key_status = \"signing key has expired\" else : self . key_status = \"signing key was revoked\" self . status = self . key_status update_sig_info ( status = self . status , keyid = self . key_id ) self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id } ) elif key in ( \"UNEXPECTED\" , \"FAILURE\" ) : # pragma : no cover self . valid = False if key == \"UNEXPECTED\" : self . status = \"unexpected data\" else : # N . B . there might be other reasons . For example , if an output # file can ' t be created - / dev / null / foo will lead to a # \"not a directory\" error , but which is not sent as a status # message with the [ GNUPG: ] prefix . Similarly if you try to # write to \"/etc/foo\" as a non - root user , a \"permission denied\" # error will be sent as a non - status message . message = f \"error - {value}\" operation , code = value . rsplit ( \" \" , 1 ) if code . isdigit () : code = int ( code ) & 0xFFFFFF # lose the error source if self . gpg . error_map and code in self . gpg . error_map : message = f \"{operation}: {self.gpg.error_map[code]}\" else : system_error = bool ( code & 0x8000 ) code = code & 0x7FFF mapping = self . GPG_SYSTEM_ERROR_CODES if system_error else self . GPG_ERROR_CODES if code in mapping : message = f \"{operation}: {mapping[code]}\" if not self . status : self . status = message elif key == \"NODATA\" : # pragma : no cover # See issue GH - 191 self . valid = False self . status = \"signature expected but not found\" elif key in ( \"DECRYPTION_INFO\" , \"PLAINTEXT\" , \"PLAINTEXT_LENGTH\" , \"BEGIN_SIGNING\" , \"KEY_CONSIDERED\" ) : pass elif key in ( \"NEWSIG\" ,) : # Only sent in gpg2 . Clear any signature ID , to be set by a following SIG_ID self . signature_id = None else : # pragma : no cover logger . debug ( \"message ignored: %r, %r\" , key , value )","title":"VerifyHandler"},{"location":"reference/gnupg/handlers/verify_handler/#ancestors-in-mro","text":"gnupg.handlers.status_handler.StatusHandler","title":"Ancestors (in MRO)"},{"location":"reference/gnupg/handlers/verify_handler/#descendants","text":"gnupg.handlers.crypt_handler.CryptHandler","title":"Descendants"},{"location":"reference/gnupg/handlers/verify_handler/#class-variables","text":"GPG_ERROR_CODES GPG_SYSTEM_ERROR_CODES TRUST_EXPIRED TRUST_FULLY TRUST_LEVELS TRUST_MARGINAL TRUST_NEVER TRUST_ULTIMATE TRUST_UNDEFINED returncode","title":"Class variables"},{"location":"reference/gnupg/handlers/verify_handler/#methods","text":"","title":"Methods"},{"location":"reference/gnupg/handlers/verify_handler/#handle_status","text":"def handle_status ( self , key : 'str' , value : 'str' ) -> 'None' Handle status messages from the gpg child process. These are lines of the format [GNUPG:] Parameters: Name Type Description Default key str Identifies what the status message is. None value str Identifies additional data, which differs depending on the key. None View Source def handle_status ( self , key : str , value : str ) -> None : def update_sig_info ( ** kwargs : object ) -> None : sig_id = self . signature_id if sig_id : info = self . sig_info [ sig_id ] info . update ( kwargs ) else : logger . debug ( \"Ignored due to missing sig iD: %s\" , kwargs ) if key in self . TRUST_LEVELS : self . trust_text = key self . trust_level = self . TRUST_LEVELS [ key ] update_sig_info ( trust_level = self . trust_level , trust_text = self . trust_text ) # See Issue #214 . Once we see this , we 're done with the signature just seen. # Zap the signature ID, because we don' t see a SIG_ID unless we have a new # good signature . self . signature_id = None elif key in ( \"WARNING\" , \"ERROR\" ) : # pragma : no cover logger . warning ( \"potential problem: %s: %s\" , key , value ) elif key == \"BADSIG\" : # pragma : no cover self . valid = False self . status = \"signature bad\" self . key_id , self . username = value . split ( None , 1 ) self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id , \"user\" : self . username } ) update_sig_info ( keyid = self . key_id , username = self . username , status = self . status ) elif key == \"ERRSIG\" : # pragma : no cover self . valid = False parts = value . split () ( self . key_id , algo , hash_algo , cls , self . timestamp ) = parts [ :5 ] # Since GnuPG 2.2.7 , a fingerprint is tacked on if len ( parts ) >= 7 : # noqa : PLR2004 self . fingerprint = parts [ 6 ] self . status = \"signature error\" update_sig_info ( keyid = self . key_id , timestamp = self . timestamp , fingerprint = self . fingerprint , status = self . status , ) self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id , \"timestamp\" : self . timestamp , \"fingerprint\" : self . fingerprint , } , ) elif key == \"EXPSIG\" : # pragma : no cover self . valid = False self . status = \"signature expired\" self . key_id , self . username = value . split ( None , 1 ) update_sig_info ( keyid = self . key_id , username = self . username , status = self . status ) self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id , \"user\" : self . username } ) elif key == \"GOODSIG\" : self . valid = True self . status = \"signature good\" self . key_id , self . username = value . split ( None , 1 ) update_sig_info ( keyid = self . key_id , username = self . username , status = self . status ) elif key == \"VALIDSIG\" : parts = value . split () fingerprint , creation_date , sig_ts , expire_ts = parts [ :4 ] ( self . fingerprint , self . creation_date , self . sig_timestamp , self . expire_timestamp ) = ( fingerprint , creation_date , sig_ts , expire_ts , ) # may be different if signature is made with a subkey if len ( parts ) >= 10 : # noqa : PLR2004 self . pubkey_fingerprint = parts [ 9 ] self . status = \"signature valid\" update_sig_info ( fingerprint = fingerprint , creation_date = creation_date , timestamp = sig_ts , expiry = expire_ts , pubkey_fingerprint = self . pubkey_fingerprint , status = self . status , ) elif key == \"SIG_ID\" : sig_id , creation_date , timestamp = value . split () self . sig_info [ sig_id ] = { \"creation_date\" : creation_date , \"timestamp\" : timestamp } ( self . signature_id , self . creation_date , self . timestamp ) = ( sig_id , creation_date , timestamp ) elif key == \"NO_PUBKEY\" : # pragma : no cover self . valid = False self . key_id = value self . status = \"no public key\" self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id } ) elif key == \"NO_SECKEY\" : # pragma : no cover self . valid = False self . key_id = value self . status = \"no secret key\" self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id } ) elif key in ( \"EXPKEYSIG\" , \"REVKEYSIG\" ) : # pragma : no cover # signed with expired or revoked key self . valid = False self . key_id = value . split () [ 0 ] if key == \"EXPKEYSIG\" : self . key_status = \"signing key has expired\" else : self . key_status = \"signing key was revoked\" self . status = self . key_status update_sig_info ( status = self . status , keyid = self . key_id ) self . problems . append ( { \"status\" : self . status , \"keyid\" : self . key_id } ) elif key in ( \"UNEXPECTED\" , \"FAILURE\" ) : # pragma : no cover self . valid = False if key == \"UNEXPECTED\" : self . status = \"unexpected data\" else : # N . B . there might be other reasons . For example , if an output # file can ' t be created - / dev / null / foo will lead to a # \"not a directory\" error , but which is not sent as a status # message with the [ GNUPG: ] prefix . Similarly if you try to # write to \"/etc/foo\" as a non - root user , a \"permission denied\" # error will be sent as a non - status message . message = f \"error - {value}\" operation , code = value . rsplit ( \" \" , 1 ) if code . isdigit () : code = int ( code ) & 0xFFFFFF # lose the error source if self . gpg . error_map and code in self . gpg . error_map : message = f \"{operation}: {self.gpg.error_map[code]}\" else : system_error = bool ( code & 0x8000 ) code = code & 0x7FFF mapping = self . GPG_SYSTEM_ERROR_CODES if system_error else self . GPG_ERROR_CODES if code in mapping : message = f \"{operation}: {mapping[code]}\" if not self . status : self . status = message elif key == \"NODATA\" : # pragma : no cover # See issue GH - 191 self . valid = False self . status = \"signature expected but not found\" elif key in ( \"DECRYPTION_INFO\" , \"PLAINTEXT\" , \"PLAINTEXT_LENGTH\" , \"BEGIN_SIGNING\" , \"KEY_CONSIDERED\" ) : pass elif key in ( \"NEWSIG\" ,) : # Only sent in gpg2 . Clear any signature ID , to be set by a following SIG_ID self . signature_id = None else : # pragma : no cover logger . debug ( \"message ignored: %r, %r\" , key , value )","title":"handle_status"}]}